<?xml version="1.0" ?>
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="basic_regex">
  <refmeta>
    <refentrytitle>basic_regex 構造体テンプレート</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>boost::xpressive::basic_regex</refname>
    <refpurpose><classname>basic_regex&lt;&gt;</classname> クラステンプレートはコンパイル済み正規表現を保持するクラスである。</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <synopsis language="C++">// ヘッダ：&lt;<filename linkend="header.basic_regex_hpp">boost/xpressive/basic_regex.hpp</filename>&gt;

template&lt;typename BidiIter&gt;
struct basic_regex {
  // 型
  typedef BidiIter                            iterator_type;
  typedef iterator_value&lt; BidiIter &gt;::type    char_type;
  typedef iterator_value&lt; BidiIter &gt;::type    value_type;
  typedef unspecified                         string_type;
  typedef regex_constants::syntax_option_type flag_type;

  // <link linkend="construct-copy-destruct">構築、コピー、解体</link>
  basic_regex();
  basic_regex(basic_regex&lt; BidiIter &gt; const &amp;);
  template&lt;typename Expr&gt; basic_regex(Expr const &amp;);
  basic_regex&lt; BidiIter &gt;&amp; operator=(basic_regex&lt; BidiIter &gt; const &amp;);
  template&lt;typename Expr&gt; basic_regex&lt; BidiIter &gt;&amp; operator=(Expr const &amp;);

  // <link linkend="public-member-functions">公開メンバ関数</link>
  std::size_t mark_count() const;
  regex_id_type regex_id() const;
  void swap(basic_regex&lt; BidiIter &gt; &amp;);

  // <link linkend="public-static-functions">公開静的メンバ関数</link>
  template&lt;typename InputIter&gt; 
    static basic_regex&lt; BidiIter &gt; 
    compile(InputIter, InputIter, flag_type = regex_constants::ECMAScript);
  template&lt;typename InputRange&gt; 
    static basic_regex&lt; BidiIter &gt; 
    compile(InputRange const &amp;, flag_type = regex_constants::ECMAScript);
  static basic_regex&lt; BidiIter &gt; 
  compile(char_type const *, flag_type = regex_constants::ECMAScript);
  static basic_regex&lt; BidiIter &gt; 
  compile(char_type const *, std::size_t, flag_type);
  static regex_constants::syntax_option_type const ECMAScript;
  static regex_constants::syntax_option_type const icase;
  static regex_constants::syntax_option_type const nosubs;
  static regex_constants::syntax_option_type const optimize;
  static regex_constants::syntax_option_type const collate;
  static regex_constants::syntax_option_type const single_line;
  static regex_constants::syntax_option_type const not_dot_null;
  static regex_constants::syntax_option_type const not_dot_newline;
  static regex_constants::syntax_option_type const ignore_white_space;
};</synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>説明</title>

    <refsection xml:id="construct-copy-destruct">
      <title>basic_regex 構築、コピー、解体の公開演算</title>
      <orderedlist>
	<listitem>
	  <constructorsynopsis language="C++">
	    <methodname>basic_regex</methodname>
	    <void/>
	  </constructorsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">regex_id() == 0</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">mark_count() == 0</code></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem>
	  <constructorsynopsis language="C++">
	    <methodname>basic_regex</methodname>
	    <methodparam>
	      <type>basic_regex&lt; BidiIter &gt; const &amp;</type>
	      <parameter>that</parameter>
	    </methodparam>
	  </constructorsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">that</parameter></term>
		    <listitem>
		      <para>コピーする <classname>basic_regex</classname> オブジェクト。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">regex_id() == that.regex_id()</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">mark_count() == that.mark_count()</code></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem>
	  <constructorsynopsis language="C++">
	    <modifier>template&lt;typename Expr&gt;</modifier>
	    <methodname>basic_regex</methodname>
	    <methodparam>
	      <type>Expr const &amp;</type>
	      <parameter>expr</parameter>
	    </methodparam>
	  </constructorsynopsis>
	  <para>静的正規表現から構築する。</para>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">expr</parameter></term>
		    <listitem>
		      <para>静的正規表現。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>要件：</term>
	      <listitem>
		<para><parameter>Expr</parameter> は静的正規表現の型。</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">regex_id() != 0</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">mark_count() >= 0</code></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <type>basic_regex&lt; BidiIter &gt;&amp;</type>
	    <methodname>operator=</methodname>
	    <methodparam>
	      <type>basic_regex&lt; BidiIter &gt; const &amp;</type>
	      <parameter>that</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">that</parameter></term>
		    <listitem>
		      <para>コピーする <classname>basic_regex</classname> オブジェクト。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">regex_id() == that.regex_id()</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">mark_count() == that.mark_count()</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>戻り値：</term>
	      <listitem>
		<para><returnvalue>*this</returnvalue></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <modifier>template&lt;typename Expr&gt;</modifier>
	    <type>basic_regex&lt; BidiIter &gt;&amp;</type>
	    <methodname>operator=</methodname>
	    <methodparam>
	      <type>Expr const &amp;</type>
	      <parameter>expr</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>静的正規表現から構築する。</para>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">expr</parameter></term>
		    <listitem>
		      <para>静的正規表現。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>要件：</term>
	      <listitem>
		<para><parameter>Expr</parameter> は静的正規表現の型。</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">regex_id() != 0</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事後条件：</term>
	      <listitem>
		<para><code language="C++">mark_count() >= 0</code></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>戻り値：</term>
	      <listitem>
		<para><returnvalue>*this</returnvalue></para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>例外：</term>
	      <listitem>
		<para>メモリ不足のとき <exceptionname>std::bad_alloc</exceptionname></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </orderedlist>
    </refsection>

    <refsection xml:id="public-member-functions">
      <title>basic_regex の公開メンバ関数</title>
      <orderedlist>
	<listitem>
	  <methodsynopsis language="C++">
	    <type>std::size_t</type>
	    <methodname>mark_count</methodname>
	    <void/>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <para>この正規表現内の捕捉済み部分式の数を返す。</para>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <type>regex_id_type</type>
	    <methodname>regex_id</methodname>
	    <void/>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <para>この正規表現を一意に識別するトークンを返す。</para>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <type>void</type>
	    <methodname>swap</methodname>
	    <methodparam>
	      <type>basic_regex&lt; BidiIter &gt; &amp;</type>
	      <parameter>that</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>この <classname>basic_regex</classname> オブジェクトの内容を別のものと交換する。</para>
	  <note>
	    <para>
	      参照まで追跡しない浅い交換である。<classname>basic_regex</classname> オブジェクトを参照により別の正規表現に組み込み、他の <classname>basic_regex</classname> オブジェクトと内容を交換すると、外側の正規表現からはこの変更を検出できない。これは <methodname>swap()</methodname> が例外を送出できないためである。
	    </para>
	  </note>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">that</parameter></term>
		    <listitem>
		      <para>他の <classname>basic_regex</classname> オブジェクト。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>例外：</term>
	      <listitem>
		<para>例外を送出しない。</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </orderedlist>
    </refsection>

    <refsection xml:id="public-static-functions">
      <title>basic_regex の公開静的メンバ関数</title>
      <orderedlist>
	<listitem>
	  <methodsynopsis language="C++">
	    <modifier>template&lt;typename InputIter&gt; static</modifier>
	    <type>basic_regex&lt; BidiIter &gt;</type>
	    <methodname>compile</methodname>
	    <methodparam>
	      <type>InputIter</type>
	      <parameter>begin</parameter>
	    </methodparam>
	    <methodparam>
	      <type>InputIter</type>
	      <parameter>end</parameter>
	    </methodparam>
	    <methodparam>
	      <type>flag_type</type>
	      <parameter>flags</parameter>
	      <initializer>regex_constants::ECMAScript</initializer>
	    </methodparam>
	  </methodsynopsis>
	  <para>
	    文字の範囲から正規表現オブジェクトを構築するファクトリメソッド。<code language="C++">regex_compiler&lt; BidiIter &gt;().compile(begin, end, flags);</code> と等価。
	  </para>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>引数：</term>
	      <listitem>
		<variablelist spacing="compact">
		  <varlistentry>
		    <term><parameter class="function">begin</parameter></term>
		    <listitem>
		      <para>コンパイルする正規表現を表す文字範囲の先頭。</para>
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="function">end</parameter></term>
		    <listitem>
		      <para>コンパイルする正規表現を表す文字範囲の終端。</para>
		    </listitem>
		  </varlistentry>
		  <varlistentry>
		    <term><parameter class="function">flags</parameter></term>
		    <listitem>
		      <para>文字列をどのように解釈するかを指定する省略可能なビットマスク（<type role="enum">syntax_option_type</type> を見よ）。</para>
		    </listitem>
		  </varlistentry>
		</variablelist>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>要件：</term>
	      <listitem>
		<para><code>[begin, end)</code> が有効な範囲である。<code>[begin, end)</code> で指定した文字の範囲が正規表現の有効な文字列表現である。</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>戻り値：</term>
	      <listitem>
		<para>文字の範囲が表す正規表現に相当する <classname>basic_regex</classname> オブジェクト。</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>例外：</term>
	      <listitem>
		<para><exceptionname>regex_error</exceptionname></para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <modifier>template&lt;typename InputRange&gt; static</modifier>
	    <type>basic_regex&lt; BidiIter &gt;</type>
	    <methodname>compile</methodname>
	    <methodparam>
	      <type>InputRange const &amp;</type>
	      <parameter>pat</parameter>
	    </methodparam>
	    <methodparam>
	      <type>flag_type</type>
	      <parameter>flags</parameter>
	    </methodparam>
	  </methodsynopsis>
	  <para>利便性のためのメンバ関数多重定義。上記関数と受け取る引数が異なるのみ。</para>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <modifier>static</modifier>
	    <type>basic_regex&lt; BidiIter &gt;</type>
	    <methodname>compile</methodname>
	    <methodparam>
	      <type>char_type const *</type>
	      <parameter>begin</parameter>
	    </methodparam>
	    <methodparam>
              <type>flag_type</type>
	      <parameter>flags</parameter>
	      <initializer>regex_constants::ECMAScript</initializer>
	    </methodparam>
	  </methodsynopsis>
	  <para>利便性のためのメンバ関数多重定義。上記関数と受け取る引数が異なるのみ。</para>
	</listitem>

	<listitem>
	  <methodsynopsis language="C++">
	    <modifier>static</modifier>
	    <type>basic_regex&lt; BidiIter &gt;</type>
	    <methodname>compile</methodname>
	    <methodparam>
	      <type>char_type const *</type>
	      <parameter>begin</parameter>
	    </methodparam>
	    <methodparam>
	      <type>std::size_t</type>
	      <parameter>len</parameter>
	    </methodparam>
	    <methodparam>
	      <type>flag_type</type>
	      <parameter>flags</parameter>
	    </methodparam>
	  </methodsynopsis>
<para>利便性のためのメンバ関数多重定義。上記関数と受け取る引数が異なるのみ。</para>
	</listitem>
      </orderedlist>
    </refsection>
  </refsection>
</refentry>

<?xml version="1.0" ?>
<!--
  Copyright (c) 2008 Eric Niebler
  Distributed under the Boost Software License, Version 1.0. (See accompanying
  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
-->
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0">
  <title>リファレンス</title>

  <section xml:id="header.basic_regex_hpp">
    <title>&lt;boost/xpressive/basic_regex.hpp&gt; ヘッダ</title>
    <para>
      <classname>basic_regex&lt;&gt;</classname> クラステンプレートの定義と、関連するヘルパ関数がある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="basic_regex">basic_regex</classname>;
    template&lt;typename BidiIter&gt;
      void <function linkend="swap">swap</function>(<classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; &amp;);
  }
}</synopsis>
    <xi:include href="basic_regex.xml"/>
    <xi:include href="swap.xml"/>
  </section>

  <section xml:id="header.match_results_hpp">
    <title>&lt;boost/xpressive/match_results.hpp&gt; ヘッダ</title>
    <para>
      <classname>match_results</classname> 型の定義と、関連するヘルパがある。<classname>match_results</classname> 型は <function>regex_match()</function> および <function>regex_search()</function> 操作の結果を保持する。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="match_results">match_results</classname>;
    template&lt;typename BidiIter&gt; struct <classname linkend="regex_id_filter_predicate">regex_id_filter_predicate</classname>;
  }
}</synopsis>
    
    <xi:include href="match_results.xml"/>
    <xi:include href="regex_id_filter_predicate.xml"/>
  </section>

  <section xml:id="header.regex_actions_hpp">
    <title>&lt;boost/xpressive/regex_actions.hpp&gt; ヘッダ</title>
    <para>
      xpressive におけるアクション式の構文要素がある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename <link xlink:href="http://www.boost.org/doc/html/PolymorphicFunctionObject.html">PolymorphicFunctionObject</link>&gt; struct <classname linkend="function">function</classname>;
    template&lt;typename T&gt; struct <classname linkend="local">local</classname>;
    template&lt;typename T, int I, typename Dummy&gt; struct <classname linkend="placeholder">placeholder</classname>;
    template&lt;typename T&gt; struct <classname linkend="reference">reference</classname>;
    template&lt;typename T&gt; struct <classname linkend="value">value</classname>;

    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.at">op::at</classname> &gt;::type const <constant linkend="at">at</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.push">op::push</classname> &gt;::type const <constant linkend="push">push</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.push_back">op::push_back</classname> &gt;::type const <constant linkend="push_back">push_back</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.push_front">op::push_front</classname> &gt;::type const <constant linkend="push_front">push_front</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.pop">op::pop</classname> &gt;::type const <constant linkend="pop">pop</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.pop_back">op::pop_back</classname> &gt;::type const <constant linkend="pop_back">pop_back</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.pop_front">op::pop_front</classname> &gt;::type const <constant linkend="pop_front">pop_front</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.top">op::top</classname> &gt;::type const <constant linkend="top">top</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.back">op::back</classname> &gt;::type const <constant linkend="back">back</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.front">op::front</classname> &gt;::type const <constant linkend="front">front</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.first">op::first</classname> &gt;::type const <constant linkend="first">first</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.second">op::second</classname> &gt;::type const <constant linkend="second">second</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.matched">op::matched</classname> &gt;::type const <constant linkend="matched">matched</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.length">op::length</classname> &gt;::type const <constant linkend="length">length</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.str">op::str</classname> &gt;::type const <constant linkend="str">str</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.insert">op::insert</classname> &gt;::type const <constant linkend="insert">insert</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.make_pair">op::make_pair</classname> &gt;::type const <constant linkend="make_pair">make_pair</constant>;
    <classname xlink:href="http://www.boost.org/doc/html/function.html">function</classname>&lt; <classname linkend="op.unwrap_reference">op::unwrap_reference</classname> &gt;::type const <constant linkend="unwrap_reference">unwrap_reference</constant>;
    template&lt;typename T, typename A&gt; <replaceable>unspecified</replaceable> <function linkend="as">as</function>(A const &amp;);
    template&lt;typename T, typename A&gt; <replaceable>unspecified</replaceable> <function linkend="static_cast_">static_cast_</function>(A const &amp;);
    template&lt;typename T, typename A&gt; <replaceable>unspecified</replaceable> <function linkend="dynamic_cast_">dynamic_cast_</function>(A const &amp;);
    template&lt;typename T, typename A&gt; <replaceable>unspecified</replaceable> <function linkend="const_cast_">const_cast_</function>(A const &amp;);
    template&lt;typename T&gt; value&lt; T &gt; const <function linkend="val">val</function>(T const &amp;);
    template&lt;typename T&gt; reference&lt; T &gt; const <function linkend="ref">ref</function>(T &amp;);
    template&lt;typename T&gt; reference&lt; T const  &gt; const <function linkend="cref">cref</function>(T const &amp;);
    template&lt;typename T&gt; <replaceable>unspecified</replaceable> <function linkend="check">check</function>(T const &amp;);
    template&lt;typename... ArgBindings&gt; <replaceable>unspecified</replaceable> <function linkend="let">let</function>(ArgBindings const &amp;...);
    template&lt;typename T, typename... Args&gt;
      <replaceable>unspecified</replaceable> <function linkend="construct">construct</function>(Args const &amp;...);
    namespace op {
      template&lt;typename T&gt; struct <classname linkend="op.as">as</classname>;
      struct <classname linkend="op.at">at</classname>;
      struct <classname linkend="op.back">back</classname>;
      template&lt;typename T&gt; struct <classname linkend="op.const_cast_">const_cast_</classname>;
      template&lt;typename T&gt; struct <classname linkend="op.construct">construct</classname>;
      template&lt;typename T&gt; struct <classname linkend="op.dynamic_cast_">dynamic_cast_</classname>;
      struct <classname linkend="op.first">first</classname>;
      struct <classname linkend="op.front">front</classname>;
      struct <classname linkend="op.insert">insert</classname>;
      struct <classname linkend="op.length">length</classname>;
      struct <classname linkend="op.make_pair">make_pair</classname>;
      struct <classname linkend="op.matched">matched</classname>;
      struct <classname linkend="op.pop">pop</classname>;
      struct <classname linkend="op.pop_back">pop_back</classname>;
      struct <classname linkend="op.pop_front">pop_front</classname>;
      struct <classname linkend="op.push">push</classname>;
      struct <classname linkend="op.push_back">push_back</classname>;
      struct <classname linkend="op.push_front">push_front</classname>;
      struct <classname linkend="op.second">second</classname>;
      template&lt;typename T&gt; struct <classname linkend="op.static_cast_">static_cast_</classname>;
      struct <classname linkend="op.str">str</classname>;
      template&lt;typename Except&gt; struct <classname linkend="op.throw_">throw_</classname>;
      struct <classname linkend="op.top">top</classname>;
      struct <classname linkend="op.unwrap_reference">unwrap_reference</classname>;
    }
  }
}</synopsis>

    <xi:include href="function.xml"/>
    <xi:include href="local.xml"/>
    <xi:include href="placeholder.xml"/>
    <xi:include href="reference.xml"/>
    <xi:include href="value.xml"/>
    <xi:include href="at.xml"/>
    <xi:include href="push.xml"/>
    <xi:include href="push_back.xml"/>
    <xi:include href="push_front.xml"/>
    <xi:include href="pop.xml"/>
    <xi:include href="pop_back.xml"/>
    <xi:include href="pop_front.xml"/>
    <xi:include href="top.xml"/>
    <xi:include href="back.xml"/>
    <xi:include href="front.xml"/>
    <xi:include href="first.xml"/>
    <xi:include href="second.xml"/>
    <xi:include href="matched.xml"/>
    <xi:include href="length.xml"/>
    <xi:include href="str.xml"/>
    <xi:include href="insert.xml"/>
    <xi:include href="make_pair.xml"/>
    <xi:include href="unwrap_reference.xml"/>
    <xi:include href="as.xml"/>
    <xi:include href="static_cast_.xml"/>
    <xi:include href="dynamic_cast_.xml"/>
    <xi:include href="const_cast_.xml"/>
    <xi:include href="val.xml"/>
    <xi:include href="ref.xml"/>
    <xi:include href="cref.xml"/>
    <xi:include href="check.xml"/>
    <xi:include href="let.xml"/>
    <xi:include href="construct.xml"/>

    <xi:include href="op.as.xml"/>
    <xi:include href="op.at.xml"/>
    <xi:include href="op.back.xml"/>
    <xi:include href="op.const_cast_.xml"/>
    <xi:include href="op.construct.xml"/>
    <xi:include href="op.dynamic_cast_.xml"/>
    <xi:include href="op.first.xml"/>
    <xi:include href="op.front.xml"/>
    <xi:include href="op.insert.xml"/>
    <xi:include href="op.length.xml"/>
    <xi:include href="op.make_pair.xml"/>
    <xi:include href="op.matched.xml"/>
    <xi:include href="op.pop.xml"/>
    <xi:include href="op.pop_back.xml"/>
    <xi:include href="op.pop_front.xml"/>
    <xi:include href="op.push.xml"/>
    <xi:include href="op.push_back.xml"/>
    <xi:include href="op.push_front.xml"/>
    <xi:include href="op.second.xml"/>
    <xi:include href="op.static_cast_.xml"/>
    <xi:include href="op.str.xml"/>
    <xi:include href="op.throw_.xml"/>
    <xi:include href="op.top.xml"/>
    <xi:include href="op.unwrap_reference.xml"/>
  </section>

  <section xml:id="header.regex_algorithms_hpp">
    <title>&lt;boost/xpressive/regex_algorithms.hpp&gt; ヘッダ</title>
    <para>
      <function>regex_match()</function> 、<function>regex_search()</function> および <function>regex_replace()</function> アルゴリズムがある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiIter, BidiIter, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                       <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiIter, BidiIter, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename Char&gt; 
      bool <function linkend="regex_match">regex_match</function>(Char *, <classname linkend="match_results">match_results</classname>&lt; Char * &gt; &amp;, 
                       <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiRange &amp;, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                       <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default, 
                       <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiRange const &amp;, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                       <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default, 
                       <replaceable>unspecified</replaceable> = 0);
    template&lt;typename Char&gt; 
      bool <function linkend="regex_match">regex_match</function>(Char *, <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiRange &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default, 
                       <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_match">regex_match</function>(BidiRange const &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                       regex_constants::match_flag_type = regex_constants::match_default, 
                       <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiIter, BidiIter, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                        <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiIter, BidiIter, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename Char&gt; 
      bool <function linkend="regex_search">regex_search</function>(Char *, <classname linkend="match_results">match_results</classname>&lt; Char * &gt; &amp;, 
                        <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiRange &amp;, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                        <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default, 
                        <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiRange const &amp;, <classname linkend="match_results">match_results</classname>&lt; BidiIter &gt; &amp;, 
                        <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default, 
                        <replaceable>unspecified</replaceable> = 0);
    template&lt;typename Char&gt; 
      bool <function linkend="regex_search">regex_search</function>(Char *, <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiRange &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default, 
                        <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiRange, typename BidiIter&gt; 
      bool <function linkend="regex_search">regex_search</function>(BidiRange const &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                        regex_constants::match_flag_type = regex_constants::match_default, 
                        <replaceable>unspecified</replaceable> = 0);
    template&lt;typename OutIter, typename BidiIter, typename Formatter&gt; 
      OutIter <function linkend="regex_replace">regex_replace</function>(OutIter, BidiIter, BidiIter, 
                            <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                            Formatter const &amp;, 
                            regex_constants::match_flag_type = regex_constants::match_default, 
                            <replaceable>unspecified</replaceable> = 0);
    template&lt;typename OutIter, typename BidiIter&gt; 
      OutIter <function linkend="regex_replace">regex_replace</function>(OutIter, BidiIter, BidiIter, 
                            <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                            typename iterator_value&lt; BidiIter &gt;::type const *, 
                            regex_constants::match_flag_type = regex_constants::match_default);
    template&lt;typename BidiContainer, typename BidiIter, typename Formatter&gt; 
      BidiContainer 
      <function linkend="regex_replace">regex_replace</function>(BidiContainer &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                    Formatter const &amp;, 
                    regex_constants::match_flag_type = regex_constants::match_default, 
                    <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiContainer, typename BidiIter, typename Formatter&gt; 
      BidiContainer 
      <function linkend="regex_replace">regex_replace</function>(BidiContainer const &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                    Formatter const &amp;, 
                    regex_constants::match_flag_type = regex_constants::match_default, 
                    <replaceable>unspecified</replaceable> = 0);
    template&lt;typename Char, typename Formatter&gt; 
      std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt; 
      <function linkend="regex_replace">regex_replace</function>(Char *, <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, Formatter const &amp;, 
                    regex_constants::match_flag_type = regex_constants::match_default, 
                    <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiContainer, typename BidiIter&gt; 
      BidiContainer 
      <function linkend="regex_replace">regex_replace</function>(BidiContainer &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                    typename iterator_value&lt; BidiIter &gt;::type const *, 
                    regex_constants::match_flag_type = regex_constants::match_default, 
                    <replaceable>unspecified</replaceable> = 0);
    template&lt;typename BidiContainer, typename BidiIter&gt; 
      BidiContainer 
      <function linkend="regex_replace">regex_replace</function>(BidiContainer const &amp;, <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;, 
                    typename iterator_value&lt; BidiIter &gt;::type const *, 
                    regex_constants::match_flag_type = regex_constants::match_default, 
                    <replaceable>unspecified</replaceable> = 0);
    template&lt;typename Char&gt; 
      std::basic_string&lt; typename remove_const&lt; Char &gt;::type &gt; 
      <function linkend="regex_replace">regex_replace</function>(Char *, <classname linkend="basic_regex">basic_regex</classname>&lt; Char * &gt; const &amp;, 
                    typename add_const&lt; Char &gt;::type *, 
                    regex_constants::match_flag_type = regex_constants::match_default);
  }
}</synopsis>

    <xi:include href="regex_match.xml"/>
    <xi:include href="regex_search.xml"/>
    <xi:include href="regex_replace.xml"/>
  </section>

  <section xml:id="header.regex_compiler_hpp">
    <title>&lt;boost/xpressive/regex_compiler.hpp&gt; ヘッダ</title>
    <para>
      正規表現を文字列から構築するファクトリである <classname>regex_compiler</classname> の定義がある。
    </para>

    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter, typename RegexTraits, typename CompilerTraits&gt;
      struct <classname linkend="regex_compiler">regex_compiler</classname>;
  }
}</synopsis>

    <xi:include href="regex_compiler.xml"/>
  </section>

  <section xml:id="header.regex_constants_hpp">
    <title>&lt;boost/xpressive/regex_constants.hpp&gt; ヘッダ</title>
    <para>
      <type role="enum">syntax_option_type</type> 、<type role="enum">match_flag_type</type> および <type role="enum">error_type</type> 列挙の定義がある。
    </para>

    <synopsis language="C++">namespace boost {
  namespace xpressive {
    namespace regex_constants {
      enum <type linkend="regex_constants.syntax_option_type">syntax_option_type</type>;
      enum <type linkend="regex_constants.match_flag_type">match_flag_type</type>;
      enum <type linkend="regex_constants.error_type">error_type</type>;
    }
  }
}</synopsis>

    <xi:include href="regex_constants.syntax_option_type.xml"/>
    <xi:include href="regex_constants.match_flag_type.xml"/>
    <xi:include href="regex_constants.error_type.xml"/>
  </section>

  <section xml:id="header.regex_error_hpp">
    <title>&lt;boost/xpressive/regex_error.hpp&gt; ヘッダ</title>
    <para>
      <classname>regex_error</classname> 例外クラスの定義がある。
    </para>
    <synopsis language="C++"><symbol xlink:href="http://www.boost.org/doc/html/BOOST_XPR_ENSURE_.html">BOOST_XPR_ENSURE_</symbol>(pred, code, msg)</synopsis>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    struct <classname linkend="regex_error">regex_error</classname>;
  }
}</synopsis>

    <xi:include href="regex_error.xml"/>
  </section>

  <section>
    <title>&lt;boost/xpressive/regex_iterator.hpp&gt; ヘッダ</title>
    <para>
      シーケンス内のすべてのマッチを辿る STL 互換のイテレータである <classname>regex_iterator</classname> 型の定義がある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="regex_iterator">regex_iterator</classname>;
  }
}</synopsis>

    <xi:include href="regex_iterator.xml"/>
  </section>

  <section xml:id="header.regex_primitives_hpp">
    <title>&lt;boost/xpressive/regex_primitives.hpp&gt; ヘッダ</title>
    <para>
      静的正規表現を記述するための構文要素がある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    struct <classname linkend="mark_tag">mark_tag</classname>;

    unsigned int const <constant linkend="inf">inf</constant>;    // 部分式の無限回の繰り返しに使う。
    <replaceable>unspecified</replaceable> <constant linkend="nil">nil</constant>;    // 空のマッチ。
    <replaceable>unspecified</replaceable> <constant linkend="alnum">alnum</constant>;    // 英数字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="alpha">alpha</constant>;    // アルファベットにマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="blank">blank</constant>;    // 空白（水平空白）文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="cntrl">cntrl</constant>;    // 制御文字にマッチ。
    <replaceable>unspecified</replaceable> <constant linkend="digit">digit</constant>;    // 数字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="graph">graph</constant>;    // グラフィカルな文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="lower">lower</constant>;    // 小文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="print">print</constant>;    // 印字可能な文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="punct">punct</constant>;    // 区切り文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="space">space</constant>;    // 空白類文字にマッチ。
    <replaceable>unspecified</replaceable> <constant linkend="upper">upper</constant>;    // 大文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="xdigit">xdigit</constant>;    // 16 進数字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="bos">bos</constant>;    // シーケンスの先頭を表す表明。 
    <replaceable>unspecified</replaceable> <constant linkend="eos">eos</constant>;    // シーケンスの終端を表す表明。
    <replaceable>unspecified</replaceable> <constant linkend="bol">bol</constant>;    // 行頭を表す表明。
    <replaceable>unspecified</replaceable> <constant linkend="eol">eol</constant>;    // 行末を表す表明。 
    <replaceable>unspecified</replaceable> <constant linkend="bow">bow</constant>;    // 語頭を表す表明。 
    <replaceable>unspecified</replaceable> <constant linkend="eow">eow</constant>;    // 語末を表す表明。 
    <replaceable>unspecified</replaceable> <constant linkend="_b">_b</constant>;    // 単語境界を表す表明。 
    <replaceable>unspecified</replaceable> <constant linkend="_w">_w</constant>;    // 単語構成文字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="_d">_d</constant>;    // 数字にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="_s">_s</constant>;    // 空白類文字にマッチ。 
    proto::terminal&lt; char &gt;::type const <constant linkend="_n">_n</constant>;    // リテラルの改行 '\n' にマッチ。 
    <replaceable>unspecified</replaceable> <constant linkend="_ln">_ln</constant>;    // 論理改行シーケンスにマッチ。
    <replaceable>unspecified</replaceable> <constant linkend="_">_</constant>;    // あらゆる文字にマッチ。
    <replaceable>unspecified</replaceable> <constant linkend="self">self</constant>;    // 現在の正規表現オブジェクトへの参照。 
    <replaceable>unspecified</replaceable> <constant linkend="set">set</constant>;    // 文字セットを作成するのに使用。
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s0">s0</constant>;    // Perl の $&amp; 部分マッチプレースホルダ。 
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s1">s1</constant>;    // Perl の $1 部分マッチプレースホルダ。 
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s2">s2</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s3">s3</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s4">s4</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s5">s5</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s6">s6</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s7">s7</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s8">s8</constant>;
    <classname linkend="mark_tag">mark_tag</classname> const <constant linkend="s9">s9</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a1">a1</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a2">a2</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a3">a3</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a4">a4</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a5">a5</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a6">a6</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a7">a7</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a8">a8</constant>;
    <replaceable>unspecified</replaceable> <constant linkend="a9">a9</constant>;
    template&lt;typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; <replaceable>unspecified</replaceable> <function linkend="icase">icase</function>(Expr const &amp;);
    template&lt;typename Literal&gt; <replaceable>unspecified</replaceable> <function linkend="as_xpr">as_xpr</function>(Literal const &amp;);
    template&lt;typename BidiIter&gt; 
      proto::terminal&lt; reference_wrapper&lt; <classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const  &gt; &gt;::type const 
      <function linkend="by_ref">by_ref</function>(<classname linkend="basic_regex">basic_regex</classname>&lt; BidiIter &gt; const &amp;);
    template&lt;typename Char&gt; <replaceable>unspecified</replaceable> <function linkend="range">range</function>(Char, Char);
    template&lt;typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; 
      proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Expr const &amp;
&gt;::type const 
      <function linkend="optional">optional</function>(Expr const &amp;);
    template&lt;unsigned int Min, unsigned int Max, typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; 
      <replaceable>unspecified</replaceable> <function linkend="repeat">repeat</function>(Expr const &amp;);
    template&lt;unsigned int Count, typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr2</type>&gt; 
      <replaceable>unspecified</replaceable> <function linkend="repeat">repeat</function>(Expr2 const &amp;);
    template&lt;typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; <replaceable>unspecified</replaceable> <function linkend="keep">keep</function>(Expr const &amp;);
    template&lt;typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; <replaceable>unspecified</replaceable> <function linkend="before">before</function>(Expr const &amp;);
    template&lt;typename <type xlink:href="http://www.boost.org/doc/html/Expr.html">Expr</type>&gt; <replaceable>unspecified</replaceable> <function linkend="after">after</function>(Expr const &amp;);
    template&lt;typename Locale&gt; <replaceable>unspecified</replaceable> <function linkend="imbue">imbue</function>(Locale const &amp;);
    template&lt;typename Skip&gt; <replaceable>unspecified</replaceable> <function linkend="skip">skip</function>(Skip const &amp;);
  }
}</synopsis>

    <xi:include href="mark_tag.xml"/>
    <xi:include href="inf.xml"/>
    <xi:include href="nil.xml"/>
    <xi:include href="alnum.xml"/>
    <xi:include href="alpha.xml"/>
    <xi:include href="blank.xml"/>
    <xi:include href="cntrl.xml"/>
    <xi:include href="digit.xml"/>
    <xi:include href="graph.xml"/>
    <xi:include href="lower.xml"/>
    <xi:include href="print.xml"/>
    <xi:include href="punct.xml"/>
    <xi:include href="space.xml"/>
    <xi:include href="upper.xml"/>
    <xi:include href="xdigit.xml"/>
    <xi:include href="bos.xml"/>
    <xi:include href="eos.xml"/>
    <xi:include href="bol.xml"/>
    <xi:include href="eol.xml"/>
    <xi:include href="bow.xml"/>
    <xi:include href="eow.xml"/>
    <xi:include href="_b.xml"/>
    <xi:include href="_w.xml"/>
    <xi:include href="_d.xml"/>
    <xi:include href="_s.xml"/>
    <xi:include href="_n.xml"/>
    <xi:include href="_ln.xml"/>
    <xi:include href="_.xml"/>
    <xi:include href="self.xml"/>
    <xi:include href="set.xml"/>
    <xi:include href="s0.xml"/>
    <xi:include href="s1.xml"/>
    <xi:include href="s2.xml"/>
    <xi:include href="s3.xml"/>
    <xi:include href="s4.xml"/>
    <xi:include href="s5.xml"/>
    <xi:include href="s6.xml"/>
    <xi:include href="s7.xml"/>
    <xi:include href="s8.xml"/>
    <xi:include href="s9.xml"/>
    <xi:include href="a1.xml"/>
    <xi:include href="a2.xml"/>
    <xi:include href="a3.xml"/>
    <xi:include href="a4.xml"/>
    <xi:include href="a5.xml"/>
    <xi:include href="a6.xml"/>
    <xi:include href="a7.xml"/>
    <xi:include href="a8.xml"/>
    <xi:include href="a9.xml"/>
    <xi:include href="icase.xml"/>
    <xi:include href="as_xpr.xml"/>
    <xi:include href="by_ref.xml"/>
    <xi:include href="range.xml"/>
    <xi:include href="optional.xml"/>
    <xi:include href="repeat.xml"/>
    <xi:include href="keep.xml"/>
    <xi:include href="before.xml"/>
    <xi:include href="after.xml"/>
    <xi:include href="imbue.xml"/>
    <xi:include href="skip.xml"/>
  </section>

  <section xml:id="header.regex_token_iterator_hpp">
    <title>&lt;boost/xpressive/regex_token_iterator.hpp&gt; ヘッダ</title>
    <para>
      <classname>regex_token_iterator</classname> の定義と、正規表現を使って文字列をトークンに分割する STL 互換のイテレータがある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="regex_token_iterator">regex_token_iterator</classname>;
  }
}</synopsis>

    <xi:include href="regex_token_iterator.xml"/>
  </section>

  <section xml:id="header.regex_traits_hpp">
    <title>&lt;boost/xpressive/regex_traits.hpp&gt; ヘッダ</title>
    <para>
      <symbol>BOOST_XPRESSIVE_USE_C_TRAITS</symbol> マクロにしたがって C 正規表現特性か C++ 正規表現特性のヘッダファイルをインクルードする。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    struct <classname linkend="regex_traits_version_1_tag">regex_traits_version_1_tag</classname>;
    struct <classname linkend="regex_traits_version_2_tag">regex_traits_version_2_tag</classname>;
  }
}</synopsis>

    <xi:include href="regex_traits_version_1_tag.xml"/>
    <xi:include href="regex_traits_version_2_tag.xml"/>
  </section>

  <section xml:id="header.sub_match_hpp">
    <title>&lt;boost/xpressive/sub_match.hpp&gt; ヘッダ</title>
    <para>
      <classname>sub_match&lt;&gt;</classname> クラステンプレートと、関連するヘルパ関数の定義がある。
    </para>
    <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="sub_match">sub_match</classname>;
    template&lt;typename BidiIter&gt; BidiIter <function linkend="range_begin">range_begin</function>(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; &amp;);
    template&lt;typename BidiIter&gt; 
      BidiIter <function linkend="range_begin">range_begin</function>(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp;);
    template&lt;typename BidiIter&gt; BidiIter <function linkend="range_end">range_end</function>(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; &amp;);
    template&lt;typename BidiIter&gt; 
      BidiIter <function linkend="range_end">range_end</function>(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp;);
    template&lt;typename BidiIter, typename Char, typename Traits&gt; 
      std::basic_ostream&lt; Char, Traits &gt; &amp; 
      <function linkend="sub_match.operator.left-shift">operator&lt;&lt;</function>(std::basic_ostream&lt; Char, Traits &gt; &amp;, 
                 <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp;);
    template&lt;typename BidiIter&gt; 
      bool operator==(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator!=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator==(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator!=(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;=(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;=(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator==(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator!=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      bool operator==(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator!=(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                     <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;=(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;=(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator==(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator!=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                     typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&gt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      bool operator&lt;=(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                      typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                typename iterator_value&lt; BidiIter &gt;::type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(typename iterator_value&lt; BidiIter &gt;::type const &amp; lhs, 
                <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                typename iterator_value&lt; BidiIter &gt;::type const * rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(typename iterator_value&lt; BidiIter &gt;::type const * lhs, 
                <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(<classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; lhs, 
                typename <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type const &amp; rhs);
    template&lt;typename BidiIter&gt; 
      <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type 
      operator+(typename <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt;::string_type const &amp; lhs, 
                <classname linkend="sub_match">sub_match</classname>&lt; BidiIter &gt; const &amp; rhs);
  }
}</synopsis>

    <xi:include href="sub_match.xml"/>
    <xi:include href="range_begin.xml"/>
    <xi:include href="range_end.xml"/>
    <xi:include href="sub_match.operator.left-shift.xml"/>
  </section>

  <section xml:id="header.traits.c_regex_traits_hpp">
    <title>&lt;boost/xpressive/traits/c_regex_traits.hpp&gt; ヘッダ</title>
    <para>
      静的・動的正規表現の振る舞いをカスタマイズする C ロカール関数のラッパである <classname>c_regex_traits</classname> テンプレートの定義がある。
    </para>
  </section>

  <section xml:id="header.traits.cpp_regex_traits_hpp">
    <title>&lt;boost/xpressive/traits/cpp_regex_traits.hpp&gt; ヘッダ</title>
    <para>
      静的・動的正規表現の振る舞いをカスタマイズする <classname>std::locale</classname> のラッパである <classname>cpp_regex_traits</classname> テンプレートの定義がある。
    </para>
  </section>

  <section xml:id="header.traits.null_regex_traits_hpp">
    <title>&lt;boost/xpressive/traits/null_regex_traits.hpp&gt; ヘッダ</title>
    <para>
      非文字データを検索する静的・動的正規表現で使用する控えの正規表現特性の実装である、<classname>null_regex_traits</classname> テンプレートの定義がある。
    </para>
  </section>

  <section xml:id="header.xpressive_hpp">
    <title>&lt;boost/xpressive/xpressive.hpp&gt; ヘッダ</title>
    <para>
      静的・動的両方の正規表現サポートを含む xpressive のすべてをインクルードする。
    </para>
  </section>

  <section xml:id="header.xpressive_dynamic_hpp">
    <title>&lt;boost/xpressive/xpressive_dynamic.hpp&gt; ヘッダ</title>
    <para>
      動的正規表現の記述と使用に必要なすべてをインクルードする。
    </para>
  </section>

  <section xml:id="header.xpressive_fwd_hpp">
    <title>&lt;boost/xpressive/xpressive_fwd.hpp&gt; ヘッダ</title>
    <para>
      xpressive のすべての公開データ型の前方宣言。
    </para>
    <synopsis language="C++"><symbol xlink:href="http://www.boost.org/doc/html/BOOST_PROTO_FUSION_V2">BOOST_PROTO_FUSION_V2</symbol>
<symbol xlink:href="http://www.boost.org/doc/html/BOOST_XPRESSIVE_HAS_MS_STACK_GUARD">BOOST_XPRESSIVE_HAS_MS_STACK_GUARD</symbol></synopsis>
  <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct <classname linkend="basic_regex">basic_regex</classname>;
    template&lt;typename Char&gt; struct <classname linkend="c_regex_traits">c_regex_traits</classname>;
    template&lt;typename RegexTraits&gt; struct <classname linkend="compiler_traits">compiler_traits</classname>;
    template&lt;typename Char&gt; struct <classname linkend="cpp_regex_traits">cpp_regex_traits</classname>;
    template&lt;typename Traits&gt; struct <classname linkend="has_fold_case">has_fold_case</classname>;
    template&lt;typename Elem&gt; struct <classname linkend="null_regex_traits">null_regex_traits</classname>;
    template&lt;typename BidiIter&gt; struct <classname linkend="regex_token_iterator">regex_token_iterator</classname>;
    template&lt;typename Char, typename Impl&gt; <classname linkend="regex_traits">struct regex_traits</classname>;

    typedef void const * regex_id_type;
    typedef <classname linkend="basic_regex">basic_regex</classname>&lt; std::string::const_iterator &gt; sregex;
    typedef <classname linkend="basic_regex">basic_regex</classname>&lt; char const * &gt; cregex;
    typedef <classname linkend="basic_regex">basic_regex</classname>&lt; std::wstring::const_iterator &gt; wsregex;
    typedef <classname linkend="basic_regex">basic_regex</classname>&lt; wchar_t const * &gt; wcregex;
    typedef <classname linkend="sub_match">sub_match</classname>&lt; std::string::const_iterator &gt; ssub_match;
    typedef <classname linkend="sub_match">sub_match</classname>&lt; char const * &gt; csub_match;
    typedef <classname linkend="sub_match">sub_match</classname>&lt; std::wstring::const_iterator &gt; wssub_match;
    typedef <classname linkend="sub_match">sub_match</classname>&lt; wchar_t const * &gt; wcsub_match;
    typedef <classname linkend="regex_compiler">regex_compiler</classname>&lt; std::string::const_iterator &gt; sregex_compiler;
    typedef <classname linkend="regex_compiler">regex_compiler</classname>&lt; char const * &gt; cregex_compiler;
    typedef <classname linkend="regex_compiler">regex_compiler</classname>&lt; std::wstring::const_iterator &gt; wsregex_compiler;
    typedef <classname linkend="regex_compiler">regex_compiler</classname>&lt; wchar_t const * &gt; wcregex_compiler;
    typedef <classname linkend="regex_iterator">regex_iterator</classname>&lt; std::string::const_iterator &gt; sregex_iterator;
    typedef <classname linkend="regex_iterator">regex_iterator</classname>&lt; char const * &gt; cregex_iterator;
    typedef <classname linkend="regex_iterator">regex_iterator</classname>&lt; std::wstring::const_iterator &gt; wsregex_iterator;
    typedef <classname linkend="regex_iterator">regex_iterator</classname>&lt; wchar_t const * &gt; wcregex_iterator;
    typedef <classname linkend="regex_token_iterator">regex_token_iterator</classname>&lt; std::string::const_iterator &gt; sregex_token_iterator;
    typedef <classname linkend="regex_token_iterator">regex_token_iterator</classname>&lt; char const * &gt; cregex_token_iterator;
    typedef <classname linkend="regex_token_iterator">regex_token_iterator</classname>&lt; std::wstring::const_iterator &gt; wsregex_token_iterator;
    typedef <classname linkend="regex_token_iterator">regex_token_iterator</classname>&lt; wchar_t const * &gt; wcregex_token_iterator;
    typedef <classname linkend="match_results">match_results</classname>&lt; std::string::const_iterator &gt; smatch;
    typedef <classname linkend="match_results">match_results</classname>&lt; char const * &gt; cmatch;
    typedef <classname linkend="match_results">match_results</classname>&lt; std::wstring::const_iterator &gt; wsmatch;
    typedef <classname linkend="match_results">match_results</classname>&lt; wchar_t const * &gt; wcmatch;
    typedef <classname linkend="regex_id_filter_predicate">regex_id_filter_predicate</classname>&lt; std::string::const_iterator &gt; sregex_id_filter_predicate;
    typedef <classname linkend="regex_id_filter_predicate">regex_id_filter_predicate</classname>&lt; char const * &gt; cregex_id_filter_predicate;
    typedef <classname linkend="regex_id_filter_predicate">regex_id_filter_predicate</classname>&lt; std::wstring::const_iterator &gt; wsregex_id_filter_predicate;
    typedef <classname linkend="regex_id_filter_predicate">regex_id_filter_predicate</classname>&lt; wchar_t const * &gt; wcregex_id_filter_predicate;
    namespace op {
    }
  }
}</synopsis>

    <xi:include href="c_regex_traits.xml"/>
    <xi:include href="compiler_traits.xml"/>
    <xi:include href="cpp_regex_traits.xml"/>
    <xi:include href="has_fold_case.xml"/>
    <xi:include href="null_regex_traits.xml"/>
    <xi:include href="regex_traits.xml"/>
  </section>

  <section xml:id="header.xpressive_static_hpp">
    <title>&lt;boost/xpressive/xpressive_static.hpp&gt; ヘッダ</title>
    <para>
      静的正規表現の記述と使用に必要なすべてをインクルードする。
    </para>
  </section>

  <section xml:id="header.xpressive_typeof_hpp">
    <title>&lt;boost/xpressive/xpressive_typeof.hpp&gt; ヘッダ</title>
    <para>
      xpressive を Boost.Typeof ライブラリとともに使用するための型登録。
    </para>
  </section>
</section>

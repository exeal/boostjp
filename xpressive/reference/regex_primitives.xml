<?xml version="1.0" ?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0">
  <info>
    <title>&lt;boost/xpressive/regex_primitives.hpp&gt; ヘッダ</title>
    <copyright>
      <year>2008</year>
      <holder>Eric Niebler</holder>
    </copyright>
  </info>

  <para>
    静的正規表現を記述するための構文要素がある。
  </para>

  <synopsis language="C++">namespace boost {
  namespace xpressive {
    struct mark_tag;

    unsigned int const inf;    // 部分式の無限回の繰り返しに使う。
    <replaceable>unspecified</replaceable> nil;    // 空のマッチ。
    <replaceable>unspecified</replaceable> alnum;    // 英数字にマッチ。 
    <replaceable>unspecified</replaceable> alpha;    // アルファベットにマッチ。 
    <replaceable>unspecified</replaceable> blank;    // 空白（水平空白）文字にマッチ。 
    <replaceable>unspecified</replaceable> cntrl;    // 制御文字にマッチ。
    <replaceable>unspecified</replaceable> digit;    // 数字にマッチ。 
    <replaceable>unspecified</replaceable> graph;    // グラフィカルな文字にマッチ。 
    <replaceable>unspecified</replaceable> lower;    // 小文字にマッチ。 
    <replaceable>unspecified</replaceable> print;    // 印字可能な文字にマッチ。 
    <replaceable>unspecified</replaceable> punct;    // 区切り文字にマッチ。 
    <replaceable>unspecified</replaceable> space;    // 空白類文字にマッチ。
    <replaceable>unspecified</replaceable> upper;    // 大文字にマッチ。 
    <replaceable>unspecified</replaceable> xdigit;    // 16 進数字にマッチ。 
    <replaceable>unspecified</replaceable> bos;    // シーケンスの先頭を表す表明。 
    <replaceable>unspecified</replaceable> eos;    // シーケンスの終端を表す表明。
    <replaceable>unspecified</replaceable> bol;    // 行頭を表す表明。
    <replaceable>unspecified</replaceable> eol;    // 行末を表す表明。 
    <replaceable>unspecified</replaceable> bow;    // 語頭を表す表明。 
    <replaceable>unspecified</replaceable> eow;    // 語末を表す表明。 
    <replaceable>unspecified</replaceable> _b;    // 単語境界を表す表明。 
    <replaceable>unspecified</replaceable> _w;    // 単語構成文字にマッチ。 
    <replaceable>unspecified</replaceable> _d;    // 数字にマッチ。 
    <replaceable>unspecified</replaceable> _s;    // 空白類文字にマッチ。 
    proto::terminal&lt; char &gt;::type const _n;    // リテラルの改行 '\n' にマッチ。 
    <replaceable>unspecified</replaceable> _ln;    // 論理改行シーケンスにマッチ。
    <replaceable>unspecified</replaceable> _;    // あらゆる文字にマッチ。
    <replaceable>unspecified</replaceable> self;    // 現在の正規表現オブジェクトへの参照。 
    <replaceable>unspecified</replaceable> set;    // 文字セットを作成するのに使用。
    mark_tag const s0;    // Perl の $&amp; 部分マッチプレースホルダ。 
    mark_tag const s1;    // Perl の $1 部分マッチプレースホルダ。 
    mark_tag const s2;
    mark_tag const s3;
    mark_tag const s4;
    mark_tag const s5;
    mark_tag const s6;
    mark_tag const s7;
    mark_tag const s8;
    mark_tag const s9;
    <replaceable>unspecified</replaceable> a1;
    <replaceable>unspecified</replaceable> a2;
    <replaceable>unspecified</replaceable> a3;
    <replaceable>unspecified</replaceable> a4;
    <replaceable>unspecified</replaceable> a5;
    <replaceable>unspecified</replaceable> a6;
    <replaceable>unspecified</replaceable> a7;
    <replaceable>unspecified</replaceable> a8;
    <replaceable>unspecified</replaceable> a9;
    template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> icase(Expr const &amp;);
    template&lt;typename Literal&gt; <replaceable>unspecified</replaceable> as_xpr(Literal const &amp;);
    template&lt;typename BidiIter&gt; 
      proto::terminal&lt; reference_wrapper&lt; basic_regex&lt; BidiIter &gt; const  &gt; &gt;::type const 
      by_ref(basic_regex&lt; BidiIter &gt; const &amp;);
    template&lt;typename Char&gt; <replaceable>unspecified</replaceable> range(Char, Char);
    template&lt;typename Expr&gt; 
      proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Expr const &amp;
&gt;::type const 
      optional(Expr const &amp;);
    template&lt;unsigned int Min, unsigned int Max, typename Expr&gt; 
      <replaceable>unspecified</replaceable> repeat(Expr const &amp;);
    template&lt;unsigned int Count, typename Expr2&gt; 
      <replaceable>unspecified</replaceable> repeat(Expr2 const &amp;);
    template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> keep(Expr const &amp;);
    template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> before(Expr const &amp;);
    template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> after(Expr const &amp;);
    template&lt;typename Locale&gt; <replaceable>unspecified</replaceable> imbue(Locale const &amp;);
    template&lt;typename Skip&gt; <replaceable>unspecified</replaceable> skip(Skip const &amp;);
  }
}</synopsis>

  <section>
    <title>mark_tag 構造体</title>
    <para>
      boost::xpressive::mark_tag – 静的正規表現で名前付き捕捉を作成するのに使用する、部分マッチのプレースホルダ型。
    </para>

    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;


struct mark_tag {
  // 構築、コピー、解体
  mark_tag(int);

  // 非公開静的メンバ関数
  static <replaceable>unspecified</replaceable> make_tag(int);
};</synopsis>
    </section>

    <section>
      <title>説明</title>
      <para>
	<classname linkend="mark_tag">mark_tag</classname> は部分マッチのグローバルなプレースホルダ s0 、s1 、…の型である。<classname linkend="mark_tag">mark_tag</classname> を使用すると、より意味のある名前で部分マッチプレースホルダを作成できる。動的正規表現における「名前付き捕捉」機能とおおよそ等価である。
      </para>
      <para>
	名前付き部分マッチプレースホルダは、一意な整数で初期化して作成する。この整数はプレースホルダを使用する正規表現内で一意でなければならない。静的正規表現内でこれに部分式を代入して部分マッチを作成するか、すでに作成した部分マッチを後方参照できる。
      </para>
      <programlisting language="C++">mark_tag number(1); // number は s1 と等価
// 数字、続いて空白、再び同じ数字にマッチ
sregex rx = (number = +_d) &gt;&gt; ' ' &gt;&gt; number;</programlisting>
      <para>
	<function>regex_match()</function> か <function>regex_search()</function> が成功した後は、部分マッチのプレースホルダを <classname linkend="match_results">match_results&lt;&gt;</classname> オブジェクトの添字にして、対応する部分マッチを得る。
      </para>

      <section>
	<title>mark_tag 構築、コピー、解体の公開演算</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">mark_tag(int mark_nbr);</synopsis>
	    <para><classname linkend="mark_tag">mark_tag</classname> プレースホルダを初期化する。</para>
	    <informaltable>
	      <tr>
		<th>引数：</th>
		<td><parameter class="function">mark_nbr</parameter></td>
		<td>この <classname linkend="mark_tag">mark_tag</classname> を使用する静的正規表現内でこの <classname linkend="mark_tag">mark_tag</classname> を一意に識別する整数。</td>
	      </tr>
	      <tr>
		<th>要件：</th>
		<td colspan="2"><code language="C++">mark_nbr &gt; 0</code></td>
	      </tr>
	    </informaltable>
	  </listitem>
	</orderedlist>
      </section>

      <section>
	<title>mark_tag 非公開静的メンバ関数</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">static <replaceable>unspecified</replaceable> make_tag(int mark_nbr);</synopsis>
	  </listitem>
	</orderedlist>
      </section>
    </section>
  </section>

  <section>
    <title>inf グローバル定数</title>
    <para>boost::xpressive::inf — 部分式の無限回の繰り返し。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

unsigned int const inf;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	制限なしの繰り返しを指定する <function>repeat&lt;&gt;()</function> 関数テンプレートとともに使用する魔法数。<code language="C++">repeat&lt;17, inf&gt;('a')</code> のように使用する。これは Perl の /<phrase role="regex-pattern">a{17,}</phrase>/ と等価である。
      </para>
    </section>
  </section>

  <section>
    <title>nil グローバル定数</title>
    <para>boost::xpressive::nil — 空のマッチ。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> nil;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	ゼロ幅シーケンスに対するマッチ。<constant>nil</constant> は常に成功し、文字を消費しない。
      </para>
    </section>
  </section>

  <section>
    <title>alnum グローバル変数</title>
    <para>boost::xpressive::alnum — 英数字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> alnum;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が英数字か決定する正規表現特性。英数字以外にマッチさせる場合は <code language="C++">~alnum</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">alnum</code> は Perl の /<phrase role="regex-pattern">[[:alnum:]]</phrase>/ と等価である。<code language="C++">~alnum</code> は Perl の /<phrase role="regex-pattern">[[:^alnum:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>alpha グローバル変数</title>
    <para>boost::xpressive::alpha — アルファベットにマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> alpha;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字がアルファベットか決定する正規表現特性。アルファベット以外にマッチさせる場合は <code language="C++">~alpha</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">alpha</code> は Perl の /<phrase role="regex-pattern">[[:alpha:]]</phrase>/ と等価である。<code language="C++">~alpha</code> は Perl の /<phrase role="regex-pattern">[[:^alpha:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>blank グローバル変数</title>
    <para>boost::xpressive::blank — 空白（水平空白）にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> blank;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が空白か決定する正規表現特性。空白以外にマッチさせる場合は <code language="C++">~blank</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">blank</code> は Perl の /<phrase role="regex-pattern">[[:blank:]]</phrase>/ と等価である。<code language="C++">~blank</code> は Perl の /<phrase role="regex-pattern">[[:^blank:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>cntrl グローバル変数</title>
    <para>boost::xpressive::cntrl — 制御文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> cntrl;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が制御文字か決定する正規表現特性。制御文字以外にマッチさせる場合は <code language="C++">~cntrl</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">cntrl</code> は Perl の /<phrase role="regex-pattern">[[:cntrl:]]</phrase>/ と等価である。<code language="C++">~cntrl</code> は Perl の /<phrase role="regex-pattern">[[:^cntrl:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>digit グローバル変数</title>
    <para>boost::xpressive::digit — 数字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> digit;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が数字か決定する正規表現特性。数字以外にマッチさせる場合は <code language="C++">~digit</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">digit</code> は Perl の /<phrase role="regex-pattern">[[:digit:]]</phrase>/ と等価である。<code language="C++">~digit</code> は Perl の /<phrase role="regex-pattern">[[:^digit:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>graph グローバル変数</title>
    <para>boost::xpressive::graph — グラフィカルな文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> graph;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字がグラフィカルな文字か決定する正規表現特性。グラフィカルな文字以外にマッチさせる場合は <code language="C++">~digit</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">graph</code> は Perl の /<phrase role="regex-pattern">[[:graph:]]</phrase>/ と等価である。<code language="C++">~graph</code> は Perl の /<phrase role="regex-pattern">[[:^graph:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>lower グローバル変数</title>
    <para>boost::xpressive::lower — 小文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> lower;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が小文字か決定する正規表現特性。小文字以外にマッチさせる場合は <code language="C++">~lower</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">lower</code> は Perl の /<phrase role="regex-pattern">[[:lower:]]</phrase>/ と等価である。<code language="C++">~lower</code> は Perl の /<phrase role="regex-pattern">[[:^lower:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>print グローバル変数</title>
    <para>boost::xpressive::print — 印字可能文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> print;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が印字可能文字か決定する正規表現特性。印字可能文字以外にマッチさせる場合は <code language="C++">~print</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">print</code> は Perl の /<phrase role="regex-pattern">[[:print:]]</phrase>/ と等価である。<code language="C++">~print</code> は Perl の /<phrase role="regex-pattern">[[:^print:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>punct グローバル変数</title>
    <para>boost::xpressive::punct — 区切り文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> punct;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が区切り文字か決定する正規表現特性。区切り文字以外にマッチさせる場合は <code language="C++">~punct</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">punct</code> は Perl の /<phrase role="regex-pattern">[[:punct:]]</phrase>/ と等価である。<code language="C++">~punct</code> は Perl の /<phrase role="regex-pattern">[[:^punct:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>space グローバル変数</title>
    <para>boost::xpressive::space — 空白類文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> space;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が空白類文字か決定する正規表現特性。空白類文字以外にマッチさせる場合は <code language="C++">~space</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">space</code> は Perl の /<phrase role="regex-pattern">[[:space:]]</phrase>/ と等価である。<code language="C++">~space</code> は Perl の /<phrase role="regex-pattern">[[:^space:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>upper グローバル変数</title>
    <para>boost::xpressive::upper — 大文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> upper;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が大文字か決定する正規表現特性。大文字以外にマッチさせる場合は <code language="C++">~upper</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">upper</code> は Perl の /<phrase role="regex-pattern">[[:upper:]]</phrase>/ と等価である。<code language="C++">~upper</code> は Perl の /<phrase role="regex-pattern">[[:^upper:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>xdigit グローバル変数</title>
    <para>boost::xpressive::xdigit — 16 進数字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> xdigit;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字が 16 進数字か決定する正規表現特性。16 進数字以外にマッチさせる場合は <code language="C++">~xdigit</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">xdigit</code> は Perl の /<phrase role="regex-pattern">[[:xdigit:]]</phrase>/ と等価である。<code language="C++">~xdigit</code> は Perl の /<phrase role="regex-pattern">[[:^xdigit:]]</phrase>/ と等価である。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>bos グローバル変数</title>
    <para>boost::xpressive::bos — シーケンスの先頭を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> bos;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字シーケンス <code>[begin, end)</code> について、<constant>bos</constant> はゼロ幅の部分シーケンス <code>[begin, begin)</code> にマッチする。
      </para>
    </section>
  </section>

  <section>
    <title>eos グローバル変数</title>
    <para>boost::xpressive::eos — シーケンスの終端を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> eos;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	文字シーケンス <code>[begin, end)</code> について、<constant>eos</constant> はゼロ幅の部分シーケンス <code>[end, end)</code> にマッチする。
      </para>
    </section>
  </section>

  <section>
    <title>bol グローバル変数</title>
    <para>boost::xpressive::bol — 行頭を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> bol;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>bol</constant> は論理改行シーケンス直後のゼロ幅部分シーケンスにマッチする。この正規表現特性は論理改行シーケンスを規定するのに使用する。
      </para>
    </section>
  </section>

  <section>
    <title>eol グローバル変数</title>
    <para>boost::xpressive::eol — 行末を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> eol;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>eol</constant> は論理改行シーケンス直前のゼロ幅部分シーケンスにマッチする。この正規表現特性は論理改行シーケンスを規定するのに使用する。
      </para>
    </section>
  </section>

  <section>
    <title>bow グローバル変数</title>
    <para>boost::xpressive::bow — 語頭を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> bow;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>bow</constant> は非単語構成文字の直後、単語構成文字の直前のゼロ幅部分シーケンスにマッチする。この正規表現特性は単語の構成を規定するのに使用する。
      </para>
    </section>
  </section>

  <section>
    <title>eow グローバル変数</title>
    <para>boost::xpressive::eow — 語末を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> eow;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>eow</constant> は単語構成文字の直前、非単語構成文字の直後のゼロ幅部分シーケンスにマッチする。この正規表現特性は単語の構成を規定するのに使用する。
      </para>
    </section>
  </section>

  <section>
    <title>_b グローバル変数</title>
    <para>boost::xpressive::_b — 単語境界を表す表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _b;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_b</constant> は語頭か語末のゼロ幅部分シーケンスにマッチする。<code language="C++">(bow|eow)</code> と等価である。この正規表現特性は単語の構成を規定するのに使用する。単語境界以外にマッチさせる場合は <code language="C++">~_b</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">_b</code> は Perl の <phrase role="regex-pattern">\b</phrase> と同じである。<code language="C++">~_b</code> は Perl の <phrase role="regex-pattern">\B</phrase> と同じである。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>_w グローバル変数</title>
    <para>boost::xpressive::_b — 単語構成文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _w;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_w</constant> は単語構成文字 1 文字にマッチする。この正規表現特性は単語構成文字を規定するのに使用する。単語構成文字以外にマッチさせる場合は <code language="C++">~_w</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">_w</code> は Perl の <phrase role="regex-pattern">\w</phrase> と同じである。<code language="C++">~_w</code> は Perl の <phrase role="regex-pattern">\W</phrase> と同じである。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>_d グローバル変数</title>
    <para>boost::xpressive::_d — 数字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _d;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_d</constant> は数字 1 文字にマッチする。この正規表現特性は数字を規定するのに使用する。数字以外にマッチさせる場合は <code language="C++">~_d</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">_d</code> は Perl の <phrase role="regex-pattern">\d</phrase> と同じである。<code language="C++">~_d</code> は Perl の <phrase role="regex-pattern">\D</phrase> と同じである。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>_s グローバル変数</title>
    <para>boost::xpressive::_s — 空白類文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _s;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_s</constant> は空白類文字 1 文字にマッチする。この正規表現特性は空白類文字を規定するのに使用する。空白類文字以外にマッチさせる場合は <code language="C++">~_s</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">_s</code> は Perl の <phrase role="regex-pattern">\s</phrase> と同じである。<code language="C++">~_s</code> は Perl の <phrase role="regex-pattern">\S</phrase> と同じである。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>_n グローバル定数</title>
    <para>boost::xpressive::_n — リテラルの改行文字 <phrase role="regex-input">\n</phrase> にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

proto::terminal&lt; char &gt;::type const _n;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_n</constant> は改行文字 <phrase role="regex-input">\n</phrase> 1 文字にマッチする。改行以外の文字にマッチさせる場合は <code language="C++">~_n</code> を使用する。
      </para>
      <note>
	<para>
	  <code language="C++">_n</code> は Perl で /s 修飾子を指定しなかった場合の <phrase role="regex-pattern">.</phrase> と同じである。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>_ln グローバル定数</title>
    <para>boost::xpressive::_ln — 論理改行シーケンスにマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _ln;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<constant>_ln</constant> は論理改行シーケンスにマッチする。正規表現特性が規定する行区切りに分類される文字か <phrase role="regex-input">\r\n</phrase> シーケンスである。バックトラックに関して、<phrase role="regex-input">\r\n</phrase> は 1 つの単位として扱う。論理改行以外の 1 文字にマッチさせる場合は <code language="C++">~_ln</code> を使用する。
      </para>
    </section>
  </section>

  <section>
    <title>_ グローバル定数</title>
    <para>boost::xpressive::_ — 任意の文字にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> _;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	Perl 構文（/s 修飾子を設定してあるとして）における <phrase role="regex-pattern">.</phrase> と同様、任意の文字にマッチする。<constant>_</constant> は改行を含む任意の 1 文字にマッチする。
      </para>
      <note>
	<para>
	  改行以外の任意の文字にマッチさせるには <code language="C++">~_n</code> を使用する。
	</para>
      </note>
    </section>
  </section>

  <section>
    <title>self グローバル変数</title>
    <para>boost::xpressive::self — 現在の正規表現への参照。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> self;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	再帰正規表現を構築しているときに便利である。識別子 <constant>self</constant> は現在の正規表現オブジェクトの短縮形である。例えば <code language="C++">sregex rx = '(' &gt;&gt; (self | nil) &gt;&gt; ')';</code> は、<phrase role="regex-input">((()))</phrase> のような「開きと閉じが正しく対応した括弧群」にマッチする正規表現オブジェクトを作成する。
      </para>
    </section>
  </section>

  <section>
    <title>set グローバル変数</title>
    <para>boost::xpressive::set — 文字集合（文字セット）を作成するのに使用する。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> set;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	識別子 <constant>set</constant> を使って文字集合を作成する方法は 2 つある。より簡単なのは <code language="C++">(set= 'a','b','c')</code> のように集合内の文字をカンマで区切って並べる方法である。この集合は <phrase role="regex-input">a</phrase> 、<phrase role="regex-input">b</phrase> 、<phrase role="regex-input">c</phrase> にマッチする。もう1つはsetの添字演算子の引数として集合を定義する方法である。例えば <code language="C++">set[ 'a' | range('b','c') | digit ]</code> は <phrase role="regex-input">a</phrase> 、<phrase role="regex-input">b</phrase> 、<phrase role="regex-input">c</phrase> 、数字にマッチする。
      </para>
      <para>
	<constant>set</constant> の補集合を得るには ~ 演算子を適用する。例えば <code language="C++">~(set= 'a','b','c')</code> は <phrase role="regex-input">a</phrase> 、<phrase role="regex-input">b</phrase> 、<phrase role="regex-input">c</phrase> 以外の文字にマッチする。
      </para>
      <para>
	<constant>set</constant> は他の集合や補集合と和をとることもできる。例えば <code language="C++">set[ ~digit | ~(set= 'a','b','c') ]</code> のようにする。
      </para>
    </section>
  </section>

  <section>
    <title>s0 グローバル定数</title>
    <para>boost::xpressive::s0 — Perl の <phrase role="regex-pattern">$&amp;</phrase> に相当する部分マッチのプレースホルダ。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s0;</synopsis>
    </section>
  </section>

  <section>
    <title>s1 グローバル定数</title>
    <para>boost::xpressive::s1 — Perl の <phrase role="regex-pattern">$1</phrase> に相当する部分マッチのプレースホルダ。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s1;</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	部分マッチを作成するには、部分式を部分マッチのプレースホルダに代入する。例えば <code language="C++">(s1= _)</code> は任意の 1 文字にマッチし、どの文字が 1 番目の部分マッチかを記憶する。この部分マッチはパターン内の別の場所から後方参照できる。例えば <code language="C++">(s1= _) &gt;&gt; s1</code> は任意の文字にマッチし、直後に同じ文字にマッチする。
      </para>
      <para>
	<function>regex_match()</function> や <function>regex_search()</function> が成功すると、部分マッチのプレースホルダを <classname linkend="match_results">match_results&lt;&gt;</classname> オブジェクトの添字にして <replaceable>N</replaceable> 番目の部分マッチを得られる。
      </para>
    </section>
  </section>

  <section>
    <title>s2 グローバル定数</title>
    <para>boost::xpressive::s2。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s2;</synopsis>
    </section>
  </section>

  <section>
    <title>s3 グローバル定数</title>
    <para>boost::xpressive::s3。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s3;</synopsis>
    </section>
  </section>

  <section>
    <title>s4 グローバル定数</title>
    <para>boost::xpressive::s4。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s4;</synopsis>
    </section>
  </section>

  <section>
    <title>s5 グローバル定数</title>
    <para>boost::xpressive::s5。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s5;</synopsis>
    </section>
  </section>

  <section>
    <title>s6 グローバル定数</title>
    <para>boost::xpressive::s6。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s6;</synopsis>
    </section>
  </section>

  <section>
    <title>s7 グローバル定数</title>
    <para>boost::xpressive::s7。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s7;</synopsis>
    </section>
  </section>

  <section>
    <title>s8 グローバル定数</title>
    <para>boost::xpressive::s8。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s8;</synopsis>
    </section>
  </section>

  <section>
    <title>s9 グローバル定数</title>
    <para>boost::xpressive::s9。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

mark_tag const s9;</synopsis>
    </section>
  </section>

  <section>
    <title>a1 グローバル変数</title>
    <para>boost::xpressive::a1。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a1;</synopsis>
    </section>
  </section>

  <section>
    <title>a2 グローバル変数</title>
    <para>boost::xpressive::a2。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a2;</synopsis>
    </section>
  </section>

  <section>
    <title>a3 グローバル変数</title>
    <para>boost::xpressive::a3。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a3;</synopsis>
    </section>
  </section>

  <section>
    <title>a4 グローバル変数</title>
    <para>boost::xpressive::a4。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a4;</synopsis>
    </section>
  </section>

  <section>
    <title>a5 グローバル変数</title>
    <para>boost::xpressive::a5。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a5;</synopsis>
    </section>
  </section>

  <section>
    <title>a6 グローバル変数</title>
    <para>boost::xpressive::a6。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a6;</synopsis>
    </section>
  </section>

  <section>
    <title>a7 グローバル変数</title>
    <para>boost::xpressive::a7。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a7;</synopsis>
    </section>
  </section>

  <section>
    <title>a8 グローバル変数</title>
    <para>boost::xpressive::a8。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a8;</synopsis>
    </section>
  </section>

  <section>
    <title>a9 グローバル変数</title>
    <para>boost::xpressive::a9。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

<replaceable>unspecified</replaceable> a9;</synopsis>
    </section>
  </section>

  <section>
    <title>icase 関数テンプレート</title>
    <para>boost::xpressive::icase — 部分式を大文字小文字を区別しないようにする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> icase(Expr const &amp; expr);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	部分式を大文字小文字を区別しないようにするには <function>icase()</function> を使用する。例えば <code language="C++">"foo" &gt;&gt; icase(set['b'] &gt;&gt; "ar")</code> は <phrase role="regex-input">foo</phrase> の後に <phrase role="regex-input">bar</phrase> が続くシーケンスにマッチするが、後半は大文字小文字を区別しない。
      </para>
    </section>
  </section>

  <section>
    <title>as_xpr 関数テンプレート</title>
    <para>boost::xpressive::as_xpr — リテラルを正規表現にする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Literal&gt; <replaceable>unspecified</replaceable> as_xpr(Literal const &amp; literal);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	リテラルを正規表現にするには <function>as_xpr()</function> を使用する。例えば <code language="C++">"foo" &gt;&gt; "bar"</code> は右シフト演算子の両方のオペランドが <type>const char*</type> であり、そのような演算子は存在しないためコンパイルできない。<code language="C++">as_xpr("foo") &gt;&gt; "bar"</code> を代わりに使用する。
      </para>
      <para>
	文字列リテラルだけでなく、文字リテラルに対しても <function>as_xpr()</function> を使用できる。例えば <code language="C++">as_xpr('a')</code> は <phrase role="regex-input">a</phrase> にマッチする。また <code language="C++">~as_xpr('a')</code> とすることで文字リテラルの否定が得られる。これは <phrase role="regex-input">a</phrase> 以外の文字にマッチする。
      </para>
    </section>
  </section>

  <section>
    <title>by_ref 関数テンプレート</title>
    <para>boost::xpressive::by_ref — 正規表現オブジェクトを参照により組み込む。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename BidiIter&gt;
  proto::terminal&lt; reference_wrapper&lt; basic_regex&lt; BidiIter &gt; const  &gt; &gt;::type const
  by_ref(basic_regex&lt; BidiIter &gt; const &amp; rex);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">rex</parameter></td>
	  <td>参照により組み込む <classname linkend="basic_regex">basic_regex</classname> オブジェクト</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>range 関数テンプレート</title>
    <para>boost::xpressive::range — 文字の範囲にマッチする。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Char&gt; <replaceable>unspecified</replaceable> range(Char ch_min, Char ch_max);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>範囲 <code>[ch_min, ch_max]</code> の任意の文字にマッチする（それぞれ、この関数の引数）。</para>
      <informaltable>
	<tr>
	  <th rowspan="2">引数：</th>
	  <td><parameter class="function">ch_max</parameter></td>
	  <td>マッチする範囲の上限</td>
	</tr>
	<tr>
	  <td><parameter class="function">ch_min</parameter></td>
	  <td>マッチする範囲の下限</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>optional 関数テンプレート</title>
    <para>boost::xpressive::optional — 部分式を省略可能にする。<code language="C++">!as_xpr(expr)</code> と等価である。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Expr&gt;
  proto::result_of::make_expr&lt; proto::tag::logical_not, proto::default_domain, Expr const &amp; &gt;::type const 
  optional(Expr const &amp; expr);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">expr</parameter></td>
	  <td>省略可能にする部分式</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>repeat 関数テンプレート</title>
    <para>boost::xpressive::repeat — 部分式を複数回繰り返す。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;unsigned int Min, unsigned int Max, typename Expr&gt;
  <replaceable>unspecified</replaceable> repeat(Expr const &amp; expr);
template&lt;unsigned int Count, typename Expr2&gt;
  <replaceable>unspecified</replaceable> repeat(Expr2 const &amp; expr2);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<function>repeat&lt;&gt;()</function> 関数テンプレートは 2 形式ある。部分式に <replaceable>N</replaceable> 回マッチさせる場合は <code language="C++">repeat&lt;N&gt;(expr)</code> を使用する。部分式を <replaceable>M</replaceable> から <replaceable>N</replaceable> 回マッチさせるには <code language="C++">repeat&lt;M,N&gt;(expr)</code> を使用する。
      </para>
      <para>
	<function>repeat&lt;&gt;()</function> 関数は貪欲な数量子を作成する。貪欲でない数量子にするには <code language="C++">-repeat&lt;M,N&gt;(expr)</code> のように単項マイナス演算子を適用する。
      </para>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">expr</parameter></td>
	  <td>繰り返す部分式</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>keep 関数テンプレート</title>
    <para>boost::xpressive::keep — 独立部分式を作成する。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> keep(Expr const &amp; expr);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	部分式のバックトラックを抑止する。部分式内の選択と繰り返しは 1 つの経路だけマッチし、他の選択肢は試行しない。
      </para>
      <note>
	<para>
	  <code language="C++">keep(expr)</code> は Perl の <phrase role="regex-pattern">(?&gt;...)</phrase> 拡張と等価である。
	</para>
      </note>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">expr</parameter></td>
	  <td>変更する部分式</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>before 関数テンプレート</title>
    <para>boost::xpressive::before — 肯定先読み表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> before(Expr const &amp; expr);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<code language="C++">before(expr)</code> は部分式 <varname>expr</varname> がシーケンス内の現在位置でマッチすれば成功するが、<varname>expr</varname> はマッチに含まれない。例えば <code language="C++">before("foo")</code> は現在位置が <phrase role="regex-input">foo</phrase> の直前であれば成功する。肯定先読み表明はビット否定演算子で否定できる。
      </para>
      <note>
	<para>
	  <code language="C++">before(expr)</code> は Perl の <phrase role="regex-pattern">(?=...)</phrase> 拡張と等価である。<code language="C++">~before(expr)</code> は否定先読みであり、Perl の <phrase role="regex-pattern">(?!...)</phrase> 拡張と等価である。
	</para>
      </note>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">expr</parameter></td>
	  <td>肯定先読み表明に使用する部分式</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>after 関数テンプレート</title>
    <para>boost::xpressive::after — 肯定後読み表明。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Expr&gt; <replaceable>unspecified</replaceable> after(Expr const &amp; expr);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<code language="C++">after(expr)</code> は部分式 <varname>expr</varname> がシーケンス内の現在位置から <varname>expr</varname> の長さ戻ったところでマッチすれば成功する。<varname>expr</varname> はマッチに含まれない。例えば <code language="C++">after("foo")</code> は現在位置が <phrase role="regex-input">foo</phrase> の直後であれば成功する。肯定後読み表明はビット否定演算子で否定できる。
      </para>
      <note>
	<para>
	  <code language="C++">after(expr)</code> は Perl の <phrase role="regex-pattern">(?&lt;=...)</phrase> 拡張と等価である。<code language="C++">~after(expr)</code> は否定後読みであり、Perl の <phrase role="regex-pattern">(?&lt;!...)</phrase> 拡張と等価である。
	</para>
      </note>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">expr</parameter></td>
	  <td>肯定後読み表明に使用する部分式</td>
	</tr>
	<tr>
	  <th>要件：</th>
	  <td colspan="2"><varname>expr</varname> の文字数は可変にできない。</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>imbue 関数テンプレート</title>
    <para>boost::xpressive::imbue — 正規表現特性か <classname>std::locale</classname> を指定する。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Locale&gt; <replaceable>unspecified</replaceable> imbue(Locale const &amp; loc);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<function>imbue()</function> は正規表現マッチ時に使用する特性かロカールを正規表現エンジンに対して指示する。特性・ロカールは、正規表現全体で同じものを使用しなければならない。例えば次のコードは正規表現で使用するロカールを指定する：<code language="C++">std::locale loc; sregex rx = imbue(loc)(+digit);</code>
      </para>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">loc</parameter></td>
	  <td><classname>std::locale</classname> か正規表現特性オブジェクト</td>
	</tr>
      </informaltable>
    </section>
  </section>

  <section>
    <title>skip 関数テンプレート</title>
    <para>boost::xpressive::skip – 正規表現マッチ中に読み飛ばす文字を指定する。</para>
    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_primitives.hpp&gt;

template&lt;typename Skip&gt; unspecified skip(Skip const &amp; skip);</synopsis>
    </section>
    <section>
      <title>説明</title>
      <para>
	<function>skip()</function> は、正規表現マッチ中に読み飛ばす文字を正規表現エンジンに対して指示する。空白類文字を無視する正規表現を記述するのに最も有用である。例えば、以下は正規表現について空白類文字と区切り文字を読み飛ばすよう指定する。
      </para>
      <programlisting language="C++">// 文は空白類文字か区切り文字で区切られた
// 1 つ以上の単語からなる。
sregex word = +alpha;
sregex sentence = skip(set[_s | punct])( +word );</programlisting>
      <para>
	上記の例と同じことをするには正規表現内の各プリミティブの前に <code language="C++">keep(*set[_s | punct])</code> を挿入する必要がある。「プリミティブ」とは文字列や文字集合、入れ子の正規表現のことである。最後に正規表現の終端にも <code language="C++">*set[_s | punct]</code> が必要である。上で指定した文の正規表現は以下と等価である。
      </para>
      <programlisting language="C++">sregex sentence = +( keep(*set[_s | punct]) &gt;&gt; word )
                       &gt;&gt; *set[_s | punct];</programlisting>

      <note>
	<para>
	  入れ子の正規表現は不可分として扱われるため、読み飛ばしがこれらの処理方法に影響することはない。文字列リテラルもまた不可分として扱われ、文字列リテラル内で読み飛ばしは発生しない。よって <code language="C++">skip(_s)("this that")</code> は <code language="C++">skip(_s)("this" &gt;&gt; as_xpr("that"))</code> と同じではない。前者は <phrase role="regex-input">this</phrase> と <phrase role="regex-input">that</phrase> の間に空白が1つあるものだけにマッチする。後者は <phrase role="regex-input">this</phrase> と <phrase role="regex-input">that</phrase> の間の空白をすべて読み飛ばす。
	</para>
      </note>
      <informaltable>
	<tr>
	  <th>引数：</th>
	  <td><parameter class="function">skip</parameter></td>
	  <td>読み飛ばす文字を指定する正規表現。</td>
	</tr>
      </informaltable>
    </section>
  </section>
</article>

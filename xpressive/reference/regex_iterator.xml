<?xml version="1.0" ?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0">
  <info>
    <title>&lt;boost/xpressive/regex_iterator.hpp&gt; ヘッダ</title>
    <copyright>
      <year>2008</year>
      <holder>Eric Niebler</holder>
    </copyright>
  </info>

  <para>
    シーケンス内のすべてのマッチを辿る STL 互換のイテレータである <classname>regex_iterator</classname> 型の定義がある。
  </para>

  <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct regex_iterator;
  }
}</synopsis>

  <section>
    <title>regex_iterator構造体テンプレート</title>
    <para>boost::xpressive::regex_iterator。</para>

    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/regex_iterator.hpp&gt;

template&lt;typename BidiIter&gt; 
struct regex_iterator {
  // 型
  typedef basic_regex&lt; BidiIter &gt;               regex_type;       
  typedef match_results&lt; BidiIter &gt;             value_type;       
  typedef iterator_difference&lt; BidiIter &gt;::type difference_type;  
  typedef value_type const *                    pointer;          
  typedef value_type const &amp;                    reference;        
  typedef std::forward_iterator_tag             iterator_category;

  // 構築、コピー、解体
  regex_iterator();
  regex_iterator(BidiIter, BidiIter, basic_regex&lt; BidiIter &gt; const &amp;, 
                 regex_constants::match_flag_type = regex_constants::match_default);
  template&lt;typename LetExpr&gt; 
    regex_iterator(BidiIter, BidiIter, basic_regex&lt; BidiIter &gt; const &amp;, 
                   <replaceable>unspecified</replaceable>, 
                   regex_constants::match_flag_type = regex_constants::match_default);
  regex_iterator(regex_iterator&lt; BidiIter &gt; const &amp;);
  regex_iterator&lt; BidiIter &gt;&amp; operator=(regex_iterator&lt; BidiIter &gt; const &amp;);

  // 公開メンバ関数
  value_type const &amp; operator*() const;
  value_type const * operator-&gt;() const;
  regex_iterator&lt; BidiIter &gt; &amp; operator++();
  regex_iterator&lt; BidiIter &gt; operator++(int);</synopsis>
    </section>

    <section>
      <title>説明</title>

      <section>
	<title>regex_iterator 構築、コピー、解体の公開演算</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">regex_iterator();</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">regex_iterator(BidiIter begin, BidiIter end, 
               basic_regex&lt; BidiIter &gt; const &amp; rex, 
               regex_constants::match_flag_type flags = regex_constants::match_default);</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">template&lt;typename LetExpr&gt;
  regex_iterator(BidiIter begin, BidiIter end,
                 basic_regex&lt; BidiIter &gt; const &amp; rex, <replaceable>unspecified</replaceable> args, 
                 regex_constants::match_flag_type flags = regex_constants::match_default);</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">regex_iterator(regex_iterator&lt; BidiIter &gt; const &amp; that);</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">regex_iterator&lt; BidiIter &gt; &amp;
operator=(regex_iterator&lt; BidiIter &gt; const &amp; that);</synopsis>
	  </listitem>
	</orderedlist>
      </section>

      <section>
	<title>regex_iterator 公開メンバ関数</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">value_type const &amp; operator*() const;</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">value_type const * operator-&gt;() const;</synopsis>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">regex_iterator&lt; BidiIter &gt; &amp; operator++();</synopsis>
	    <para>
	      <code language="C++">what.prefix().first != what[0].second</code> かつ <constant>match_prev_avail</constant> 要素がフラグに設定されていなければ設定する。その上で <code language="C++">regex_search(what[0].second, end, what, *pre, flags)</code> を呼び出したのと同様に振る舞う。ただし以下の点については振る舞いが異なる：前回見つかったマッチがゼロ幅だった（<code language="C++">what[0].length() == 0</code>）場合は開始位置が <code language="C++">what[0].second</code> である非ゼロ幅のマッチを探索し、それが失敗かつ <code language="C++">what[0].second != suffix().second</code> である場合に限り開始位置が <code language="C++">what[0].second + 1</code> であるマッチ（これもゼロ幅である可能性がある）を探索する。それ以上マッチが見つからなければ、<code language="C++">*this</code> をシーケンスの終端を指すイテレータと等値に設定する。
	    </para>
	    <informaltable>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;size() == pre-&gt;mark_count() + 1</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;empty() == false</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;prefix().first == （前回見つかったマッチの終端位置を指すイテレータ）</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;prefix().last == (**this)[0].first</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;prefix().matched == (*this)-&gt;prefix().first != (*this)-&gt;prefix().second</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;suffix().first == (**this)[0].second</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;suffix().last == end</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)-&gt;suffix().matched == (*this)-&gt;suffix().first != (*this)-&gt;suffix().second</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(**this)[0].first == </code>（このマッチの開始イテレータ）</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(**this)[0].second == </code>（このマッチの終端イテレータ）</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td>完全マッチが見つかった場合は <code language="C++">(**this)[0].matched == true</code> 、（<constant>match_partial</constant> フラグを設定して見つかった）部分マッチの場合は <code language="C++">(**this)[0].matched == true</code>。</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(**this)[n].first == </code>（<code language="C++">n &lt; (*this)-&gt;size()</code> である全ての整数 <replaceable>n</replaceable> について、<replaceable>n</replaceable> 番目の部分式にマッチしたシーケンスの先頭。<replaceable>n</replaceable> 番目の部分式がマッチに関与しなかった場合は <parameter class="function">end</parameter>）</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(**this)[n].second == </code>（<code language="C++">n &lt; (*this)-&gt;size()</code> である全ての整数 <replaceable>n</replaceable> について、<replaceable>n</replaceable> 番目の部分式にマッチしたシーケンスの終端。<replaceable>n</replaceable> 番目の部分式がマッチに関与しなかった場合は <parameter class="function">end</parameter>）</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(**this)[n].matched == </code>（<code language="C++">n &lt; (*this)-&gt;size()</code> である全ての整数 <replaceable>n</replaceable> について、<replaceable>n</replaceable> 番目の部分式がマッチに関与した場合は true 、それ意外の場合は false）</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">(*this)->position() == </code>（走査対象シーケンスの先頭からこのマッチの先頭までの距離）</td>
	      </tr>
	    </informaltable>
	  </listitem>
	  <listitem>
	    <synopsis language="C++">regex_iterator&lt; BidiIter &gt; operator++(int);</synopsis>
	  </listitem>
	</orderedlist>
      </section>
    </section>
  </section>
</article>

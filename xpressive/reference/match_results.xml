<?xml version="1.0" ?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0">
  <info>
    <title>&lt;boost/xpressive/match_results.hpp&gt; ヘッダ</title>
    <copyright>
      <year>2008</year>
      <holder>Eric Niebler</holder>
    </copyright>
  </info>

  <para>
    <classname>match_results</classname> 型の定義と、関連するヘルパがある。<classname>match_results</classname> 型は <function>regex_match()</function> および <function>regex_search()</function> 操作の結果を保持する。
  </para>

  <synopsis language="C++">namespace boost {
  namespace xpressive {
    template&lt;typename BidiIter&gt; struct match_results;
    template&lt;typename BidiIter&gt; struct regex_id_filter_predicate;
  }
}</synopsis>

  <section>
    <title>match_results 構造体テンプレート</title>
    <para>
      Boost::xpressive::match_results – <classname linkend="match_results">match_results&lt;&gt;</classname> クラステンプレートは <function>regex_match()</function> や <function>regex_search()</function> の結果を <classname linkend="sub_match">sub_match</classname> オブジェクトのコレクションとして保持する。
    </para>

    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/match_results.hpp&gt;

template&lt;typename BidiIter&gt; 
struct match_results {
  // 型
  typedef iterator_value&lt; BidiIter &gt;::type      char_type;          
  typedef unspecified                           string_type;        
  typedef std::size_t                           size_type;          
  typedef sub_match&lt; BidiIter &gt;                 value_type;         
  typedef iterator_difference&lt; BidiIter &gt;::type difference_type;    
  typedef value_type const &amp;                    reference;          
  typedef value_type const &amp;                    const_reference;    
  typedef unspecified                           iterator;           
  typedef unspecified                           const_iterator;     
  typedef unspecified                           nested_results_type;

  // 構築、コピー、解体
  match_results();
  match_results(match_results&lt; BidiIter &gt; const &amp;);
  match_results&lt; BidiIter &gt;&amp; operator=(match_results&lt; BidiIter &gt; const &amp;);
  ~match_results();

  // 公開メンバ関数
  size_type size() const;
  bool empty() const;
  difference_type length(size_type = 0) const;
  difference_type position(size_type = 0) const;
  string_type str(size_type = 0) const;
  template&lt;typename Sub&gt; const_reference operator[](Sub const &amp;) const;
  const_reference prefix() const;
  const_reference suffix() const;
  const_iterator begin() const;
  const_iterator end() const;
  operator bool_type() const;
  bool operator!() const;
  regex_id_type regex_id() const;
  nested_results_type const &amp; nested_results() const;
  template&lt;typename Format, typename OutputIterator&gt; 
    OutputIterator 
    format(OutputIterator, Format const &amp;, 
           regex_constants::match_flag_type = regex_constants::format_default, 
           unspecified = 0) const;
  template&lt;typename OutputIterator&gt; 
    OutputIterator 
    format(OutputIterator, char_type const *, 
           regex_constants::match_flag_type = regex_constants::format_default) const;
  template&lt;typename Format, typename OutputIterator&gt; 
    string_type format(Format const &amp;, 
                       regex_constants::match_flag_type = regex_constants::format_default, 
                       unspecified = 0) const;
  string_type format(char_type const *, 
                     regex_constants::match_flag_type = regex_constants::format_default) const;
  void swap(match_results&lt; BidiIter &gt; &amp;);
  template&lt;typename Arg&gt; match_results&lt; BidiIter &gt; &amp; let(Arg const &amp;);
};</synopsis>
    </section>

    <section>
      <title>説明</title>
      <para>
	クラステンプレート <classname linkend="match_results">match_results&lt;&gt;</classname> は、正規表現マッチの結果を表すシーケンスのコレクションである。コレクションの領域は <classname linkend="match_results">match_results&lt;&gt;</classname> クラスのメンバ関数が必要に応じて確保・解放する。
      </para>
      <para>
	クラステンプレート <classname linkend="match_results">match_results&lt;&gt;</classname> は、lib.sequence.reqmtsが規定するシーケンスの要件に適合するが、constなシーケンスに対して定義された演算だけをサポートする。
      </para>

      <section>
	<title>match_results の構築、コピー、解体公開演算</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">match_results();</synopsis>
	    <informaltable>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">regex_id() == 0</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">size() == 0</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">empty() == true</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td><code language="C++">str() == string_type()</code></td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">match_results(match_results&lt; BidiIter &gt; const &amp; that);</synopsis>
	    <informaltable>
	      <tr>
		<th>引数：</th>
		<td><parameter class="function">that</parameter></td>
		<td>コピーする <classname linkend="match_results">match_results</classname> オブジェクト。</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">regex_id() == that.regex_id()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">size() == that.size()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">empty() == that.empty()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">str(n) == that.str(n)</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">prefix() == that.prefix()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">suffix() == that.suffix()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">(*this)[n] == that[n]</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">length(n) == that.length(n)</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">position(n) == that.position(n)</code></td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">match_results&lt; BidiIter &gt;&amp; operator=(match_results&lt; BidiIter &gt; const &amp; that);</synopsis>
	    <informaltable>
	      <tr>
		<th>引数：</th>
		<td><parameter class="function">that</parameter></td>
		<td>コピーする <classname linkend="match_results">match_results</classname> オブジェクト。</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">regex_id() == that.regex_id()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">size() == that.size()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">empty() == that.empty()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">str(n) == that.str(n)</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">prefix() == that.prefix()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">suffix() == that.suffix()</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">(*this)[n] == that[n]</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">length(n) == that.length(n)</code></td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">n &lt; that.size()</code> であるすべての自然数 <replaceable>n</replaceable> について <code language="C++">position(n) == that.position(n)</code></td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">~match_results();</synopsis>
	  </listitem>
	</orderedlist>
      </section>

      <section>
	<title>match_results 公開メンバ関数</title>
	<orderedlist>
	  <listitem>
	    <synopsis language="C++">size_type size() const;</synopsis>
	    <para><code language="C++">*this</code> が成功したマッチ結果を表す場合は、マッチしたマーク済み部分式の総数に 1 を足した数を返す。それ以外の場合は 0 を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">bool empty() const;</synopsis>
	    <para><code language="C++">size() == 0</code> を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">difference_type length(size_type sub = 0) const;</synopsis>
	    <para><code language="C++">(*this)[sub].length()を返す。</code></para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">difference_type position(size_type sub = 0) const;</synopsis>
	    <para>
	      <code language="C++">!(*this)[sub].matched</code> であれば <literal>-1</literal> を返す。それ以外の場合は <code language="C++">std::distance(base, (*this)[sub].first)</code> を返す（<varname>base</varname> は検索対象のシーケンスの開始イテレータ）。
	      <footnote>
		<para>
		  <classname linkend="regex_iterator">regex_iterator</classname> による繰り返し検索の途中でなければ、<varname>base</varname> は <code language="C++">prefix().first</code> と同じである。
		</para>
	      </footnote>
	    </para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">string_type str(size_type sub = 0) const;</synopsis>
	    <para><code language="C++">(*this)[sub].str()</code> を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">template&lt;typename Sub&gt; const_reference operator[](Sub const &amp; sub) const;</synopsis>
	    <para>マーク済み部分式 <parameter>sub</parameter> にマッチしたシーケンスを表す <classname linkend="sub_match">sub_match</classname> オブジェクトへの参照を返す。<code language="C++">sub == 0</code> であれば正規表現全体にマッチしたシーケンスを表す <classname linkend="sub_match">sub_match</classname> オブジェクトへの参照を返す。<code language="C++">sub &gt;= size()</code> であればマッチしなかった部分式を表す <classname linkend="sub_match">sub_match</classname> オブジェクトへの参照を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">const_reference prefix() const;</synopsis>
	    <para>マッチ・検索対象文字列の先頭からマッチが見つかった位置までの文字シーケンスを表す <classname linkend="sub_match">sub_match</classname> オブジェクトへの参照を返す。</para>
	    <informaltable>
	      <tr>
		<th>要件：</th>
		<td><code language="C++">(*this)[0].matched</code> が真</td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">const_reference suffix() const;</synopsis>
	    <para>マッチが見つかった位置の終端からマッチ・検索対象文字列の終端までの文字シーケンスを表す <classname linkend="sub_match">sub_match</classname> オブジェクトへの参照を返す。</para>
	    <informaltable>
	      <tr>
		<th>要件：</th>
		<td><code language="C++">(*this)[0].matched</code> が真</td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">const_iterator begin() const;</synopsis>
	    <para><code language="C++">*this</code> に格納されたマーク済み部分式マッチをすべて列挙する開始イテレータを返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">const_iterator end() const;</synopsis>
	    <para><code language="C++">*this</code> に格納されたマーク済み部分式マッチをすべて列挙する終了イテレータを返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">operator bool_type() const;</synopsis>
	    <para><code language="C++">(*this)[0].matched</code> であれば真を、そうでなければ偽を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">bool operator!() const;</synopsis>
	    <para><code language="C++">empty() || !(*this)[0].matched</code> であれば真を、そうでなければ偽を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">regex_id_type regex_id() const;</synopsis>
	    <para>この <classname linkend="C++">match_results</classname> オブジェクトで最近使用した <classname linkend="basic_regex">basic_regex</classname> オブジェクトの識別子を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">nested_results_type const &amp; nested_results() const;</synopsis>
	    <para>入れ子の <classname linkend="C++">match_results</classname> 要素のシーケンスを返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">template&lt;typename Format, typename OutputIterator&gt;
  OutputIterator
  format(OutputIterator out, Format const &amp; fmt,
         regex_constants::match_flag_type flags = regex_constants::format_default,
         <replaceable>unspecified</replaceable> = 0) const;</synopsis>
	   <para>
	     <parameter>Format</parameter> が ForwardRange か null 終端文字列であれば、<parameter class="function">fmt</parameter> 内の文字シーケンスを OutputIterator である <parameter class="function">out</parameter> にコピーする。 <parameter class="function">fmt</parameter> 内の各書式化子およびエスケープシーケンスについて、それらが表す文字（列）かそれらが参照する <code language="C++">*this</code> 内のシーケンスで置換する。<parameter class="function">flags</parameter> で指定したビットマスクは、どの書式化子あるいはエスケープシーケンスを使用するかを決定する。既定では『ECMA-262 、ECMAScript 言語仕様 15 章 5.4.11 String.prototype.replace』が使用する書式である。
	   </para>
	   <para>
	     それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</type> であれば、この関数は <code language="C++">fmt(*this, out, flags)</code> を返す。
	   </para>
	   <para>
	     それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator&gt;</type> であれば、この関数は <code language="C++">fmt(*this, out)</code>を返す。
	   </para>
	   <para>
	     それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt; &gt;</type> であれば、この関数は <code language="C++">std::copy(x.begin(), x.end(), out)</code> を返す。<varname>x</varname> は <code language="C++">fmt(*this)</code> を呼び出した結果である。
	   </para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">template&lt;typename OutputIterator&gt;
  OutputIterator 
  format(OutputIterator out, char_type const * fmt,
         regex_constants::match_flag_type flags = regex_constants::format_default) const;</synopsis>
	    <para>利便性のために提供している多重定義メンバ関数である。上記関数とは受け取る引数が異なるのみである。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">template&lt;typename Format, typename OutputIterator&gt;
  string_type format(Format const &amp; fmt, 
                     regex_constants::match_flag_type flags = regex_constants::format_default, 
                     <replaceable>unspecified</replaceable> = 0) const;</synopsis>
	    <para>
	      <parameter>Format</parameter> が ForwardRange か null 終端文字列であれば、この関数は文字シーケンス <parameter class="function">fmt</parameter> のコピーを返す。<parameter class="function">fmt</parameter> 内の各書式化子およびエスケープシーケンスについて、それらが表す文字（列）かそれらが参照する <code language="C++">*this</code> 内のシーケンスで置換する。<parameter class="function">flags</parameter> で指定したビットマスクは、どの書式化子あるいはエスケープシーケンスを使用するかを決定する。既定では『ECMA-262 、ECMAScript 言語仕様 15 章 5.4.11 String.prototype.replace』が使用する書式である。
	    </para>
	    <para>
	      それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator, regex_constants::match_flag_type&gt;</type> であれば、この関数は <code language="C++">fmt(*this, out, flags)</code> 呼び出しで得られた <type role="typedef">string_type</type> オブジェクト <varname>x</varname> を返す。<parameter class="function">out</parameter> は <varname>x</varname> への <classname>back_insert_iterator</classname> である。
	    </para>
	    <para>
	      それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt;, OutputIterator&gt;</type> であれば、この関数は <code language="C++">fmt(*this, out)</code> の呼び出しで得られた <type role="typedef">string_type</type> オブジェクト <varname>x</varname> を返す。<parameter>out</parameter> は <varname>x</varname> への <classname>back_insert_iterator</classname> である。
	    </para>
	    <para>
	      それ以外で <parameter>Format</parameter> が <type>Callable&lt;match_results&lt;BidiIter&gt; &gt;</type> であれば、この関数は <code language="C++">fmt(*this)</code> を返す。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">string_type format(char_type const * fmt, 
                   regex_constants::match_flag_type flags = regex_constants::format_default) const;</synopsis>
	    <para>利便性のために提供している多重定義メンバ関数である。上記関数とは受け取る引数が異なるのみである。</para>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">void swap(match_results&lt; BidiIter &gt; &amp; that);</synopsis>
	    <para>2 つの <classname linkend="match_results">match_results</classname> オブジェクトの内容を交換する。例外を投げないことを保証する。</para>
	    <informaltable>
	      <tr>
		<th>引数：</th>
		<td><parameter class="function">that</parameter></td>
		<td>交換する <classname linkend="match_results">match_results</classname> オブジェクト。</td>
	      </tr>
	      <tr>
		<th>事後条件：</th>
		<td colspan="2"><code language="C++">*this</code> が <parameter class="function">that</parameter> 内にあった部分式マッチのシーケンスをもつ。<parameter class="function">that</parameter> が <code language="C++">*this</code> 内にあった部分式マッチのシーケンスをもつ。</td>
	      </tr>
	      <tr>
		<th>例外：</th>
		<td colspan="2">送出しない。</td>
	      </tr>
	    </informaltable>
	  </listitem>

	  <listitem>
	    <synopsis language="C++">template&lt;typename Arg&gt; match_results&lt; BidiIter &gt; &amp; let(Arg const &amp; arg);</synopsis>
	    <para>
	      <foreignphrase xml:lang="en">TODO document me</foreignphrase>
	      <footnote>
		<para>
		  訳注　この節はまだ原文がありません。
		</para>
	      </footnote>
	    </para>
	  </listitem>
	</orderedlist>
      </section>
    </section>
  </section>

  <section>
    <title>regex_id_filter_predicate 構造体テンプレート</title>
    <para>
      boost::xpressive::regex_id_filter_predicate。
    </para>

    <section>
      <title>書式</title>
      <synopsis language="C++">// ヘッダ：&lt;boost/xpressive/match_results.hpp&gt;

template&lt;typename BidiIter&gt;
struct regex_id_filter_predicate {
  // 構築、コピー、解体
  regex_id_filter_predicate(regex_id_type);

  // 公開メンバ関数
  bool operator()(match_results&lt; BidiIter &gt; const &amp;) const;
};</synopsis>
    </section>

    <section>
      <title>説明</title>

      <section>
	<title>regex_id_filter_predicate 構築、コピー、解体の公開演算</title>
	<synopsis language="C++">regex_id_filter_predicate(regex_id_type regex_id);</synopsis>
      </section>

      <section>
	<title>regex_id_filter_predicate 公開メンバ関数</title>
	<synopsis language="C++">bool operator()(match_results&lt; BidiIter &gt; const &amp; res) const;</synopsis>
      </section>
    </section>
  </section>
</article>

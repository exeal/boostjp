<?xml version="1.0" ?>
<!--
  Copyright 2006-2007 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
-->
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="ref.sub_match">
  <title>sub_match</title>
  <programlisting language="C++"><![CDATA[#include <boost/regex.hpp>]]></programlisting>
  <para>
    正規表現が他の多くの単純なパターンマッチアルゴリズムと異なるのは、マッチを発見するだけでなく、部分式のマッチを生成する点である。各部分式はパターン中の括弧の組 <phrase role="regex-pattern">(...)</phrase> により、その範囲が与えられる。部分式マッチをユーザに知らせるために何らかの方法が必要である。部分式マッチの添字付きコレクションとして振舞う <classname linkend="ref.match_results">match_results</classname> クラスの定義がそれであり、各部分式マッチは <classname linkend="ref.sub_match">sub_match</classname> 型オブジェクトが保持する。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトは <classname linkend="ref.match_results">match_results</classname> 型のオブジェクトの配列要素としてのみ取得可能である。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトは <classname>std::basic_string</classname> 、<type>const charT*</type> 、<type>const charT</type> 型のオブジェクトと比較可能である。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトは <classname>std::basic_string</classname> 、<type>const charT*</type> 、<type>const charT</type> 型のオブジェクトに追加して新しい <classname>std::basic_string</classname> オブジェクトを生成可能である。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトで示されるマーク済み部分式が正規表現マッチに関与していれば <property>matched</property> メンバは<emphasis>真</emphasis>と評価され、メンバ <property>first</property> と <property>second</property> はマッチを形成する文字範囲 [first,second) を示す。それ以外の場合は <property>matched</property> は<emphasis>偽</emphasis>であり、メンバ <property>first</property> と <property>second</property> は未定義の値となる。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトで示されるマーク済み部分式が繰り返しになっている場合、その <classname linkend="ref.sub_match">sub_match</classname> オブジェクトが表現するのは<emphasis>最後の</emphasis>繰り返しに対応するマッチである。すべての繰り返しに対応するすべての捕捉の完全なセットは <methodname>captures()</methodname> メンバ関数でアクセス可能である（効率に関して深刻な問題があり、この機能は明示的に有効にしなければならない）。
  </para>
  <para>
    <classname linkend="ref.sub_match">sub_match</classname> 型のオブジェクトが部分式 0（マッチ全体）を表現する場合、メンバ <property>matched</property> は常に<emphasis>真</emphasis>である。ただし正規表現アルゴリズムにフラグ <constant>match_partial</constant> を渡して結果が<link linkend="partial_matches">部分マッチ</link>となる場合はこの限りではなく、メンバ <property>matched</property> は<emphasis>偽</emphasis>、メンバ <property>first</property> と <property>second</property> は部分マッチを形成する文字範囲を表現する。
  </para>
  <programlisting language="C++">namespace boost{

template &lt;class BidirectionalIterator&gt;
class sub_match;

typedef sub_match&lt;const char*&gt;                    csub_match;
typedef sub_match&lt;const wchar_t*&gt;                 wcsub_match;
typedef sub_match&lt;std::string::const_iterator&gt;    ssub_match;
typedef sub_match&lt;std::wstring::const_iterator&gt;   wssub_match;

template &lt;class BidirectionalIterator&gt;
class sub_match : public std::pair&lt;BidirectionalIterator, BidirectionalIterator&gt;
{
public:
   typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type       <type linkend="ref.sub_match.value_type">value_type</type>;
   typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type  <type linkend="ref.sub_match.diff_type">difference_type</type>;
   typedef          BidirectionalIterator                                    <type linkend="ref.sub_match.it_type">iterator</type>;

   bool <property linkend="ref.sub_match.matched">matched</property>;

   difference_type <property linkend="ref.sub_match.length">length</property>()const;
   <property linkend="ref.sub_match.cast">operator basic_string&lt;value_type&gt;</property>()const;
   basic_string&lt;value_type&gt; <property linkend="ref.sub_match.str">str</property>()const;

   int <methodname linkend="ref.sub_match.compare1">compare</methodname>(const sub_match&amp; s)const;
   int <methodname linkend="ref.sub_match.compare2">compare</methodname>(const basic_string&lt;value_type&gt;&amp; s)const;
   int <methodname linkend="ref.sub_match.compare3">compare</methodname>(const value_type* s)const;
#ifdef BOOST_REGEX_MATCH_EXTRA
   typedef <replaceable>implementation-private</replaceable> <type linkend="ref.sub_match.cap_seq_type">capture_sequence_type</type>;
   const capture_sequence_type&amp; <methodname linkend="ref.sub_match.captures">captures</methodname>()const;
#endif
};
//
// sub_match 同士の比較：
//
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare1">operator ==</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare2">operator !=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare3">operator &lt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare4">operator &lt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare5">operator &gt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare6">operator &gt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);

//
// basic_string との比較：
//
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare7">operator ==</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare8">operator !=</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare9">operator &lt;</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                         traits,
                                         Allocator&gt;&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare10">operator &gt;</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                         traits,
                                         Allocator&gt;&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare11">operator &gt;=</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare12">operator &lt;=</methodname> (const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare13">operator ==</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare14">operator !=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare15">operator &lt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                         traits,
                                         Allocator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare16">operator &gt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                         traits,
                                         Allocator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare17">operator &gt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; rhs);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
bool <methodname linkend="ref.sub_match.op_compare18">operator &lt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                          traits,
                                          Allocator&gt;&amp; rhs);

//
// 文字列ポインタとの比較：
//
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare19">operator ==</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare20">operator !=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare21">operator &lt;</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare22">operator &gt;</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare23">operator &gt;=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare24">operator &lt;=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare25">operator ==</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare26">operator !=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare27">operator &lt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare28">operator &gt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare29">operator &gt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare30">operator &lt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* rhs);

//
// 1 文字との比較：
//
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare31">operator ==</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare32">operator !=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare33">operator &lt;</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare34">operator &gt;</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                 const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare35">operator &gt;=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare36">operator &lt;=</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; lhs,
                  const sub_match&lt;BidirectionalIterator&gt;&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare37">operator ==</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare38">operator !=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare39">operator &lt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare40">operator &gt;</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                 typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare41">operator &gt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);
template &lt;class BidirectionalIterator&gt;
bool <methodname linkend="ref.sub_match.op_compare42">operator &lt;=</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; lhs,
                  typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; rhs);

//
// 加算演算子：
//
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;
   <methodname linkend="ref.sub_match.op_add1">operator +</methodname> (const std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                       traits,
                                       Allocator&gt;&amp; s,
            const sub_match&lt;BidirectionalIterator&gt;&amp; m);
template &lt;class BidirectionalIterator, class traits, class Allocator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;
   <methodname linkend="ref.sub_match.op_add2">operator +</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; m,
               const std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type,
                                       traits,
                                       Allocator&gt;&amp; s);
template &lt;class BidirectionalIterator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;
   <methodname linkend="ref.sub_match.op_add3">operator +</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const* s,
               const sub_match&lt;BidirectionalIterator&gt;&amp; m);
template &lt;class BidirectionalIterator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;
   <methodname linkend="ref.sub_match.op_add4">operator +</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; m,
               typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const * s);
template &lt;class BidirectionalIterator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;
   <methodname linkend="ref.sub_match.op_add5">operator +</methodname> (typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; s,
               const sub_match&lt;BidirectionalIterator&gt;&amp; m);
template &lt;class BidirectionalIterator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;
   <methodname linkend="ref.sub_match.op_add6">operator +</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; m,
               typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp; s);
template &lt;class BidirectionalIterator&gt;
std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt;
   <methodname linkend="ref.sub_match.op_add7">operator +</methodname> (const sub_match&lt;BidirectionalIterator&gt;&amp; m1,
               const sub_match&lt;BidirectionalIterator&gt;&amp; m2);

//
// ストリーム挿入子：
//
template &lt;class charT, class traits, class BidirectionalIterator&gt;
basic_ostream&lt;charT, traits&gt;&amp;
   <methodname linkend="ref.sub_match.op_stream">operator &lt;&lt;</methodname> (basic_ostream&lt;charT, traits&gt;&amp; os,
                const sub_match&lt;BidirectionalIterator&gt;&amp; m);

} // namespace boost</programlisting>

  <sect4 xml:id="ref.sub_match.description">
    <title>説明</title>

    <sect5 xml:id="ref.sub_match.members">
      <title>メンバ</title>
      <orderedlist>
	<listitem xml:id="ref.sub_match.value_type">
	  <programlisting language="C++"><![CDATA[typedef typename std::iterator_traits<iterator>::value_type value_type;]]></programlisting>
	  <para>
	    イテレータが指す型。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.diff_type">
	  <programlisting language="C++"><![CDATA[typedef typename std::iterator_traits<iterator>::difference_type difference_type;]]></programlisting>
	  <para>
	    2 つのイテレータの差を表す型。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.it_type">
	  <programlisting language="C++">typedef BidirectionalIterator iterator;</programlisting>
	  <para>
	    イテレータ型。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.first">
	  <programlisting language="C++">iterator first</programlisting>
	  <para>
	    マッチの先頭位置を示すイテレータ。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.second">
	  <programlisting language="C++">iterator second</programlisting>
	  <para>
	    マッチの終端位置を示すイテレータ。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.matched">
	  <programlisting language="C++">bool matched</programlisting>
	  <para>
	    この部分式がマッチしているかを示す論理値。
	  </para>
	</listitem>

	<listitem xml:id="ref.sub_match.length">
	  <methodsynopsis language="C++">
	    <modifier>static</modifier>
	    <type>difference_type</type>
	    <methodname>length</methodname>
	    <void/>
	    <modifier>const</modifier>
	    <!-- const が付いてなかったので付けた -->
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  マッチした部分式の長さを返す。この部分式がマッチしなかった場合は 0 を返す。<code language="C++">matched ? distance(first, second) : 0</code> と同じ。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.cast">
	  <methodsynopsis language="C++">
	    <methodname><![CDATA[operator basic_string<value_type>]]></methodname>
	    <void/>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">*this</code> を文字列に変換する。<code language="C++"><![CDATA[(matched ? basic_string<value_type>(first, second) : basic_string<value_type>())]]></code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.str">
	  <methodsynopsis language="C++">
	    <type><![CDATA[basic_string<value_type>]]></type>
	    <methodname>str</methodname>
	    <void/>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">*this</code> の文字列表現を返す。<code language="C++"><![CDATA[(matched ? basic_string<value_type>(first, second) : basic_string<value_type>())]]></code> と同じ。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.compare1">
	  <methodsynopsis language="C++">
	    <type>int</type>
	    <methodname>compare</methodname>
	    <methodparam>
	      <type>const sub_match&amp;</type>
	      <parameter>s</parameter>
	    </methodparam>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">*this</code> と <parameter>s</parameter> と字句的比較を行う。<code language="C++">str().compare(s.str())</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.compare2">
	  <methodsynopsis language="C++">
	    <type>int</type>
	    <methodname>compare</methodname>
	    <methodparam>
	      <type><![CDATA[const basic_string<value_type>&]]></type>
	      <parameter>s</parameter>
	    </methodparam>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">*this</code> と文字列 <parameter>s</parameter> を比較する。<code language="C++">str().compare(s)</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.compare3">
	  <methodsynopsis language="C++">
	    <type>int</type>
	    <methodname>compare</methodname>
	    <methodparam>
	      <type>const value_type*</type>
	      <parameter>s</parameter>
	    </methodparam>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">*this</code> と null 終端文字列 <parameter>s</parameter> を比較する。<code language="C++">str().compare(s)</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.cap_seq_type">
	  <programlisting language="C++">typedef <replaceable>implementation-private</replaceable> capture_sequence_type;</programlisting>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  標準ライブラリ Sequence の要件（21.1.1 および表 68 の操作）を満たす実装固有の型を定義する。その <type>value_type</type> は <classname><![CDATA[sub_match<BidirectionalIterator>]]></classname> である。この型が <classname><![CDATA[std::vector<sub_match<BidirectionalIterator> >]]></classname> となる可能性もあるが、それに依存すべきではない。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.captures">
	  <methodsynopsis language="C++">
	    <type>const capture_sequence_type&amp;</type>
	    <methodname>captures</methodname>
	    <void/>
	    <modifier>const</modifier>
	  </methodsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  この部分式に対するすべての捕捉を格納したシーケンスを返す。
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>事前条件：</term>
	      <listitem>
		<para>
		  <symbol>BOOST_REGEX_MATCH_EXTRA</symbol> を使ってライブラリをビルドしていなければ、このメンバ関数は定義されない。また正規表現マッチ関数（<function linkend="ref.regex_match">regex_match</function> 、<function linkend="ref.regex_search">regex_search</function> 、<classname linkend="ref.regex_iterator">regex_iterator</classname> 、<classname linkend="ref.regex_token_iterator">regex_token_iterator</classname>）にフラグ <constant>match_extra</constant> を渡していなければ、有用な情報を返さない。
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>根拠：</term>
	      <listitem>
		<para>
		  この機能を有効にするといくつか影響がある。
		</para>
		<itemizedlist>
		  <listitem>
		    <para>
		      <classname>sub_match</classname> がより多くのメモリを占有し、複雑な正規表現をマッチする場合にすぐにメモリやスタック空間の不足に陥る。
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      <constant>match_extra</constant> を使用しない場合であっても、処理する機能（例えば独立部分式）によってはマッチアルゴリズムの効率が落ちる。
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      <constant>match_extra</constant> を使用するとさらに効率が落ちる（速度が低下する）。ほとんどの場合、さらに必要なメモリ割り当てが起こる。
		    </para>
		  </listitem>
		</itemizedlist>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </orderedlist>
    </sect5>

    <sect5 xml:id="ref.sub_match.sub_match_non_member_operators">
      <title>sub_match 非メンバ演算子</title>
      <orderedlist>
	<listitem xml:id="ref.sub_match.op_compare1">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) == 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare2">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) != 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare3">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) &lt; 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare4">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) &lt;= 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare5">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) &gt;= 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare6">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo><![CDATA[template <class BidirectionalIterator>]]></funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type><![CDATA[const sub_match<BidirectionalIterator>&]]></type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.compare(rhs) &gt; 0</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare7">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs == rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare8">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs != rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare9">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare10">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare11">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare12">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare13">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() == rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare14">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() != rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare15">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &lt; rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare16">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &gt; rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare17">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &gt;= rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare18">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &lt;= rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare19">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs == rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare20">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs != rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare21">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare22">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare23">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare24">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare25">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() == rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare26">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() != rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare27">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &lt; rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare28">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &gt; rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare29">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &gt;= rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare30">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs.str() &lt;= rhs</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare31">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs == rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare32">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs != rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare33">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare34">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare35">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare36">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare37">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator ==</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs == rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare38">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator !=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs != rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare39">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare40">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt; rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare41">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &gt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &gt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_compare42">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>bool <function>operator &lt;=</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>lhs</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>rhs</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">lhs &lt;= rhs.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add1">
	  <para>
	    <classname linkend="ref.sub_match">sub_match</classname> の加算演算子により、<classname>basic_string</classname> に追加可能な型に対して <classname linkend="ref.sub_match">sub_match</classname> を追加することができ、結果として新しい文字列を得る。
	  </para>
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>const std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>s</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">s + m.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add2">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator, class traits, class Allocator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	      <paramdef>
		<type>const std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type, traits, Allocator&gt;&amp;</type>
		<parameter>s</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">m.str() + s</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add3">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>s</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">s + m.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add4">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const*</type>
		<parameter>s</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">m.str() + s</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add5">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>s</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">s + m.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add6">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m</parameter>
	      </paramdef>
	      <paramdef>
		<type>typename iterator_traits&lt;BidirectionalIterator&gt;::value_type const&amp;</type>
		<parameter>s</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">m.str() + s</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>

	<listitem xml:id="ref.sub_match.op_add7">
	  <funcsynopsis language="C++">
	    <funcsynopsisinfo>template &lt;class BidirectionalIterator&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <?dbhtml funcsynopsis-style="ansi"?>
	      <funcdef>std::basic_string&lt;typename iterator_traits&lt;BidirectionalIterator&gt;::value_type&gt; <function>operator +</function></funcdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m1</parameter>
	      </paramdef>
	      <paramdef>
		<type>const sub_match&lt;BidirectionalIterator&gt;&amp;</type>
		<parameter>m2</parameter>
	      </paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++">m1.str() + m2.str()</code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </orderedlist>
    </sect5>

    <sect5 xml:id="ref.sub_match.stream_inserter">
      <title>ストリーム挿入子</title>
      <orderedlist>
	<listitem xml:id="ref.sub_match.op_stream">
	  <programlisting language="C++"><![CDATA[template <class charT, class traits, class BidirectionalIterator>
basic_ostream<charT, traits>&
   operator << (basic_ostream<charT, traits>& os,
                const sub_match<BidirectionalIterator>& m);]]></programlisting>
	  <variablelist spacing="compact">
	    <varlistentry>
	      <term>効果：</term>
	      <listitem>
		<para>
		  <code language="C++"><![CDATA[(os << m.str())]]></code> を返す。
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </orderedlist>
    </sect5>
  </sect4>
</section>

<?xml version="1.0" ?>
<!--
  Copyright 2006-2007 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
-->
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="ref.basic_regex">
  <title>basic_regex</title>

  <sect4 xml:id="ref.basic_regex.synopsis">
    <title>概要</title>
    <programlisting language="C++"><![CDATA[#include <boost/regex.hpp>]]></programlisting>
    <para>
      テンプレートクラス <classname>basic_regex</classname> は、正規表現の解析とコンパイルをカプセル化する。このクラスは 2 つのテンプレート引数をとる。
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  <type>charT</type> は文字型を決定する。すなわち <type>char</type> か <type>wchar_t</type> のいずれかである。<link linkend="ref.concepts.charT_concept">charT のコンセプト</link>を見よ。
	</para>
      </listitem>
      <listitem>
	<para>
	  <type>traits</type> は、例えばどの文字クラス名を考慮するか、といった文字型の振る舞いを決定する。既定の特性クラスとして <classname>regex_traits&lt;charT&gt;</classname> が用意されている。<link linkend="ref.concepts.traits_concept">traits のコンセプト</link>を見よ。
	</para>
      </listitem>
    </itemizedlist>
    <para>
      簡単に使用できるように、標準的な <classname>basic_regex</classname> インスタンスを定義する typedef が 2 つある。カスタムの特性クラスか非標準の文字型（例えば <link linkend="ref.non_std_strings.icu">Unicode サポート</link>を見よ）を使用するつもりがなければ、この 2 つだけを使用すればよい。
    </para>
    <programlisting language="C++"><![CDATA[]]></programlisting>
    <para>
      以下が <classname>basic_regex</classname> の定義である。<classname>basic_string</classname> クラスに基づいており、<type>charT</type> の定数コンテナの要求事項を満足する。
    </para>
    <programlisting language="C++">namespace boost{

template &lt;class charT, class traits = regex_traits&lt;charT&gt; &gt;
class basic_regex {
   public:
   // 型：
   typedef          charT                               value_type;
   typedef          implementation-specific             const_iterator;
   typedef          const_iterator                      iterator;
   typedef          charT&amp;                              reference;
   typedef          const charT&amp;                        const_reference;
   typedef          std::ptrdiff_t                      difference_type;
   typedef          std::size_t                         size_type;
   typedef          regex_constants::<type linkend="ref.syntax_option_type">syntax_option_type</type> flag_type;
   typedef typename traits::locale_type                 locale_type;

   // 定数：
   // メインオプションの選択：
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> normal
                                                = regex_constants::normal;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> ECMAScript
                                                = normal;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> JavaScript
                                                = normal;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> Jscript
                                                = normal;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> basic
                                                = regex_constants::basic;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> extended
                                                = regex_constants::extended;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> awk
                                                = regex_constants::awk;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> grep
                                                = regex_constants::grep;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> egrep
                                                = regex_constants::egrep;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> sed
                                                = basic = regex_constants::sed;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> perl
                                                = regex_constants::perl;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> literal
                                                = regex_constants::literal;

   // Perl 正規表現固有の修飾子：
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_mod_m
                                                = regex_constants::no_mod_m;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_mod_s
                                                = regex_constants::no_mod_s;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> mod_s
                                                = regex_constants::mod_s;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> mod_x
                                                = regex_constants::mod_x;

   // POSIX 基本正規表現固有の修飾子：
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> bk_plus_qm
                                                = regex_constants::bk_plus_qm;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> bk_vbar
                                                = regex_constants::bk_vbar;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_char_classes
                                                = regex_constants::no_char_classes;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_intervals
                                                = regex_constants::no_intervals;

   // 共通の修飾子：
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> nosubs
                                                = regex_constants::nosubs;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> optimize
                                                = regex_constants::optimize;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> collate
                                                = regex_constants::collate;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> newline_alt
                                                = regex_constants::newline_alt;
   static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_except
                                                = regex_constants::newline_alt;

   // 構築、コピー、解体：
   explicit <methodname linkend="ref.basic_regex.construct1">basic_regex</methodname> ();
   explicit <methodname linkend="ref.basic_regex.construct2">basic_regex</methodname>(const charT* p, flag_type f = regex_constants::normal);
   <methodname linkend="ref.basic_regex.construct3">basic_regex</methodname>(const charT* p1, const charT* p2,
               flag_type f = regex_constants::normal);
   <methodname linkend="ref.basic_regex.construct4">basic_regex</methodname>(const charT* p, size_type len, flag_type f);
   <methodname linkend="ref.basic_regex.construct5">basic_regex</methodname>(const basic_regex&amp;);

   template &lt;class ST, class SA&gt;
   explicit <methodname linkend="ref.basic_regex.construct6">basic_regex</methodname>(const basic_string&lt;charT, ST, SA&gt;&amp; p,
                        flag_type f = regex_constants::normal);

   template &lt;class InputIterator&gt;
   <methodname linkend="ref.basic_regex.construct7">basic_regex</methodname>(InputIterator first, InputIterator last,
               flag_type f = regex_constants::normal);

   ~basic_regex();
   <link linkend="ref.basic_regex.opeq1">basic_regex&amp; operator=</link>(const basic_regex&amp;);
   <link linkend="ref.basic_regex.opeq2">basic_regex&amp; operator=</link> (const charT* ptr);

   template &lt;class ST, class SA&gt;
   <link linkend="ref.basic_regex.opeq3">basic_regex&amp; operator=</link> (const basic_string&lt;charT, ST, SA&gt;&amp; p);
   // イテレータ：
   <link linkend="ref.basic_regex.subexpression">std::pair&lt;const_iterator, const_iterator&gt; subexpression</link>(size_type n) const;
   <link linkend="ref.basic_regex.begin">const_iterator begin</link>() const;
   <link linkend="ref.basic_regex.end">const_iterator end</link>() const;
   // 容量：
   <link linkend="ref.basic_regex.size">size_type size</link>() const;
   <link linkend="ref.basic_regex.max_size">size_type max_size</link>() const;
   <link linkend="ref.basic_regex.empty">bool empty</link>() const;
   <link linkend="ref.basic_regex.mark_count">size_type mark_count</link>()const;
   //
   // 変更：
   <link linkend="ref.basic_regex.assign1">basic_regex&amp; assign</link>(const basic_regex&amp; that);
   <link linkend="ref.basic_regex.assign2">basic_regex&amp; assign</link>(const charT* ptr,
                       flag_type f = regex_constants::normal);
   <link linkend="ref.basic_regex.assign3">basic_regex&amp; assign</link>(const charT* ptr, unsigned int len, flag_type f);

   template &lt;class string_traits, class A&gt;
   <link linkend="ref.basic_regex.assign4">basic_regex&amp; assign</link>(const basic_string&lt;charT, string_traits, A&gt;&amp; s,
                       flag_type f = regex_constants::normal);

   template &lt;class InputIterator&gt;
   <link linkend="ref.basic_regex.assign5">basic_regex&amp; assign</link>(InputIterator first, InputIterator last,
                       flag_type f = regex_constants::normal);

   // const な操作：
   <link linkend="ref.basic_regex.flags">flag_type</link> flags() const;
   <link linkend="ref.basic_regex.status">int status</link>()const;
   <link linkend="ref.basic_regex.str">basic_string&lt;charT&gt; str</link>() const;
   <link linkend="ref.basic_regex.compare">int compare</link>(basic_regex&amp;) const;
   // ロカール：
   <link linkend="ref.basic_regex.imbue">locale_type imbue</link>(locale_type loc);
   <link linkend="ref.basic_regex.getloc">locale_type getloc</link>() const;
   // 値の交換
   <link linkend="ref.basic_regex.swap">void swap</link>(basic_regex&amp;) throw();
};

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_eq">bool operator ==</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_ne">bool operator !=</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_lt">bool operator &lt;</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_le">bool operator &lt;=</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_ge">bool operator &gt;=</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                  const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_gt">bool operator &gt;</link> (const basic_regex&lt;charT, traits&gt;&amp; lhs,
                 const basic_regex&lt;charT, traits&gt;&amp; rhs);

template &lt;class charT, class io_traits, class re_traits&gt;
basic_ostream&lt;charT, io_traits&gt;&amp;
<link linkend="ref.basic_regex.op_stream">operator &lt;&lt;</link> (basic_ostream&lt;charT, io_traits&gt;&amp; os,
             const basic_regex&lt;charT, re_traits&gt;&amp; e);

template &lt;class charT, class traits&gt;
<link linkend="ref.basic_regex.op_swap">void swap</link>(basic_regex&lt;charT, traits&gt;&amp; e1,
          basic_regex&lt;charT, traits&gt;&amp; e2);

typedef basic_regex&lt;char&gt; regex;
typedef basic_regex&lt;wchar_t&gt; wregex;

} // namespace boost</programlisting>
  </sect4>

  <sect4 xml:id="ref.basic_regex.description">
    <title>説明</title>
    <para>
      <classname>basic_regex</classname> クラスは以下の公開メンバをもつ。
    </para>
    <programlisting language="C++">// メインオプションの選択：
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> normal
                                          = regex_constants::normal;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> ECMAScript
                                          = normal;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> JavaScript
                                          = normal;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> Jscript
                                          = normal;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> basic
                                          = regex_constants::basic;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> extended
                                          = regex_constants::extended;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> awk
                                          = regex_constants::awk;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> grep
                                          = regex_constants::grep;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> egrep
                                          = regex_constants::egrep;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> sed
                                          = basic = regex_constants::sed;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> perl
                                          = regex_constants::perl;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> literal
                                          = regex_constants::literal;

// Perl 正規表現固有の修飾子：
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_mod_m
                                          = regex_constants::no_mod_m;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_mod_s
                                          = regex_constants::no_mod_s;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> mod_s
                                          = regex_constants::mod_s;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> mod_x
                                          = regex_constants::mod_x;

// POSIX 基本正規表現固有の修飾子：
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> bk_plus_qm
                                          = regex_constants::bk_plus_qm;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> bk_vbar
                                          = regex_constants::bk_vbar;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_char_classes
                                          = regex_constants::no_char_classes;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_intervals
                                          = regex_constants::no_intervals;

// 共通の修飾子：
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> nosubs
                                          = regex_constants::nosubs;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> optimize
                                          = regex_constants::optimize;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> collate
                                          = regex_constants::collate;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> newline_alt
                                          = regex_constants::newline_alt;
static const regex_constants:: <type linkend="ref.syntax_option_type">syntax_option_type</type> no_except
                                          = regex_constants::newline_alt;</programlisting>
    <para>
      これらのオプションの意味は <type linkend="ref.syntax_option_type">syntax_option_type</type> の節にある。
    </para>
    <para>
      静的定数メンバは名前空間 <package>boost::regex_constants</package> 内で宣言した定数の別名として提供している。名前空間 <package>boost::regex_constants</package> 内で宣言されている <type linkend="ref.syntax_option_type">syntax_option_type</type> 型の各定数については、<classname>basic_regex</classname> のスコープで同じ名前・型・値で宣言している。
    </para>

    <orderedlist>
      <listitem xml:id="ref.basic_regex.construct1">
	<constructorsynopsis language="C++">
	  <methodname>basic_regex</methodname>
	  <void/>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<classname>basic_regex</classname> クラスのオブジェクトを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> デフォルトコンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>true</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><literal>0</literal></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>()]]></code></td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct2">
	<constructorsynopsis language="C++">
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type>const chartT*</type>
	    <parameter>p</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<parameter>p</parameter> は null ポインタ以外。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para>
		<parameter>p</parameter> が正しい正規表現でない場合 <exceptionname linkend="ref.bad_expression">bad_expression</exceptionname>（<parameter>f</parameter> にフラグ <constant>no_except</constant> が設定されていない場合）。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<classname linkend="ref.basic_regex">basic_regex</classname> クラスのオブジェクトを構築する。<parameter>f</parameter> で指定した<link linkend="ref.syntax_option_type">オプションフラグ</link>にしたがって null 終端文字列 <parameter>p</parameter> の正規表現を解釈し、オブジェクトの内部有限状態マシンを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> デフォルトコンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++"><![CDATA[char_traits<charT>::length(p)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>(p)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count()</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct3">
	<constructorsynopsis language="C++">
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>p1</parameter>
	  </methodparam>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>p2</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<parameter>p1</parameter> と <parameter>p2</parameter> は null ポインタ以外、かつ <code language="C++"><![CDATA[p1 < p2]]></code>。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para>
		[p1,p2) が正しい正規表現でない場合 <exceptionname>bad_expression</exceptionname>（<parameter>f</parameter> に <constant>no_except</constant> が設定されていない場合）。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		クラス <classname linkend="ref.basic_regex">basic_regex</classname> のオブジェクトを構築する。<parameter>f</parameter> で指定した<link linkend="ref.syntax_option_type">オプションフラグ</link>にしたがって文字シーケンス [p1,p2) の正規表現を解釈し、オブジェクトの内部有限状態マシンを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> デフォルトコンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++"><![CDATA[std::distance(p1,p2)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>(p1,p2)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count()</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct4">
	<constructorsynopsis language="C++">
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>p</parameter>
	  </methodparam>
	  <methodparam>
	    <type>size_type</type>
	    <parameter>len</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<parameter>p</parameter> は null ポインタ以外、かつ <code language="C++"><![CDATA[len < max_size()]]></code>。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para>
		<parameter>p</parameter> が正しい正規表現でない場合 <exceptionname linkend="ref.bad_expression">bad_expression</exceptionname>（<parameter>f</parameter> に <constant>no_except</constant> が設定されていない場合）。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		クラス <classname linkend="ref.basic_regex">basic_regex</classname> のオブジェクトを構築する。<parameter>f</parameter> で指定したオプションフラグにしたがって文字シーケンス [p,p+len) の正規表現を解釈し、オブジェクトの内部有限状態マシンを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> デフォルトコンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><parameter>len</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>(p, len)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count()</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct5">
	<constructorsynopsis language="C++">
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type>const basic_regex&amp;</type>
	    <parameter>e</parameter>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		オブジェクト <parameter>e</parameter> をコピーしてクラス <classname linkend="ref.basic_regex">basic_regex</classname> オブジェクトを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct6">
	<constructorsynopsis language="C++">
	  <modifier><![CDATA[template <class ST, class SA>]]></modifier>
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_string<charT, ST, SA>&]]></type>
	    <parameter>s</parameter>
	  </methodparam>
	  <methodparam>
	    <type>type_flag</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para>
		<parameter>s</parameter> が正しい正規表現でない場合 <exceptionname linkend="ref.bad_expression">bad_expression</exceptionname>（<parameter>f</parameter> に <constant>no_except</constant> が設定されていない場合）。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<classname linkend="ref.basic_regex">basic_regex</classname> クラスのオブジェクトを構築する。<parameter>f</parameter> で指定した<link linkend="ref.syntax_option_type">オプションフラグ</link>にしたがって文字列 <parameter>s</parameter> の正規表現を解釈し、オブジェクトの内部有限状態マシンを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> コンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++">s.size()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><parameter>s</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count()</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.construct7">
	<constructorsynopsis language="C++">
	  <modifier><![CDATA[template <class ForwardIterator>]]></modifier>
	  <methodname>basic_regex</methodname>
	  <methodparam>
	    <type>ForwardIterator</type>
	    <parameter>first</parameter>
	  </methodparam>
	  <methodparam>
	    <type>ForwardIterator</type>
	    <parameter>last</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para>
		[first,last) が正しい正規表現でない場合 <exceptionname linkend="ref.bad_expression">bad_expression</exceptionname>（<parameter>f</parameter> に <constant>no_except</constant> が設定されていない場合）。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<classname linkend="ref.basic_regex">basic_regex</classname> クラスのオブジェクトを構築する。<parameter>f</parameter> で指定した<link linkend="ref.syntax_option_type">オプションフラグ</link>にしたがって文字シーケンス [first,last) の正規表現を解釈し、オブジェクトの内部有限状態マシンを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><classname>basic_regex</classname> コンストラクタの事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++">distance(first,last)</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>(first,last)]]></code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count()</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.opeq1">
	<methodsynopsis language="C++">
	  <type>basic_regex&amp;</type>
	  <methodname>operator=</methodname>
	  <methodparam>
	    <type>const basic_regex&amp;</type>
	    <parameter>e</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">assign(e.str(), e.flags())</code> の結果を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.opeq2">
	<methodsynopsis language="C++">
	  <type>basic_regex&amp;</type>
	  <methodname>operator=</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>ptr</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<parameter>ptr</parameter> は null ポインタ以外。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">assign(ptr)</code> の結果を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.opeq3">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class ST, class SA>]]></modifier>
	  <type>basic_regex&amp;</type>
	  <methodname>operator=</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, ST, SA>&]]></type>
	    <parameter>p</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">assign(p)</code> の結果を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.subexpression">
	<methodsynopsis language="C++">
	  <type><![CDATA[std::pair<const_iterator, const_iterator>]]></type>
	  <methodname>subexpression</methodname>
	  <methodparam>
	    <type>size_type</type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		元の正規表現文字列内のマーク済み部分式 <parameter>n</parameter> の位置を表すイテレータのペアを返す。戻り値のイテレータは <methodname>begin()</methodname> および <methodname>end()</methodname> からの相対位置である。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		正規表現は <type linkend="ref.syntax_option_type">syntax_option_type</type> <constant>save_subexpression_location</constant> を設定してコンパイルしていなければならない。引数 <parameter>n</parameter> は <code>0 &lt;= n &lt; mark_count()</code> の範囲になければならない。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.begin">
	<methodsynopsis language="C++">
	  <type>const_iterator</type>
	  <methodname>begin</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		正規表現を表す文字シーケンスの開始イテレータを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.end">
	<methodsynopsis language="C++">
	  <type>const_iterator</type>
	  <methodname>end</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		正規表現を表す文字シーケンスの終了イテレータを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.size">
	<methodsynopsis language="C++">
	  <type>size_type</type>
	  <methodname>size</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>正規表現を表す文字シーケンスの長さを返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.max_size">
	<methodsynopsis language="C++">
	  <type>size_type</type>
	  <methodname>max_size</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>正規表現を表す文字シーケンスの最大長さを返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.empty">
	<methodsynopsis language="C++">
	  <type>bool</type>
	  <methodname>empty</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>オブジェクトが正しい正規表現を保持していない場合に真を返す。それ以外の場合は偽を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.mark_count">
	<methodsynopsis language="C++">
	  <type>unsigned</type>
	  <methodname>mark_count</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>正規表現中のマーク済み部分式の数を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.assign1">
	<methodsynopsis language="C++">
	  <type>basic_regex&amp;</type>
	  <methodname>assign</methodname>
	  <methodparam>
	    <type>const basic_regex&amp;</type>
	    <parameter>that</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++" linkend="ref.basic_regex.assign4">assign(that.str(), that.flags())</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.assign2">
	<methodsynopsis language="C++">
	  <type>basic_regex&amp;</type>
	  <methodname>assign</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>ptr</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++" linkend="ref.basic_regex.assign4">assign(string_type(ptr), f)</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.assign3">
	<methodsynopsis language="C++">
	  <type>basic_regex&amp;</type>
	  <methodname>assign</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>ptr</parameter>
	  </methodparam>
	  <methodparam>
	    <type>unsigned int</type>
	    <parameter>len</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++" linkend="ref.basic_regex.assign4">assign(string_type(ptr, len), f)</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.assign4">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class string_traits, class A>]]></modifier>
	  <type>basic_regex&amp;</type>
	  <methodname>assign</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_string<charT, string_traits, A>&]]></type>
	    <parameter>s</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>例外：</term>
	    <listitem>
	      <para><parameter>s</parameter> が正しい正規表現でない場合 <exceptionname linkend="ref.bad_expression">bad_expression</exceptionname>（<parameter>f</parameter> に <constant>no_except</constant> が設定されていない場合）。</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>戻り値：</term>
	    <listitem>
	      <para><code language="C++">*this</code>。</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><parameter>f</parameter> で指定した<link linkend="ref.syntax_option_type">オプションフラグ</link>にしたがって文字列 <parameter>s</parameter> の正規表現を解釈し代入する。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<table>
	  <caption><methodname>basic_regex::assign</methodname> の事後条件</caption>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>false</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++">s.size()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><parameter>s</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">flags()</code></td>
	      <td><parameter>f</parameter></td>
	    </tr>
	    <tr>
	      <td><code language="C++">mark_count</code></td>
	      <td>正規表現中に含まれるマーク済み部分式の総数</td>
	    </tr>
	  </tbody>
	</table>
      </listitem>

      <listitem xml:id="ref.basic_regex.assign5">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class InputIterator>]]></modifier>
	  <type>basic_regex&amp;</type>
	  <methodname>assign</methodname>
	  <methodparam>
	    <type>InputIterator</type>
	    <parameter>first</parameter>
	  </methodparam>
	  <methodparam>
	    <type>InputIterator</type>
	    <parameter>last</parameter>
	  </methodparam>
	  <methodparam>
	    <type>flag_type</type>
	    <parameter>f</parameter>
	    <initializer>regex_constants::normal</initializer>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para><type>InputIterator</type> 型は<link xlink:href="http://input_iterator/">入力イテレータの要件（24.1.1）</link>を満たす。</para>
	      <!-- ??? -->
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++" linkend="ref.basic_regex.assign4">assign(string_type(first, last), f)</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.flags">
	<methodsynopsis language="C++">
	  <type>flag_type</type>
	  <methodname>flags</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>オブジェクトのコンストラクタ、あるいは最後の <methodname>assign</methodname> の呼び出しで渡した<link linkend="ref.syntax_option_type">正規表現構文のフラグ</link>のコピーを返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.status">
	<methodsynopsis language="C++">
	  <type>int</type>
	  <methodname>status</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>正規表現が正しい正規表現であれば 0、それ以外の場合はエラーコードを返す。このメンバ関数は例外処理を使用できない環境のために用意されている。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.str">
	<methodsynopsis language="C++">
	  <type><![CDATA[basic_string<charT>]]></type>
	  <methodname>str</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>オブジェクトのコンストラクタ、あるいは最後の <methodname>assign</methodname> の呼び出しで渡した文字シーケンスのコピーを返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.compare">
	<methodsynopsis language="C++">
	  <type>int</type>
	  <methodname>compare</methodname>
	  <methodparam>
	    <type>basic_regex&amp;</type>
	    <parameter>e</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">flags() == e.flags()</code> であれば <code language="C++">str().compare(e.str())</code> を、それ以外の場合は <code language="C++">flags() - e.flags()</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.imbue">
	<methodsynopsis language="C++">
	  <type>locale_type</type>
	  <methodname>imbue</methodname>
	  <methodparam>
	    <type>locale_type</type>
	    <parameter>l</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">traits_inst.imbue(l)</code> の結果を返す。<varname>traits_inst</varname> はオブジェクト内の、テンプレート引数 <type>traits</type> のインスタンス（をデフォルトコンストラクタで初期化したもの）である。</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>事後条件：</term>
	    <listitem>
	      <para><code language="C++">empty() == true</code>。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.getloc">
	<methodsynopsis language="C++">
	  <type>locale_type</type>
	  <methodname>getloc</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">traits_inst.getloc()</code> の結果を返す。<varname>traits_inst</varname> はオブジェクト内の、テンプレート引数 <type>traits</type> のインスタンス（をデフォルトコンストラクタで初期化したもの）である。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.swap">
	<methodsynopsis language="C++">
	  <type>void</type>
	  <methodname>swap</methodname>
	  <methodparam>
	    <type>basic_regex&amp;</type>
	    <parameter>e</parameter>
	  </methodparam>
	  <modifier>throw()</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>2 つの正規表現の内容を交換する。</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>事後条件：</term>
	    <listitem>
	      <para><code language="C++">*this</code> は <parameter>e</parameter> にあった正規表現を保持し、<parameter>e</parameter> は <code language="C++">*this</code> にあった正規表現を保持する。</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>計算量：</term>
	    <listitem>
	      <para>一定。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_eq">
	<note>
	  <para>
	    <classname linkend="ref.basic_regex">basic_regex</classname> オブジェクト間の比較は実験的なものである。<link xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf">Technical Report on C++ Libraries</link> には記述がなく、<classname linkend="ref.basic_regex">basic_regex</classname> の他の実装に移植する必要がある場合は注意していただきたい。
	  </para>
	</note>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator ==</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) == 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_ne">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator !=</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) != 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_lt">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator &lt;</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) &lt; 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_le">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator &lt;=</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) &lt;= 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_ge">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator &gt;=</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) &gt;= 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_gt">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits>]]></modifier>
	  <type>bool</type>
	  <methodname>operator &gt;</methodname>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, traits>&]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.compare(rhs) &gt; 0</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_stream">
	<note>
	  <para>
	    <classname>basic_regex</classname> のストリーム挿入子は実験的なものであり、正規表現のテキスト表現をストリームに出力する。
	  </para>
	</note>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class io_traits, class re_traits>]]></modifier>
	  <type><![CDATA[basic_ostream<charT, io_traits>&]]></type>
	  <methodname>operator &lt;&lt;</methodname>
	  <methodparam>
	    <type><![CDATA[basic_ostream<charT, io_traits>&]]></type>
	    <parameter>os</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const basic_regex<charT, re_traits>&]]></type>
	    <parameter>e</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">(os &lt;&lt; e.str())</code> を返す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.basic_regex.op_swap">
	<methodsynopsis language="C++">
	  <type>void</type>
	  <methodname>swap</methodname>
	  <methodparam>
	    <type><![CDATA[basic_regex<charT, traits>&amp;]]></type>
	    <parameter>lhs</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[basic_regex<charT, traits>&amp;]]></type>
	    <parameter>rhs</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para><code language="C++">lhs.swap(rhs)</code> を呼び出す。</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>
    </orderedlist>
  </sect4>
</section>

<?xml version="1.0" ?>
<!--
  Copyright 2006-2007 John Maddock.
  Distributed under the Boost Software License, Version 1.0.
  (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
-->
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="ref.match_results">
  <title>match_results</title>

  <sect4 xml:id="ref.match_results.synopsis">
    <title>概要</title>
    <programlisting language="C++"><![CDATA[#include <boost/regex.hpp>]]></programlisting>
    <para>
      正規表現が他の多くの単純なパターンマッチアルゴリズムと異なるのは、マッチを発見するだけでなく、部分式のマッチを生成する点である。各部分式はパターン中の括弧の組 <phrase role="regex.pattern">(…)</phrase> により、その範囲が与えられる。部分式のマッチをユーザに知らせるために何らかの方法が必要である。部分式マッチの添字付きコレクションとして振舞う <classname>match_results</classname> クラスの定義がそれであり、各部分式マッチは <classname linkend="ref.sub_match">sub_match</classname> 型オブジェクトに含まれる。
    </para>
    <para>
      テンプレートクラス <classname>match_results</classname> は、正規表現マッチの結果を表す文字シーケンスのコレクションを表現する。<classname>match_results</classname> 型のオブジェクトは <function linkend="ref.regex_match">regex_match</function> および <function linkend="ref.regex_search">regex_search</function> アルゴリズムに渡して使用する。またイテレータ <classname linkend="ref.regex_iterator">regex_iterator</classname> がこのオブジェクトを返す。このコレクションが使用するストレージは、<classname>match_results</classname> のメンバ関数が必要に応じて割り当て、解放する。
    </para>
    <para>
      テンプレートクラス <classname>match_results</classname> は（lib.sequence.reqmts）が規定する Sequence の要件を満たす。ただし const 限定の操作に限られる。
    </para>
    <para>
      大抵の場合、クラステンプレート <classname>match_results</classname> を使用するときは、その typedef である <type>cmatch</type> 、<type>wcmatch</type> 、<type>smatch</type> および <type>wsmatch</type> のいずれかを用いる。
    </para>
    <programlisting language="C++">template &lt;class BidirectionalIterator,
          class Allocator = std::allocator&lt;sub_match&lt;BidirectionalIterator&gt; &gt;
class match_results;

typedef match_results&lt;const char*&gt;              cmatch;
typedef match_results&lt;const wchar_t*&gt;           wcmatch;
typedef match_results&lt;string::const_iterator&gt;   smatch;
typedef match_results&lt;wstring::const_iterator&gt;  wsmatch;

template &lt;class BidirectionalIterator,
          class Allocator = std::allocator&lt;sub_match&lt;BidirectionalIterator&gt; &gt;
class match_results
{
public:
   typedef          sub_match&lt;BidirectionalIterator&gt;                        value_type;
   typedef          const value_type&amp;                                       const_reference;
   typedef          const_reference                                         reference;
   typedef          <replaceable>implementation defined</replaceable>                                  const_iterator;
   typedef          const_iterator                                          iterator;
   typedef typename iterator_traits&lt;BidirectionalIterator&gt;::difference_type difference_type;
   typedef typename Allocator::size_type                                    size_type;
   typedef          Allocator                                               allocator_type;
   typedef typename iterator_traits&lt;BidirectionalIterator&gt;::value_type      char_type;
   typedef          basic_string&lt;char_type&gt;                                 string_type;

   // 構築、コピー、解体：
   explicit <methodname linkend="ref.match_results.construct">match_results</methodname>(const Allocator&amp; a = Allocator());
   <methodname linkend="ref.match_results.copy_construct">match_results</methodname>(const match_results&amp; m);
   match_results&amp; <methodname linkend="ref.match_results.assign">operator=</methodname>(const match_results&amp; m);
   ~match_results();

   // サイズ：
   size_type <methodname linkend="ref.match_results.size">size</methodname>() const;
   size_type <methodname linkend="ref.match_results.max_size">max_size</methodname>() const;
   bool <methodname linkend="ref.match_results.empty">empty</methodname>() const;
   // 要素アクセス：
   difference_type <methodname linkend="ref.match_results.length">length</methodname>(int sub = 0) const;
   difference_type <methodname linkend="ref.match_results.length">length</methodname>(const char_type* sub) const;
   template &lt;class charT&gt;
   difference_type <methodname linkend="ref.match_results.length">length</methodname>(const charT* sub) const;
   template &lt;class charT, class Traits, class A&gt;
   difference_type <methodname linkend="ref.match_results.length">length</methodname>(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const;
   difference_type <methodname linkend="ref.match_results.position">position</methodname>(unsigned int sub = 0) const;
   difference_type <methodname linkend="ref.match_results.position">position</methodname>(const char_type* sub) const;
   template &lt;class charT&gt;
   difference_type <methodname linkend="ref.match_results.position">position</methodname>(const charT* sub) const;
   template &lt;class charT, class Traits, class A&gt;
   difference_type <methodname linkend="ref.match_results.position">position</methodname>(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const;
   string_type <methodname linkend="ref.match_results.str">str</methodname>(int sub = 0) const;
   string_type <methodname linkend="ref.match_results.str">str</methodname>(const char_type* sub)const;
   template &lt;class Traits, class A&gt;
   string_type <methodname linkend="ref.match_results.str">str</methodname>(const std::basic_string&lt;char_type, Traits, A&gt;&amp; sub)const;
   template &lt;class charT&gt;
   string_type <methodname linkend="ref.match_results.str">str</methodname>(const charT* sub)const;
   template &lt;class charT, class Traits, class A&gt;
   string_type <methodname linkend="ref.match_results.str">str</methodname>(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub)const;
   const_reference <methodname linkend="ref.match_results.subscript">operator[]</methodname>(int n) const;
   const_reference <methodname linkend="ref.match_results.subscript">operator[]</methodname>(const char_type* n) const;
   template &lt;class Traits, class A&gt;
   const_reference <methodname linkend="ref.match_results.subscript">operator[]</methodname>(const std::basic_string&lt;char_type, Traits, A&gt;&amp; n) const;
   template &lt;class charT&gt;
   const_reference <methodname linkend="ref.match_results.subscript">operator[]</methodname>(const charT* n) const;
   template &lt;class charT, class Traits, class A&gt;
   const_reference <methodname linkend="ref.match_results.subscript">operator[]</methodname>(const std::basic_string&lt;charT, Traits, A&gt;&amp; n) const;

   const_reference <methodname linkend="ref.match_results.prefix">prefix</methodname>() const;
   const_reference <methodname linkend="ref.match_results.suffix">suffix</methodname>() const;
   const_iterator <methodname linkend="ref.match_results.begin">begin</methodname>() const;
   const_iterator <methodname linkend="ref.match_results.end">end</methodname>() const;

   // 書式化：
   template &lt;class OutputIterator, class Formatter&gt;
   OutputIterator <methodname linkend="ref.match_results.format">format</methodname>(OutputIterator out,
                        Formatter&amp; fmt,
                        match_flag_type flags = format_default) const;
   template &lt;class Formatter&gt;
   string_type <methodname linkend="ref.match_results.format2">format</methodname>(const Formatter fmt,
                      match_flag_type flags = format_default) const;

   allocator_type <methodname linkend="ref.match_results.get_allocator">get_allocator</methodname>() const;
   void <methodname linkend="ref.match_results.swap">swap</methodname>(match_results&amp; that);

#ifdef BOOST_REGEX_MATCH_EXTRA
   typedef typename value_type::capture_sequence_type capture_sequence_type;
   const capture_sequence_type&amp; <methodname linkend="ref.match_results.captures">captures</methodname>(std::size_t i)const;
#endif

};

template &lt;class BidirectionalIterator, class Allocator&gt;
bool <methodname linkend="ref.match_results.op_eq">operator ==</methodname> (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
template &lt;class BidirectionalIterator, class Allocator&gt;
bool <methodname linkend="ref.match_results.op_ne">operator !=</methodname> (const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
                  const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);

template &lt;class charT, class traits, class BidirectionalIterator, class Allocator&gt;
basic_ostream&lt;charT, traits&gt;&amp;
   <methodname linkend="ref.match_results.op_stream">operator &lt;&lt;</methodname> (basic_ostream&lt;charT, traits&gt;&amp; os,
                const match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m);

template &lt;class BidirectionalIterator, class Allocator&gt;
void <methodname linkend="ref.match_results.op_swap">swap</methodname>(match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m1,
          match_results&lt;BidirectionalIterator, Allocator&gt;&amp; m2);
    </programlisting>
  </sect4>

  <sect4 xml:id="ref.match_results.description">
    <title>説明</title>
    <orderedlist>
      <listitem xml:id="ref.match_results.construct">
	<para>
	  <classname>match_results</classname> のすべてのコンストラクタにおける <type>Allocator</type> 引数のコピーは、オブジェクトの生涯にわたってコンストラクタとメンバ関数によるメモリ割り当てに使用される。
	</para>
	<constructorsynopsis language="C++">
	  <methodname>match_results</methodname>
	  <methodparam>
	    <type>const Allocator&amp;</type>
	    <parameter>a</parameter>
	    <initializer>Allocator()</initializer>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> クラスのオブジェクトを構築する。この関数の事後条件は次の表のとおりである。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<informaltable>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><constant>true</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><constant>0</constant></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str()</code></td>
	      <td><code language="C++"><![CDATA[basic_string<charT>()]]></code></td>
	    </tr>
	  </tbody>
	</informaltable>
      </listitem>

      <listitem xml:id="ref.match_results.copy_construct">
	<constructorsynopsis language="C++">
	  <methodname>match_results</methodname>
	  <methodparam>
	    <type>const match_results&amp;</type>
	    <parameter>m</parameter>
	  </methodparam>
	</constructorsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<parameter>m</parameter> をコピーして <classname>match_results</classname> クラスのオブジェクトを構築する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.assign">
	<methodsynopsis language="C++">
	  <type>match_results&amp;</type>
	  <methodname>operator=</methodname>
	  <methodparam>
	    <type>const match_results&amp;</type>
	    <parameter>m</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<parameter>m</parameter> を <code language="C++">*this</code> に代入する。この関数の事後条件は次の表のとおりである。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<informaltable>
	  <thead>
	    <tr>
	      <th>要素</th>
	      <th>値</th>
	    </tr>
	  </thead>
	  <tbody>
	    <tr>
	      <td><code language="C++">empty()</code></td>
	      <td><code language="C++">m.empty()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">size()</code></td>
	      <td><code language="C++">m.size()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">str(n)</code></td>
	      <td><code language="C++">n &lt; m.size()</code> であるすべての整数で <code language="C++">m.str(n)</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">prefix()</code></td>
	      <td><code language="C++">m.prefix()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">suffix()</code></td>
	      <td><code language="C++">m.suffix()</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">(*this)[n]</code></td>
	      <td><code language="C++">n &lt; m.size()</code> であるすべての整数で <code language="C++">m[n]</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">length(n)</code></td>
	      <td><code language="C++">n &lt; m.size()</code> であるすべての整数で <code language="C++">m.length(n)</code></td>
	    </tr>
	    <tr>
	      <td><code language="C++">position(n)</code></td>
	      <td><code language="C++">n &lt; m.size()</code> であるすべての整数で <code language="C++">m.position(n)</code></td>
	    </tr>
	  </tbody>
	</informaltable>
      </listitem>

      <listitem xml:id="ref.match_results.size">
	<methodsynopsis language="C++">
	  <type>size_type</type>
	  <methodname>size</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">*this</code> 中の <classname linkend="ref.sub_match">sub_match</classname> 要素数を返す。これは正規表現中でマッチしたマーク済み部分式の数に 1 を足したものである。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.max_size">
	<methodsynopsis language="C++">
	  <type>size_type</type>
	  <methodname>max_size</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">*this</code> に格納可能な <classname linkend="ref.sub_match">sub_match</classname> 要素の最大数を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.empty">
	<methodsynopsis language="C++">
	  <type>bool</type>
	  <methodname>empty</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">size() == 0</code> を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.length">
	<methodsynopsis language="C++">
	  <type>difference_type</type>
	  <methodname>length</methodname>
	  <methodparam>
	    <type>int</type>
	    <parameter>sub</parameter>
	    <initializer>0</initializer>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <type>difference_type</type>
	  <methodname>length</methodname>
	  <methodparam>
	    <type>const char_type*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier>template &lt;charT&gt;</modifier>
	  <type>difference_type</type>
	  <methodname>length</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier>template &lt;charT, class Traits, class A&gt;</modifier>
	  <type>difference_type</type>
	  <methodname>length</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<charT, Traits, A>&]]></type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		部分式 <parameter>sub</parameter> の長さを返す。<code language="C++">(*this)[sub].length()</code> と同じである。
	      </para>
	      <para>
		文字列を引数に取る多重定義は <replaceable>n</replaceable> 番目の名前付き部分式を参照する。指定した名前をもつ部分式がない場合は 0 を返す。
	      </para>
	      <para>
		この関数のテンプレート多重定義に渡す文字列・文字の型は、オブジェクトが保持するシーケンスや正規表現の文字型と異なっていてもよい。この場合、文字列は正規表現が保持する文字型に変換される。引数の文字型が正規表現が保持するシーケンスの文字型より幅が大きい場合はコンパイルエラーとなる。これらの多重定義は、マッチを行う正規表現の文字型が Unicode 文字型のような変り種の場合であっても、通常の幅の小さい C 文字列リテラルを引数として渡せるようにしてある。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.position">
	<methodsynopsis language="C++">
	  <type>difference_type</type>
	  <methodname>position</methodname>
	  <methodparam>
	    <type>unsigned int</type>
	    <parameter>sub</parameter>
	    <initializer>0</initializer>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <type>difference_type</type>
	  <methodname>position</methodname>
	  <methodparam>
	    <type>const char_type*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT>]]></modifier>
	  <type>difference_type</type>
	  <methodname>position</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class Traits, class A>]]></modifier>
	  <type>difference_type</type>
	  <methodname>position</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<charT, Traits, A>&]]></type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		部分式 <parameter>sub</parameter> の開始位置を返す。<parameter>sub</parameter> がマッチしなかった場合は -1 を返す。部分マッチの場合は <code language="C++">(*this)[0].matched</code> は偽であるが、<code language="C++">position()</code> は部分マッチの位置を返す。
	      </para>
	      <para>
		文字列を引数に取る多重定義は <replaceable>n</replaceable> 番目の名前付き部分式を参照する。指定した名前をもつ部分式がない場合は -1 を返す。
	      </para>
	      <para>
		この関数のテンプレート多重定義に渡す文字列・文字の型は、オブジェクトが保持するシーケンスや正規表現の文字型と異なっていてもよい。この場合、文字列は正規表現が保持する文字型に変換される。引数の文字型が正規表現が保持するシーケンスの文字型より幅が大きい場合はコンパイルエラーとなる。これらの多重定義は、マッチを行う正規表現の文字型が Unicode 文字型のような変り種の場合であっても、通常の幅の小さい C 文字列リテラルを引数として渡せるようにしてある。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.str">
	<methodsynopsis language="C++">
	  <type>string_type</type>
	  <methodname>str</methodname>
	  <methodparam>
	    <type>int</type>
	    <parameter>sub</parameter>
	    <initializer>0</initializer>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <type>string_type</type>
	  <methodname>str</methodname>
	  <methodparam>
	    <type>const char_type*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class Traits, class A>]]></modifier>
	  <type>string_type</type>
	  <methodname>str</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<char_type, Traits, A>&]]></type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT>]]></modifier>
	  <type>string_type</type>
	  <methodname>str</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class Traits, class A>]]></modifier>
	  <type>string_type</type>
	  <methodname>str</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<charT, Traits, A>&]]></type>
	    <parameter>sub</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		部分式 <parameter>sub</parameter> の文字列を返す。<code language="C++">string_type((*this)[sub])</code> と同じである。
	      </para>
	      <para>
		文字列を引数に取る多重定義は <replaceable>n</replaceable> 番目の名前付き部分式を参照する。指定した名前をもつ部分式がない場合は空文字列を返す。
	      </para>
	      <para>
		この関数のテンプレート多重定義に渡す文字列・文字の型は、オブジェクトが保持するシーケンスや正規表現の文字型と異なっていてもよい。この場合、文字列は正規表現が保持する文字型に変換される。引数の文字型が正規表現が保持するシーケンスの文字型より幅が大きい場合はコンパイルエラーとなる。これらの多重定義は、マッチを行う正規表現の文字型が Unicode 文字型のような変り種の場合であっても、通常の幅の小さい C 文字列リテラルを引数として渡せるようにしてある。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.subscript">
	<methodsynopsis language="C++">
	  <type>const_reference</type>
	  <methodname>operator[]</methodname>
	  <methodparam>
	    <type>int</type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <type>const_reference</type>
	  <methodname>operator[]</methodname>
	  <methodparam>
	    <type>const char_type*</type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class Traits, class A>]]></modifier>
	  <type>const_reference</type>
	  <methodname>operator[]</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<char_type, Traits, A>&]]></type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT>]]></modifier>
	  <type>const_reference</type>
	  <methodname>operator[]</methodname>
	  <methodparam>
	    <type>const charT*</type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class Traits, class A>]]></modifier>
	  <type>const_reference</type>
	  <methodname>operator[]</methodname>
	  <methodparam>
	    <type><![CDATA[const std::basic_string<charT, Traits, A>&]]></type>
	    <parameter>n</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		マーク済み部分式 <replaceable>n</replaceable> にマッチした文字シーケンスを表す <classname linkend="ref.sub_match">sub_match</classname> オブジェクトへの参照を返す。<code language="C++">n == 0</code> の場合は、正規表現全体にマッチした文字シーケンスを表す <classname linkend="ref.sub_match">sub_match</classname> オブジェクトへの参照を返す。<replaceable>n</replaceable> が範囲外であるかマッチしなかった部分式を指している場合は、<property>matched</property> メンバが偽である <classname linkend="ref.sub_match">sub_match</classname> オブジェクトを返す。
	      </para>
	      <para>
		文字列を引数に取る多重定義は <replaceable>n</replaceable> 番目の名前付き部分式にマッチした文字シーケンスを表す <classname linkend="ref.sub_match">sub_match</classname> オブジェクトへの参照を返す。指定した名前をもつ部分式がない場合は <property>matched</property> メンバが偽である <classname linkend="ref.sub_match">sub_match</classname> オブジェクトを返す。
	      </para>
	      <para>
		この関数のテンプレート多重定義に渡す文字列・文字の型は、オブジェクトが保持するシーケンスや正規表現の文字型と異なっていてもよい。この場合、文字列は正規表現が保持する文字型に変換される。引数の文字型が正規表現が保持するシーケンスの文字型より幅が大きい場合はコンパイルエラーとなる。これらの多重定義は、マッチを行う正規表現の文字型が Unicode 文字型のような変り種の場合であっても、通常の幅の小さい C 文字列リテラルを引数として渡せるようにしてある。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.prefix">
	<methodsynopsis language="C++">
	  <type>const_reference</type>
	  <methodname>prefix</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		マッチ・検索を行う文字列の先頭から見つかったマッチの先頭までの文字シーケンスを表す <classname linkend="ref.sub_match">sub_match</classname> オブジェクトへの参照を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.suffix">
	<methodsynopsis language="C++">
	  <type>const_reference</type>
	  <methodname>suffix</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		見つかったマッチの終端からマッチ・検索を行う文字列の終端までの文字シーケンスを表す <classname linkend="ref.sub_match">sub_match</classname> オブジェクトへの参照を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.begin">
	<methodsynopsis language="C++">
	  <type>const_iterator</type>
	  <methodname>begin</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">*this</code> に格納されたすべてのマーク済み部分式を列挙する開始イテレータを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.end">
	<methodsynopsis language="C++">
	  <type>const_iterator</type>
	  <methodname>end</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">*this</code> に格納されたすべてのマーク済み部分式を列挙する終了イテレータを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.format">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class OutputIterator, class Formatter>]]></modifier>
	  <type>OutputIterator</type>
	  <methodname>format</methodname>
	  <methodparam>
	    <type>OutputIterator</type>
	    <parameter>out</parameter>
	  </methodparam>
	  <methodparam>
	    <type>Formatter</type>
	    <parameter>fmt</parameter>
	  </methodparam>
	  <methodparam>
	    <type>match_flag_type</type>
	    <parameter>flags</parameter>
	    <initializer>format_default</initializer>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		型 <type>OutputIterator</type> が出力イテレータの要件（C++ 標準 24.1.2）を満たす。
	      </para>
	      <para>
		型 <type>Formatter</type> は <type>char_type[]</type> 型の null 終端文字列へのポインタ、<type>char_type</type> 型のコンテナ（例えば <classname>std::basic_string&lt;char_type&gt;</classname>）、あるいは関数呼び出しにより置換文字列を生成する単項・二項・三項関数子のいずれかでなければならない。関数子の場合、<code language="C++">fmt(*this)</code> は置換テキストと使用する <type>char_type</type> のコンテナを返さなければならず、<code language="C++">fmt(*this, out)</code> および <code language="C++">fmt(*this, out, flags)</code> はいずれも置換テキストを <code language="C++">*out</code> に出力し <type>OutputIterator</type> の新しい位置を返さなければならない。書式化子が関数子の場合は<emphasis>値渡し</emphasis>となることに注意していただきたい。内部状態を持つ関数オブジェクトを渡す場合、<link xlink:href="http://www.boost.org/libs/ref.html">Boost.Ref</link> を使用してオブジェクトを参照渡しするとよい。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<parameter>fmt</parameter> が null 終端文字列か <type>char_type</type> のコンテナであれば、文字シーケンス <code>[fmt.begin(), fmt.end())</code> を <type>OutputIterator</type> <parameter>out</parameter> にコピーする。<parameter>fmt</parameter> 中の各書式指定子とエスケープシーケンスは、シーケンスをそれぞれが表す文字（列）か、参照する <code language="C++">*this</code> 中の文字シーケンスで置換する。<parameter>flags</parameter> で指定したビットマスクはどの書式指定子・エスケープシーケンスを使用するか決定し、既定では ECMA-262 、ECMAScript 言語仕様、15 章 5.4.11 String.prototype.replace で使用されている書式である。
	      </para>
	      <para>
		<parameter>fmt</parameter> が関数オブジェクトであれば、関数オブジェクトが受け取った引数の数により以下のようになる。
	      </para>
	      <itemizedlist>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this)</code> を呼び出し、結果を <type>OutputIterator</type> <parameter>out</parameter> にコピーする。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this, out)</code> を呼び出す。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this, out, flags)</code> を呼び出す。
		  </para>
		</listitem>
	      </itemizedlist>
	      <para>
		すべての場合で <type>OutputIterator</type> の新しい位置が返される。
	      </para>
	      <para>
		詳細は<link linkend="format">書式化構文ガイド</link>を見よ。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>戻り値：</term>
	    <listitem>
	      <para>
		<parameter>out</parameter>。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.format2">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class Formatter>]]></modifier>
	  <type>string_type</type>
	  <methodname>format</methodname>
	  <methodparam>
	    <type>Formatter</type>
	    <parameter>fmt</parameter>
	  </methodparam>
	  <methodparam>
	    <type>match_flag_type</type>
	    <parameter>flags</parameter>
	    <initializer>format_default</initializer>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		型 <type>Formatter</type> は <type>char_type[]</type> 型の null 終端文字列へのポインタ、<type>char_type</type> 型のコンテナ（例えば <classname>std::basic_string&lt;char_type&gt;</classname>）、あるいは関数呼び出しにより置換文字列を生成する単項・二項・三項関数子のいずれかでなければならない。関数子の場合、<code language="C++">fmt(*this)</code> は置換テキストと使用する <type>char_type</type> のコンテナを返さなければならず、<code language="C++">fmt(*this, out)</code> および <code language="C++">fmt(*this, out, flags)</code> はいずれも置換テキストを <code language="C++">*out</code> に出力し <type>OutputIterator</type> の新しい位置を返さなければならない。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<parameter>fmt</parameter> が null 終端文字列か <type>char_type</type> のコンテナであれば、文字列 <parameter>fmt</parameter> をコピーする。<parameter>fmt</parameter> 中の各書式指定子とエスケープシーケンスは、シーケンスをそれぞれが表す文字（列）か、参照する <code language="C++">*this</code> 中の文字シーケンスで置換する。<parameter>flags</parameter> で指定したビットマスクはどの書式指定子・エスケープシーケンスを使用するか決定し、既定では ECMA-262 、ECMAScript 言語仕様、15 章 5.4.11 String.prototype.replace で使用されている書式である。
	      </para>
	      <para>
		<parameter>fmt</parameter> が関数オブジェクトであれば、関数オブジェクトが受け取った引数の数により以下のようになる。
	      </para>
	      <itemizedlist>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this)</code> を呼び出し、結果を返す。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this, <replaceable>unspecified-output-iterator</replaceable>)</code> を呼び出す。<replaceable>unspecified-output-iterator</replaceable> は出力を結果文字列にコピーする指定なしの <type>OutputIterator</type> 型である。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <code language="C++">fmt(*this, <replaceable>unspecified-output-iterator</replaceable>, flags)</code> を呼び出す。<replaceable>unspecified-output-iterator</replaceable> は出力を結果文字列にコピーする指定なしの <type>OutputIterator</type> 型である。
		  </para>
		</listitem>
	      </itemizedlist>
	      <para>
		すべての場合で <type>OutputIterator</type> の新しい位置が返される。
	      </para>
	      <para>
		詳細は<link linkend="format">書式化構文ガイド</link>を見よ。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.get_allocator">
	<methodsynopsis language="C++">
	  <type>allocator_type</type>
	  <methodname>get_allocator</methodname>
	  <void/>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		オブジェクトのコンストラクタで渡した <type>Allocator</type> のコピーを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.swap">
	<methodsynopsis language="C++">
	  <type>void</type>
	  <methodname>swap</methodname>
	  <methodparam>
	    <type>match_results&amp;</type>
	    <parameter>that</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		2 つのシーケンスの内容を交換する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>事後条件：</term>
	    <listitem>
	      <para>
		<code language="C++">*this</code> は、<parameter>that</parameter> が保持していた、部分式にマッチしたシーケンスを保持する。<parameter>that</parameter> は、<code language="C++">*this</code> が保持していた、部分式にマッチしたシーケンスを保持する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>計算量：</term>
	    <listitem>
	      <para>
		一定。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.capture_type">
	<programlisting language="C++">typedef typename value_type::capture_sequence_type capture_sequence_type;</programlisting>
	<para>
	  標準ライブラリ Sequence の要件（21.1.1 および表 68 の操作）を満たす実装固有の型を定義する。その <type>value_type</type> は <classname>sub_match&lt;BidirectionalIterator&gt;</classname> である。この型が <classname>std::vector&lt;sub_match&lt;BidirectionalIterator&gt; &gt;</classname> となる可能性もあるが、それに依存すべきではない。
	</para>
      </listitem>

      <listitem xml:id="ref.match_results.captures">
	<methodsynopsis language="C++">
	  <type>const capture_sequence_type&amp;</type>
	  <methodname>captures</methodname>
	  <methodparam>
	    <type>std::size_t</type>
	    <parameter>i</parameter>
	  </methodparam>
	  <modifier>const</modifier>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>要件：</term>
	    <listitem>
	      <para>
		<classname>match_results</classname> オブジェクトが <function linkend="ref.regex_search">regex_search</function> か <function linkend="ref.regex_match">regex_match</function> の呼び出し結果で初期化された、または <classname linkend="ref.regex_iterator">regex_iterator</classname> が返したもので、かつそのイテレータが無効状態でない。<classname>match_results</classname> オブジェクトが未初期化の場合、<exceptionname>std::logic_error</exceptionname> が発生する。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		部分式 <parameter>i</parameter> に対するすべての捕捉を格納したシーケンスを返す。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>戻り値：</term>
	    <listitem>
	      <para>
		<code language="C++">(*this)[i].captures();</code>
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>事前条件：</term>
	    <listitem>
	      <para>
		<symbol>BOOST_REGEX_MATCH_EXTRA</symbol> を使ってライブラリをビルドしていなければ、このメンバ関数は定義されない。また正規表現マッチ関数（<function linkend="ref.regex_match">regex_match</function> 、<function linkend="ref.regex_search">regex_search</function> 、<classname linkend="ref.regex_iterator">regex_iterator</classname> 、<classname linkend="ref.regex_token_iterator">regex_token_iterator</classname>）にフラグ <constant>match_extra</constant> を渡していなければ、有用な情報を返さない。
	      </para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>根拠：</term>
	    <listitem>
	      <para>
		この機能を有効にするといくつか影響がある。
	      </para>
	      <itemizedlist>
		<listitem>
		  <para>
		    <classname>sub_match</classname> がより多くのメモリを占有し、複雑な正規表現をマッチする場合にすぐにメモリやスタック空間の不足に陥る。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <constant>match_extra</constant> を使用しない場合であっても、処理する機能（例えば独立部分式）によってはマッチアルゴリズムの効率が落ちる。
		  </para>
		</listitem>
		<listitem>
		  <para>
		    <constant>match_extra</constant> を使用するとさらに効率が落ちる（速度が低下する）。ほとんどの場合、さらに必要なメモリ割り当てが起こる。
		  </para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.op_eq">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class BidirectionalIterator, class Allocator>]]></modifier>
	  <type>bool</type>
	  <methodname>operator ==</methodname>
	  <methodparam>
	    <type><![CDATA[const match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m1</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m2</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		2 つのシーケンスの等価性を比較する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.op_ne">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class BidirectionalIterator, class Allocator>]]></modifier>
	  <type>bool</type>
	  <methodname>operator !=</methodname>
	  <methodparam>
	    <type><![CDATA[const match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m1</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m2</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		2 つのシーケンスの非等価性を比較する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.op_stream">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class charT, class traits, class BidirectionalIterator, class Allocator>]]></modifier>
	  <type><![CDATA[basic_ostream<charT, traits>&]]></type>
	  <methodname>operator &lt;&lt;</methodname>
	  <methodparam>
	    <type><![CDATA[basic_ostream<charT, traits>&]]></type>
	    <parameter>os</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[const match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		<code language="C++">os &lt;&lt; m.str()</code> の要領で <parameter>m</parameter> の内容をストリーム <parameter>os</parameter> に書き込む。<parameter>os</parameter> を返す。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>

      <listitem xml:id="ref.match_results.op_swap">
	<methodsynopsis language="C++">
	  <modifier><![CDATA[template <class BidirectionalIterator, class Allocator>]]></modifier>
	  <type>void</type>
	  <methodname>swap</methodname>
	  <methodparam>
	    <type><![CDATA[match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m1</parameter>
	  </methodparam>
	  <methodparam>
	    <type><![CDATA[match_results<BidirectionalIterator, Allocator>&]]></type>
	    <parameter>m2</parameter>
	  </methodparam>
	</methodsynopsis>
	<variablelist spacing="compact">
	  <varlistentry>
	    <term>効果：</term>
	    <listitem>
	      <para>
		2 つのシーケンスの内容を交換する。
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </listitem>
    </orderedlist>
  </sect4>
</section>



<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>よくある質問と回答 &mdash; Boost.Python（日本語訳）  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="Boost.Python（NumPy）" href="numpy/index.html" />
    <link rel="prev" title="サポートリソース" href="support.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Boost.Python（日本語訳）
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">リリースノート</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">チュートリアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">ビルドとテスト</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">リファレンスマニュアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">設定に関する情報</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">用語</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">サポートリソース</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">よくある質問と回答</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy/index.html">Boost.Python（NumPy）</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">動作を確認したプラットフォームとコンパイラ</a></li>
<li class="toctree-l1"><a class="reference internal" href="projects.html">Boost.Python を使用しているプロジェクト</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals.html">Boost.Python の裏側</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">新着情報・変更履歴</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">TODO リスト</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress_reports.html">LLNL 進捗レポート</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">謝辞</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boost.Python（日本語訳）</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>よくある質問と回答</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/faq.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>よくある質問と回答<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents local topic" id="id2">
<ul class="simple">
<li><p><a class="reference internal" href="#faq-how-can-i-wrap-a-function-which" id="id19">関数ポインタを引数にとる関数をラップするにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#faq-i-m-getting-the-attempt-to-retur" id="id20">「懸垂参照を返そうとしました」エラーが出る。何が間違っているのか</a></p></li>
<li><p><a class="reference internal" href="#return-internal-reference" id="id21">return_internal_reference の効率はどうか</a></p></li>
<li><p><a class="reference internal" href="#c" id="id22">C++ コンテナを引数にとる関数をラップするにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#c1204" id="id23">致命的なエラー C1204：コンパイラの制限 : 内部構造がオーバーフローしました。</a></p></li>
<li><p><a class="reference internal" href="#python" id="id24">Python 拡張をデバッグするにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#boost-build" id="id25">Boost.Build で拡張をデバッグする</a></p></li>
<li><p><a class="reference internal" href="#faq-why-doesn-t-my-operator-work" id="id26">私の <code class="code docutils literal notranslate"><span class="pre">*=</span></code> 演算子が動作しないのはなぜか</a></p></li>
<li><p><a class="reference internal" href="#boost-python-mac-os-x" id="id27">Boost.Python は Mac OS X で動作するか</a></p></li>
<li><p><a class="reference internal" href="#c-pyobject" id="id28">C++ オブジェクトを保持する既存の PyObject を探し出すにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#faq-how-can-i-wrap-a-function-which0" id="id29">生のポインタの所有権を持つ必要がある関数をラップするにはどうすればいいか</a></p></li>
<li><p><a class="reference internal" href="#faq-compilation-takes-too-much-time" id="id30">コンパイルに時間がかかりメモリも大量に消費する！高速化するにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#boost-python" id="id31">Boost.Python を使用してサブパッケージを作成するにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#error-c2064-2" id="id32">error C2064：2 引数を取り込む関数には評価されません</a></p></li>
<li><p><a class="reference internal" href="#faq-how-can-i-automatically-convert" id="id33">カスタム文字列型と Python 文字列を自動的に相互変換するにはどうすればよいか</a></p></li>
<li><p><a class="reference internal" href="#faq-why-is-my-automatic-to-python-co" id="id34">Python への自動変換器が見つからないのはなぜか</a></p></li>
<li><p><a class="reference internal" href="#faq-is-boost-python-thread-aware-com" id="id35">インタープリタが複数の場合 Boost.Python はスレッドに対して問題ないか</a></p></li>
</ul>
</div>
<div class="section" id="faq-how-can-i-wrap-a-function-which">
<span id="id3"></span><h2><a class="toc-backref" href="#id19">関数ポインタを引数にとる関数をラップするにはどうすればよいか</a><a class="headerlink" href="#faq-how-can-i-wrap-a-function-which" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>次のようにしたい場合は、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span> <span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">funcptr</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">funcptr</span> <span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fp</span><span class="p">(</span><span class="s">&quot;hello,world!&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">test</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="n">foo</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Python 側はこう。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span> <span class="n">s</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="go">hello, world!</span>
</pre></div>
</div>
<p>短い答えは「できない」だ。これは Boost.Python の制限ではなく C++ の制限による。問題は Python の関数は実際はデータであり、データと C++ 関数をひとまとめにするには関数の静的変数に格納する以外に方法がないということである。この話の問題は、一握りのデータをすべての関数とひとまとめすることしかできず、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">foo</span></code> へ渡すと決めた Python 関数についてその場で新しい C++ 関数をコンパイルする方法はないということである。言い換えると、C++ 関数が常に同じ Python 関数を呼び出すのであれば動作するが、おそらくあなたの希望ではないだろう。</p>
<p>ラップする C++ コードを変更することに糸目を付けなければ、代わりにそれを <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> へ渡し呼び出すとよい。多重定義された関数呼び出し演算子は、渡した先の <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> の背後にある Python 関数を呼び出す。</p>
<p>この問題についてより多くの考え方に触れるには、<a class="reference external" href="http://aspn.activestate.com/ASPN/Mail/Message/1554837">このポスト</a><a class="footnote-reference brackets" href="#id14" id="id5">1</a>を見よ。</p>
</div>
<div class="section" id="faq-i-m-getting-the-attempt-to-retur">
<span id="id6"></span><h2><a class="toc-backref" href="#id20">「懸垂参照を返そうとしました」エラーが出る。何が間違っているのか</a><a class="headerlink" href="#faq-i-m-getting-the-attempt-to-retur" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>厄介なクラッシュの発生を防ぐために発生している例外である。大抵は次のようなコードを書いたときに発生する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">period</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">get_floating_frequency</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">call_method</span><span class="o">&lt;</span><span class="n">period</span> <span class="k">const</span><span class="o">&amp;&gt;</span><span class="p">(</span>
      <span class="n">m_self</span><span class="p">,</span><span class="s">&quot;get_floating_frequency&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次のようなエラーが発生する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ReferenceError: Attempt to return dangling reference to object of type:</span>
<span class="go">class period</span>
</pre></div>
</div>
<p>この場合、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">call_method</span></code> が呼び出す Python のメソッドが新しい Python オブジェクトを構築する。その Python が所有し内包する C++ オブジェクト（<code class="xref cpp cpp-expr docutils literal notranslate"><em class="property"><span class="pre">class</span></em> <span class="pre">period</span></code> のインスタンス）への参照を返そうとしている。呼び出されるメソッドは短命な新しいオブジェクトを戻すため、それへの参照のみが上記の <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">get_floating_frequency</span><span class="pre">(</span><span class="pre">)</span></code> の存続期間で保持される。関数が返ると Python のオブジェクトが破壊されるため、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">period</span></code> クラスのインスタンスが破壊され、返った参照は懸垂したままとなる。もはや未定義の振る舞いであり、この参照で何かしようとするとクラッシュする。Boost.Python はこのような状況を実行時に検出し、クラッシュする前に例外を投げる。</p>
</div>
<div class="section" id="return-internal-reference">
<span id="faq-is-return-internal-reference-eff"></span><h2><a class="toc-backref" href="#id21">return_internal_reference の効率はどうか</a><a class="headerlink" href="#return-internal-reference" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>質問</p>
<p>12 個の <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">double</span></code> を持つオブジェクトがある。別のクラスのメンバ関数がこのオブジェクトへの <code class="code docutils literal notranslate"><span class="pre">const&amp;</span></code> を返す。返されるオブジェクトを Python で使用するという観点では、得られるのが戻り値のオブジェクトのコピーと参照のどちらであるかは気にしていない。Boost.Python のバージョン 2 で、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">copy_const_referece</span></code> か <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_internal_reference</span></code> のどちらを使用するか決めようと思う。生成されるコードのサイズやメモリオーバーヘッド等、どちらかを選択するのに決め手になるものはあるか。</p>
</div></blockquote>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">copy_const_reference</span></code> はオブジェクトに対しストレージを使用してインスタンスを作成し、そのサイズは base_size + 12 * sizeof(double) である。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_internal_reference</span></code> はオブジェクトへのポインタに対しストレージを使用してインスタンスを作成し、そのサイズは base_size + sizeof(void*) である。しかしながら、元のオブジェクトの弱参照リストに入る弱い参照オブジェクトと、内部で参照するオブジェクトの寿命を管理するための特別なコールバックオブジェクトも作成する。私の考えはどうかというと、この場合は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">copy_const_reference</span></code> がよいと思う。全メモリ使用量と断片化が減少し、トータルサイクルも削減することだろう。</p>
</div>
<div class="section" id="c">
<span id="faq-how-can-i-wrap-functions-which-t"></span><h2><a class="toc-backref" href="#id22">C++ コンテナを引数にとる関数をラップするにはどうすればよいか</a><a class="headerlink" href="#c" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Ralf W. Grosse-Kunstleve が次のようなノートを残している。</p>
<ol class="arabic">
<li><p>通常の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_&lt;&gt;</span></code> ラッパを使用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;std_vector_double&quot;</span><span class="p">)</span>
  <span class="p">.</span><span class="n">def</span><span class="p">(...)</span>
  <span class="p">...</span>
  <span class="p">;</span>
</pre></div>
</div>
<p>これをテンプレート内に持っていくと、様々な型を同じコードでラップできる。このテクニックは scitbx パッケージ内のファイル <code class="file docutils literal notranslate"><span class="pre">scitbx/include/scitbx/array_family/boost_python/flex_wrapper.h</span></code> で使用している。このファイルを <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> インスタンスをラップするよう変更するのは容易である。</p>
<p>この種の C++/Python の束縛は多数（10000 以上）の要素を持つコンテナに最も適している。</p>
</li>
<li><p>カスタムの rvalue 変換器を使用する。Boost.Python の「rvalue 変換器」は次のような関数シグニチャにマッチする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">array</span><span class="p">);</span> <span class="c1">// const 参照渡し</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">array</span><span class="p">);</span> <span class="c1">// 値渡し</span>
</pre></div>
</div>
<p>ファイル <code class="file docutils literal notranslate"><span class="pre">scitbx/include/scitbx/boost_python/container_conversions.h</span></code> にいくつか rvalue 変換器の実装がある。このコードを使えば、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> や <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::list&lt;&gt;</span></code> といった C++ コンテナ型から Python のタプルへの変換、あるいはその逆が可能である。ファイル <code class="file docutils literal notranslate"><span class="pre">scitbx/array_family/boost_python/regression_test_module.cpp</span></code> に簡単な例がある。</p>
<p>自動的な C++ コンテナ－ Python タプルの変換は、中サイズのコンテナに最も適している。これらの変換器が生成するオブジェクトコードは 1 番目の方法に比較して著しく小さい。</p>
</li>
</ol>
<p>2 番目の方法の欠点は <code class="code docutils literal notranslate"><span class="pre">+</span></code> 、<code class="code docutils literal notranslate"><span class="pre">-</span></code> 、<code class="code docutils literal notranslate"><span class="pre">*</span></code> 、<code class="code docutils literal notranslate"><span class="pre">/</span></code> 、<code class="code docutils literal notranslate"><span class="pre">%</span></code> といった算術演算子が利用できないことである。タプルの代わりに「<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">math_array</span></code>」型へ変換するカスタムの rvalue 変換器があると便利だろう。現時点では実装されていないが、数週間以内にリリースする Boost.Python V2 のフレームワークで可能になる（2002 年 3 月 10 日のポスト）。</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::vector&lt;&gt;</span></code> － Python リスト間の「カスタムの lvalue 変換器」もあると便利だろう。これらの変換器は C++ からの Python リストの変更をサポートする。例えば、</p>
<div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-text">C++ 側</span><a class="headerlink" href="#id15" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">array</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="p">;</span><span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>カスタムの lvalue 変換器については Boost.Python コアライブラリの変更が必要であり、現時点では利用できない。</p>
<p>追伸：上で触れた scitbx ファイル群は匿名 CVS で利用できる。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cvs -d:pserver:anonymous@cvs.cctbx.sourceforge.net:/cvsroot/cctbx login</span>
<span class="go">cvs -d:pserver:anonymous@cvs.cctbx.sourceforge.net:/cvsroot/cctbx co scitbx</span>
</pre></div>
</div>
</div>
<div class="section" id="c1204">
<span id="faq-fatal-error-c1204-compiler-limit"></span><h2><a class="toc-backref" href="#id23">致命的なエラー C1204：コンパイラの制限 : 内部構造がオーバーフローしました。</a><a class="headerlink" href="#c1204" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>大きなソースファイルをコンパイルすると、このエラーメッセージが出る。どうすればよいか。</p>
</div></blockquote>
<p>選択肢が 2 つある。</p>
<ol class="arabic simple">
<li><p>コンパイラをアップグレードする（推奨）。</p></li>
<li><p>ソースファイルを複数の翻訳単位に分割する。</p></li>
</ol>
<div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-text">my_module.cpp</span><a class="headerlink" href="#id16" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">void</span> <span class="n">more_of_my_module</span><span class="p">();</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">my_module</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>
   <span class="n">def</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">bar</span><span class="p">);</span>
   <span class="p">...</span>
   <span class="n">more_of_my_module</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-text">more_of_my_module.cpp</span><a class="headerlink" href="#id17" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">more_of_my_module</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">def</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">,</span> <span class="n">baz</span><span class="p">);</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="reference/class.html#_CPPv4I0000EN5boost6python6class_E" title="boost::python::class_"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_&lt;&gt;</span></code></a> 宣言を単一のソースファイルに押し込むことがエラーにより不可能な場合、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_</span></code> オブジェクトへの参照を他のソースファイルの関数へ渡して、その補助ソースファイル内でメンバ関数（<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">.def(...)</span></code> 等）を呼び出すとよい。</p>
<div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-text">more_of_my_class.cpp</span><a class="headerlink" href="#id18" title="このコードへのパーマリンク">¶</a></div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">more_of_my_class</span><span class="p">(</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">my_class</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">x</span>
     <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;baz&quot;</span><span class="p">,</span> <span class="n">baz</span><span class="p">)</span>
     <span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;xx&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">get_xx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_class</span><span class="o">::</span><span class="n">set_xx</span><span class="p">)</span>
     <span class="p">;</span>

   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="python">
<span id="faq-how-do-i-debug-my-python-extensi"></span><h2><a class="toc-backref" href="#id24">Python 拡張をデバッグするにはどうすればよいか</a><a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Greg Burley が Unix GCC ユーザに対して以下の回答をしている。</p>
<blockquote>
<div><p>C++ ライブラリかクラスについて Boost.Python 拡張を作成すると、コードのデバッグが必要になる。結局のところ、Python でライブラリをラップする理由の 1 つがこれだ。<abbr>BPL</abbr> を使用することで期待される副作用や利益は、Python のコードが最小限の状況で boost::python が動作しない場合（すなわち、ラップするメソッドが正しくないとエラーが出るが、そのほとんどはコンパイラが捕捉するだろう）でも、デバッグがテスト段階の C++ ライブラリに隔離できるということである。</p>
<p><strong class="program">gdb</strong> セッションを始めて Python による C++ ライブラリのデバッグを行うための基本的なステップを以下に示す。あなたの <abbr>BPL</abbr> モジュール <code class="file docutils literal notranslate"><span class="pre">my_ext.so</span></code> を含むディレクトリで <strong class="program">gdb</strong> セッションを開始しなければならないことに注意していただきたい。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">target exec python</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">run</span>
<span class="gp">&gt;</span>&gt;&gt; from my_ext import *
<span class="gp">&gt;</span>&gt;&gt; <span class="o">[</span>C-c<span class="o">]</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">break MyClass::MyBuggyFunction</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">cont</span>
<span class="gp">&gt;</span>&gt;&gt; <span class="nv">pyobj</span> <span class="o">=</span> MyClass<span class="o">()</span>
<span class="gp">&gt;</span>&gt;&gt; pyobj.MyBuggyFunction<span class="o">()</span>
<span class="go">Breakpoint 1, MyClass::MyBuggyFunction ...</span>
<span class="go">Current language:  auto; currently c++</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">do debugging stuff</span>
</pre></div>
</div>
</div></blockquote>
<p>Greg の方法はステップ実行したソースファイルの各行が表示されるので、Emacs の <strong class="program">gdb</strong> コマンドより優れたものである。</p>
<p><strong>Windows</strong> における私のお気に入りのデバッグツールは <strong class="program">Microsoft Visual C++ 7</strong> に付属のデバッガだ。このデバッガは、Microsoft および <strong class="program">Metrowerks</strong> ツールセットのすべてのバージョンが生成するコードで動作するようである。安定していて、ユーザが特別なトリックを使わなくても「とりあえず動作する」。</p>
<p>Raoul Gough は Windows 上の <strong class="program">gdb</strong> について以下を提供している。</p>
<blockquote>
<div><p>最近 <strong class="program">gdb</strong> の Windows DLL サポートが改善され、少しのトリックで Python 拡張をデバッグできるようになった。まず、DLL から最小限のシンボルを抽出する機能をサポートした最新の <strong class="program">gdb</strong> が必要である。バージョン 6 以降の <strong class="program">gdb</strong> か Cygwin gdb-20030214-1 以降が対応している。適切なリリースであれば <code class="file docutils literal notranslate"><span class="pre">gdb.info</span></code> ファイルに Configuration – Native – Cygwin Native – Non-debug DLL symbols 節がある。本稿で概略を示す方法について、この info 節に詳細がある。</p>
<p>次に、<kbd class="kbd docutils literal notranslate"><kbd class="kbd docutils literal notranslate"></kbd>^<kbd class="kbd docutils literal notranslate">C</kbd></kbd> で実行を中断するのではなく Python インタープリタ内にブレークポイントを設定する必要がある。ブレークポイントを設定する適切な場所は <code class="xref c c-func docutils literal notranslate"><span class="pre">PyOS_Readline</span></code> である。Python の対話コマンドを読み込む直前に毎回実行が停止する。デバッガが開始したらブレークポイントを設定可能になる前に Python を開始して自身の DLL を読み込まなければならない。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp">$</span> gdb python
<span class="go">GNU gdb 2003-09-02-cvs (cygwin-special)</span>
<span class="go">[...]</span>

<span class="gp gp-VirtualEnv">(gdb)</span>
<span class="go">Starting program: /cygdrive/c/Python22/python.exe</span>
<span class="go">Python 2.2.2 (#37, Oct 14 2002, 17:02:34) [MSC 32 bit (Intel)] on win32</span>
<span class="go">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span>
<span class="gp">&gt;</span>&gt;&gt; ^Z


<span class="go">Program exited normally.</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">break *&amp;PyOS_Readline</span>
<span class="go">Breakpoint 1 at 0x1e04eff0</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">run</span>
<span class="go">Starting program: /cygdrive/c/Python22/python.exe</span>
<span class="go">Python 2.2.2 (#37, Oct 14 2002, 17:02:34) [MSC 32 bit (Intel)] on win32</span>
<span class="go">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span>

<span class="go">Breakpoint 1, 0x1e04eff0 in python22!PyOS_Readline ()</span>
<span class="go">   from /cygdrive/c/WINNT/system32/python22.dll</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="go">cont</span>
<span class="go">Continuing.</span>
<span class="gp">&gt;</span>&gt;&gt; from my_ext import *

<span class="go">Breakpoint 1, 0x1e04eff0 in python22!PyOS_Readline ()</span>
<span class="go">   from /cygdrive/c/WINNT/system32/python22.dll</span>
<span class="gp gp-VirtualEnv">(gdb)</span> <span class="gp">#</span> my_ext now loaded <span class="o">(</span>with any debugging symbols it contains<span class="o">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="boost-build">
<span id="faq-how-do-i-debug-my-python-extensi-debugging-extensions-through-boo"></span><h2><a class="toc-backref" href="#id25">Boost.Build で拡張をデバッグする</a><a class="headerlink" href="#boost-build" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference external" href="http://www.boost.org/boost-build2/">Boost.Build</a> で boost-python-runtest 規則を使用して拡張モジュールのテストを起動する場合、<strong class="program">bjam</strong> コマンドラインに <code class="xref std std-option docutils literal notranslate"><span class="pre">--debugger=debugger</span></code> を追加して好きなデバッガを起動できる。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bjam -sTOOLS=vc7.1 &quot;--debugger=devenv /debugexe&quot; test</span>
<span class="go">bjam -sTOOLS=gcc -sPYTHON_LAUNCH=gdb test</span>
</pre></div>
</div>
<p>テストを走らせるときに <code class="xref std std-option docutils literal notranslate"><span class="pre">-d+2</span></code> オプションを追加すると、Boost.Build がテストを起動するのに使用する完全なコマンドを表示するので非常に便利である。このためには <code class="xref std std-envvar docutils literal notranslate"><span class="pre">PYTHONPATH</span></code> およびデバッガが正しく動作するのに必要な <span class="target" id="index-0"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> のような他の重要な環境関数がセットアップされていなければならない。</p>
</div>
<div class="section" id="faq-why-doesn-t-my-operator-work">
<span id="id8"></span><h2><a class="toc-backref" href="#id26">私の <code class="code docutils literal notranslate"><span class="pre">*=</span></code> 演算子が動作しないのはなぜか</a><a class="headerlink" href="#faq-why-doesn-t-my-operator-work" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>多数の多重定義演算子とともにクラスを Python へエクスポートした。他はちゃんと動作するのに、<code class="code docutils literal notranslate"><span class="pre">*=</span></code> 演算子だけが正しく動作しない。毎回「シーケンスは非 int 型と乗算できません」と言われる。<code class="code docutils literal notranslate"><span class="pre">p1</span> <span class="pre">*=</span> <span class="pre">p2</span></code> の代わりに <code class="code docutils literal notranslate"><span class="pre">p1.__imul__(p2)</span></code> とすると、コードの実行は成功する。私の何が間違っているのか。</p>
</div></blockquote>
<p>あなたは何も間違っていない。これは Python 2.2 のバグだ。Python 単体でも同じことが起こるはずである（Python 単体で新形式のクラスを使ってみると、Boost.Python 内で何が起こっているか理解できるだろう）。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">X</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span> <span class="s1">&#39;imul&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">*=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>この問題を解決するには Python をバージョン 2.2.1 以降へアップグレードする必要があり、他の方法はない。</p>
</div>
<div class="section" id="boost-python-mac-os-x">
<span id="faq-does-boost-python-work-with-mac"></span><h2><a class="toc-backref" href="#id27">Boost.Python は Mac OS X で動作するか</a><a class="headerlink" href="#boost-python-mac-os-x" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>10.2.8 および 10.3 では Apple の gcc 3.3 コンパイラで動作することが分かっている。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">gcc (GCC) 3.3 20030304 (Apple Computer, Inc. build 1493)</span>
</pre></div>
</div>
<p>10.2.8 の場合は gcc の 2003 年 8 月アップデートを入手する（<a class="reference external" href="http://connect.apple.com/">http://connect.apple.com/</a> で無償配布されている）。10.3 の場合は <strong class="program">Xcode Tools</strong> バージョン 1.0 を入手する（こちらも無償である）。</p>
<p>Python 2.3 が必要である。10.3 に付属の Python がよい。10.2.8 では次のコマンドを使用して Python をフレームワークとしてインストールする。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">./configure –enable-framework</span>
<span class="go">make</span>
<span class="go">make frameworkinstall</span>
</pre></div>
</div>
<p>ターゲットディレクトリが <code class="file docutils literal notranslate"><span class="pre">/Library/Frameworks/Python.framework/Versions/2.3</span></code> であるので、最後のコマンドは root 権限が必要である。しかしながら、このインストールは 10.2.8 に付属の Python バージョンと競合しない。</p>
<p>コンパイルの前に <code class="docutils literal notranslate"><span class="pre">stacksize</span></code> を増やしておくことも肝要である。例えば次のようにする。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">limit stacksize 8192k</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">stacksize</span></code> が小さいと内部コンパイラエラーが出てビルドがクラッシュする場合がある。</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">boost::python::class_&lt;your_type&gt;</span></code> テンプレートの実体化をコンパイル中に、たまに Apple のコンパイラが以下のようなエラーを印字（バグ）することがある。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">.../inheritance.hpp:44: error: cannot</span>
<span class="go"> dynamic_cast `p&#39; (of type `struct cctbx::boost_python::&lt;unnamed&gt;::add_pair*</span>
<span class="go">   &#39;) to type `void*&#39; (source type is not polymorphic)</span>
</pre></div>
</div>
<p>一般的な回避方法はないが、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">your_type</span></code> の定義を以下のように修正するとすべての場合で動作するようだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">your_type</span>
<span class="p">{</span>
  <span class="c1">// メンバデータを定義する前</span>
<span class="cp">#if defined(__MACH__) &amp;&amp; defined(__APPLE_CC__) &amp;&amp; __APPLE_CC__ == 1493</span>
  <span class="kt">bool</span> <span class="n">dummy_</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="c1">// 例えばここにメンバデータを置く</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
  <span class="c1">// 以下続く</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="c-pyobject">
<span id="faq-how-can-i-find-the-existing-pyob"></span><h2><a class="toc-backref" href="#id28">C++ オブジェクトを保持する既存の PyObject を探し出すにはどうすればよいか</a><a class="headerlink" href="#c-pyobject" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>「常に保持済みの C++ オブジェクトへのポインタを返す関数をラップしたい。」</p>
</div></blockquote>
<p>方法の 1 つとしては、仮想関数を持つクラスをラップするのに使用する機構をハイジャックすることである。コンストラクタで第 1 引数として <code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code> を取り、その <code class="xref c c-type docutils literal notranslate"><span class="pre">PyObject*</span></code> を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">self</span></code> として格納するラッパクラスを作成する場合、薄いラッパ関数内でラッパ型へダウンキャストして元に戻すことができる。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="n">X</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="k">virtual</span> <span class="o">~</span><span class="n">X</span><span class="p">();</span> <span class="p">...</span> <span class="p">};</span>
<span class="n">X</span><span class="o">*</span> <span class="nf">f</span><span class="p">();</span>  <span class="c1">// Python オブジェクトが管理するXを返す</span>


<span class="c1">// ラップのためのコード</span>

<span class="k">struct</span> <span class="nc">X_wrap</span> <span class="o">:</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="n">X_wrap</span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span> <span class="n">self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="o">:</span> <span class="n">self</span><span class="p">(</span><span class="n">self</span><span class="p">),</span> <span class="n">X</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">self</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">handle</span><span class="o">&lt;&gt;</span> <span class="n">f_wrap</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X_wrap</span><span class="o">*</span> <span class="n">xw</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">X_wrap</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">xw</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">handle</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">borrowed</span><span class="p">(</span><span class="n">xw</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">));</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f_wrap</span><span class="p">());</span>
<span class="n">class_</span><span class="o">&lt;</span><span class="n">X</span><span class="p">,</span><span class="n">X_wrap</span><span class="p">,</span><span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">())</span>
   <span class="p">...</span>
   <span class="p">;</span>
</pre></div>
</div>
<p>当然、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X</span></code> が仮想関数を持たない場合、<code class="code docutils literal notranslate"><span class="pre">dynamic_cast</span></code> の代わりに実行時チェックを行わない（行わなくてもよい）:code:<cite>static_cast</cite> を使用しなければならない。C++ から構築した <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">x</span></code> が <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X_wrap</span></code> オブジェクトとなることは当然ないため、この方法が動作するのは <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">x</span></code> オブジェクトが Python から構築された場合だけである。</p>
<p>別の方法では C++ コードをわずかに変更しなければならない（可能であればこちらのほうがよい）。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">shared_ptr&lt;X&gt;</span></code> が Python から変換されると、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">shared_ptr</span></code> は実際は内包する Python オブジェクトへの参照を管理する。逆に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">shared_ptr&lt;X&gt;</span></code> を Python へ変換すると、ライブラリはそれが「Python オブジェクト管理者」の 1 つであるかチェックし、そうであれば元の Python オブジェクトをそのまま返す。よって <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/object.html#_CPPv4N5boost6python6objectE" title="boost::python::object"><span class="pre">object</span></a><span class="pre">(</span><span class="pre">p</span><span class="pre">)</span></code> と書くだけで Python オブジェクトを戻すことができる。これを利用するには、ラップする C++ コードを生のポインタではなく <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">shared_ptr</span></code> で扱えるよう変更可能にしなければならない。</p>
<p>さらに別の方法もある。返したい Python オブジェクトを受け取る関数は、オブジェクトのアドレスと内包する Python オブジェクトの対応関係を記録する薄いラッパでラップでき、このマッピングから Python オブジェクトを捜索する <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f_wrap</span></code> 関数を用意しておくことができる。</p>
</div>
<div class="section" id="faq-how-can-i-wrap-a-function-which0">
<span id="id9"></span><h2><a class="toc-backref" href="#id29">生のポインタの所有権を持つ必要がある関数をラップするにはどうすればいいか</a><a class="headerlink" href="#faq-how-can-i-wrap-a-function-which0" title="このヘッドラインへのパーマリンク">¶</a></h2>
<blockquote>
<div><p>私がラップしている API の一部分は次のようなものである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">A</span> <span class="p">{};</span> <span class="k">struct</span> <span class="nc">B</span> <span class="p">{</span> <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span> <span class="n">A</span><span class="o">*</span> <span class="p">);</span> <span class="p">}</span>
<span class="c1">// B::add() は渡されたポインタの所有権を獲得する。</span>
</pre></div>
</div>
<p>しかしながら、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="n">A</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">mod</span><span class="p">.</span><span class="n">B</span><span class="p">()</span>
<span class="n">b</span><span class="p">.</span><span class="n">add</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span>
<span class="n">del</span> <span class="n">a</span>
<span class="n">del</span> <span class="n">b</span>
<span class="cp"># メモリの改変により</span>
<span class="cp"># Python インタープリタがクラッシュする。</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">with_custodian_and_ward</span></code> を使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a</span></code> の寿命を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">b</span></code> に束縛したとしても、結局のところポインタ先の Python オブジェクト <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a</span></code> が削除されるのを防ぐことはできない。ラップした C++ オブジェクトの「所有権を移動する」方法はあるか。</p>
<p class="attribution">—Bruce Lowery</p>
</div></blockquote>
<p>ある。C++ オブジェクトが <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">auto_ptr</span></code> に保持されるようにしておく。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>次に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">auto_ptr</span></code> 引数をとる薄いラッパ関数を作成する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">b_insert</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">auto_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">b</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="n">a</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">B.add</span></code> でラップする。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">manage_new_object</span></code> が返すポインタもまた <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">auto_ptr</span></code> で保持されているため、この所有権の移動が正しく動作することに注意していただきたい。</p>
</div>
<div class="section" id="faq-compilation-takes-too-much-time">
<span id="id10"></span><h2><a class="toc-backref" href="#id30">コンパイルに時間がかかりメモリも大量に消費する！高速化するにはどうすればよいか</a><a class="headerlink" href="#faq-compilation-takes-too-much-time" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>チュートリアルの<a class="reference internal" href="tutorial.html#tutorial-techniques-reducing-compiling-time"><span class="std std-ref">コンパイルにかかる時間を短縮する</span></a>の節を参照いただきたい。</p>
</div>
<div class="section" id="boost-python">
<span id="faq-how-do-i-create-sub-packages-usi"></span><h2><a class="toc-backref" href="#id31">Boost.Python を使用してサブパッケージを作成するにはどうすればよいか</a><a class="headerlink" href="#boost-python" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>チュートリアルの<a class="reference internal" href="tutorial.html#tutorial-techniques-creating-packages"><span class="std std-ref">パッケージを作成する</span></a>の節を参照いただきたい。</p>
</div>
<div class="section" id="error-c2064-2">
<span id="faq-error-c2064-term-does-not-evalua"></span><h2><a class="toc-backref" href="#id32">error C2064：2 引数を取り込む関数には評価されません</a><a class="headerlink" href="#error-c2064-2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Niall Douglas が次のノートを提供している。</p>
<blockquote>
<div><p><strong class="program">Microsoft Visual C++ 7.1（MS Visual Studio .NET 2003）</strong>で以下のようなエラーメッセージが出る場合、ほとんどはコンパイラのバグである。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">boost\boost\python\detail\invoke.hpp(76):</span>
<span class="go">error C2064: 2 引数を取り込む関数には評価されません&quot;</span>
</pre></div>
</div>
<p>このメッセージは以下のようなコードで引き起こされる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">FXThread</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">setAutoDelete</span><span class="p">(</span><span class="kt">bool</span> <span class="n">doso</span><span class="p">)</span> <span class="k">throw</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Export_FXThread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span> <span class="n">FXThread</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;FXThread&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;setAutoDelete&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">FXThread</span><span class="o">::</span><span class="n">setAutoDelete</span><span class="p">)</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このバグは <code class="code docutils literal notranslate"><span class="pre">throw()</span></code> 修飾子が原因である。回避方法は修飾子を取り除くことである。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;setAutoDelete&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">bool</span> <span class="p">(</span><span class="n">FXThread</span><span class="o">::*</span><span class="p">)(</span><span class="kt">bool</span><span class="p">))</span> <span class="o">&amp;</span><span class="n">FXThread</span><span class="o">::</span><span class="n">setAutoDelete</span><span class="p">)</span>
</pre></div>
</div>
<p>（このバグは Microsoft に報告済みである。）</p>
</div></blockquote>
</div>
<div class="section" id="faq-how-can-i-automatically-convert">
<span id="id11"></span><h2><a class="toc-backref" href="#id33">カスタム文字列型と Python 文字列を自動的に相互変換するにはどうすればよいか</a><a class="headerlink" href="#faq-how-can-i-automatically-convert" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Ralf W. Grosse-Kunstleve が次のノートを提供している。</p>
<blockquote>
<div><p>以下は、必要なものがすべて揃った小型の拡張モジュールのデモである。次のは対応する簡単なテストである。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">custom_string</span>
<span class="k">assert</span> <span class="n">custom_string</span><span class="o">.</span><span class="n">hello</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Hello world.&quot;</span>
<span class="k">assert</span> <span class="n">custom_string</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="s2">&quot;california&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>
</div>
<p>コードを見れば分かるが、</p>
<ul class="simple">
<li><p>カスタムの to_python 変換器（容易）：<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">custom_string_to_python_str</span></code></p></li>
<li><p>カスタムの lvalue 変換器（より多くのコードが必要）：<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">custom_string_from_python_str</span></code></p></li>
</ul>
<p>カスタム変換器は、モジュール初期化関数のトップ近傍のグローバルな Boost.Python レジストリに登録する。一度制御フローが登録コードに渡ると、同じプロセス内でインポートしたあらゆるモジュールで Python 文字列の自動的な相互変換が動作するようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python/module.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/python/def.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/python/to_python_converter.hpp&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">sandbox</span> <span class="p">{</span> <span class="k">namespace</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">custom_string</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">custom_string</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">custom_string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">value_</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">custom_string_to_python_str</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">PyObject</span><span class="o">*</span> <span class="n">convert</span><span class="p">(</span><span class="n">custom_string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">incref</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">object</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">()).</span><span class="n">ptr</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">custom_string_from_python_str</span>
<span class="p">{</span>
  <span class="n">custom_string_from_python_str</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">converter</span><span class="o">::</span><span class="n">registry</span><span class="o">::</span><span class="n">push_back</span><span class="p">(</span>
      <span class="o">&amp;</span><span class="n">convertible</span><span class="p">,</span>
      <span class="o">&amp;</span><span class="n">construct</span><span class="p">,</span>
      <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">type_id</span><span class="o">&lt;</span><span class="n">custom_string</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">convertible</span><span class="p">(</span><span class="n">PyObject</span><span class="o">*</span> <span class="n">obj_ptr</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyString_Check</span><span class="p">(</span><span class="n">obj_ptr</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">obj_ptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="n">construct</span><span class="p">(</span>
    <span class="n">PyObject</span><span class="o">*</span> <span class="n">obj_ptr</span><span class="p">,</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">converter</span><span class="o">::</span><span class="n">rvalue_from_python_stage1_data</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">value</span> <span class="o">=</span> <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">obj_ptr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">throw_error_already_set</span><span class="p">();</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">storage</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">converter</span><span class="o">::</span><span class="n">rvalue_from_python_storage</span><span class="o">&lt;</span><span class="n">custom_string</span><span class="o">&gt;*</span><span class="p">)</span>
        <span class="n">data</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">storage</span><span class="p">.</span><span class="n">bytes</span><span class="p">;</span>
    <span class="k">new</span> <span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="n">custom_string</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="n">data</span><span class="o">-&gt;</span><span class="n">convertible</span> <span class="o">=</span> <span class="n">storage</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="n">custom_string</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">custom_string</span><span class="p">(</span><span class="s">&quot;Hello world.&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">(</span><span class="n">custom_string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">init_module</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

  <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">to_python_converter</span><span class="o">&lt;</span>
    <span class="n">custom_string</span><span class="p">,</span>
    <span class="n">custom_string_to_python_str</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">custom_string_from_python_str</span><span class="p">();</span>

  <span class="n">def</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>
  <span class="n">def</span><span class="p">(</span><span class="s">&quot;size&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}}</span> <span class="c1">// namespace sandbox::&lt;anonymous&gt;</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">custom_string</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sandbox</span><span class="o">::</span><span class="n">init_module</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="faq-why-is-my-automatic-to-python-co">
<span id="id12"></span><h2><a class="toc-backref" href="#id34">Python への自動変換器が見つからないのはなぜか</a><a class="headerlink" href="#faq-why-is-my-automatic-to-python-co" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Niall Douglas が次のノートを提供している。</p>
<blockquote>
<div><p>上記のようなカスタム変換器を定義すると、メンバデータへの直接アクセスのために <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">boost::python::class_</span></code> が提供する <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def_readonly</span></code> および <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def_readwrite</span></code> メンバ関数は期待どおりに動作しない。これは <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">def_readonly</span><span class="pre">(</span><span class="pre">&quot;bar&quot;</span><span class="pre">,</span> <span class="pre">&amp;</span><span class="pre">foo</span><span class="pre">::</span><span class="pre">bar</span><span class="pre">)</span></code> が次と等価だからである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">make_getter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">return_internal_reference</span><span class="p">()))</span>
</pre></div>
</div>
<p>同様に <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">def_readwrite</span><span class="pre">(</span><span class="pre">&quot;bar&quot;</span><span class="pre">,</span> <span class="pre">&amp;</span><span class="pre">foo</span><span class="pre">::</span><span class="pre">bar</span><span class="pre">)</span></code> は次と等価である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">make_getter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">return_internal_reference</span><span class="p">()),</span>
                   <span class="n">make_setter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">return_internal_reference</span><span class="p">())</span>
</pre></div>
</div>
<p>戻り値のポリシーをカスタム変換に互換性のある形で定義するには、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def_readonly</span></code> および <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def_readwrite</span></code> を <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">add_property</span></code> で置き換える。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">make_getter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">return_value_policy</span><span class="o">&lt;</span><span class="n">return_by_value</span><span class="o">&gt;</span><span class="p">()),</span>
                   <span class="n">make_setter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">return_value_policy</span><span class="o">&lt;</span><span class="n">return_by_value</span><span class="o">&gt;</span><span class="p">()))</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="faq-is-boost-python-thread-aware-com">
<span id="id13"></span><h2><a class="toc-backref" href="#id35">インタープリタが複数の場合 Boost.Python はスレッドに対して問題ないか</a><a class="headerlink" href="#faq-is-boost-python-thread-aware-com" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Niall Douglas が次のノートを提供している。</p>
<blockquote>
<div><p>短い答え：ノー。</p>
<p>長い答え：解決するパッチは書けるが、困難である。Boost.Python を使用するあらゆるコード（特に仮想関数の多重定義部分）をカスタムのロック・アンロックで囲む必要があり、加えて <code class="file docutils literal notranslate"><span class="pre">boost/python/detail/invoke.hpp</span></code> を大幅に修正して Boost.Python があなたのコードを使用するあらゆる部分をカスタムのアンロック・ロックで囲む必要がある。さらに Boost.Python が <code class="file docutils literal notranslate"><span class="pre">invoke.hpp</span></code> によりイテレータ変更を起動するときにアンロック・ロックしないように注意しなければならない。</p>
<p>パッチを当てた <code class="file docutils literal notranslate"><span class="pre">invoke.hpp</span></code> は C++-SIG メーリングリストにポストされ、アーカイブになっている。機械的に必要な実際の全実装は TnFOX プロジェクト（<a class="reference external" href="http://sourceforge.net/projects/tnfox/">SourceForge</a> 内の場所）にある。</p>
</div></blockquote>
<dl class="footnote brackets">
<dt class="label" id="id14"><span class="brackets"><a class="fn-backref" href="#id5">1</a></span></dt>
<dd><p>訳注　ActiveState サイトへのリンクは移動してしまいました。<a class="reference external" href="http://code.activestate.com/lists/python-cplusplus-sig/">http://code.activestate.com/lists/python-cplusplus-sig/</a> 以下が移動先と思われますが、訳者には個々のメッセージの場所が分かりませんでした。</p>
</dd>
</dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="numpy/index.html" class="btn btn-neutral float-right" title="Boost.Python（NumPy）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="support.html" class="btn btn-neutral float-left" title="サポートリソース" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2020, exeal

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
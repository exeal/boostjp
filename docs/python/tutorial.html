

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>チュートリアル &mdash; Boost.Python（日本語訳）  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="ビルドとテスト" href="building.html" />
    <link rel="prev" title="リリースノート" href="release_notes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Boost.Python（日本語訳）
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">リリースノート</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">チュートリアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="building.html">ビルドとテスト</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">リファレンスマニュアル</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">設定に関する情報</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">用語</a></li>
<li class="toctree-l1"><a class="reference internal" href="support.html">サポートリソース</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">よくある質問と回答</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy/index.html">Boost.Python（NumPy）</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="platforms.html">動作を確認したプラットフォームとコンパイラ</a></li>
<li class="toctree-l1"><a class="reference internal" href="projects.html">Boost.Python を使用しているプロジェクト</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="internals.html">Boost.Python の裏側</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">新着情報・変更履歴</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">TODO リスト</a></li>
<li class="toctree-l1"><a class="reference internal" href="progress_reports.html">LLNL 進捗レポート</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">謝辞</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boost.Python（日本語訳）</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>チュートリアル</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>チュートリアル<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<blockquote class="pull-quote">
<div><div class="line-block">
<div class="line"><strong>Joel de Guzman</strong></div>
<div class="line"><strong>David Abrahams</strong></div>
<div class="line">© 2002-2005 Joel de Guzman, David Abrahams</div>
<div class="line">Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a class="reference external" href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a></div>
</div>
</div></blockquote>
<div class="contents local topic" id="id2">
<ul class="simple">
<li><p><a class="reference internal" href="#tutorial-quickstart" id="id48">クイックスタート</a></p>
<ul>
<li><p><a class="reference internal" href="#hello-world" id="id49">Hello World</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-hello" id="id50">Hello World のビルド</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-hello-from-start-to-finish" id="id51">始めから終わりまで</a></p></li>
<li><p><a class="reference internal" href="#jam" id="id52">Jam ろう！</a></p></li>
<li><p><a class="reference internal" href="#bjam" id="id53">bjam を起動する</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-exposing" id="id54">クラスのエクスポート</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-exposing-constructors" id="id55">コンストラクタ</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-class-data-members" id="id56">クラスデータメンバ</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-class-properties" id="id57">クラスプロパティ</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-inheritance" id="id58">継承</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-class-virtual-functions" id="id59">仮想関数</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-virtual-functions-with-default-implementations" id="id60">既定の実装をもった仮想関数</a></p></li>
<li><p><a class="reference internal" href="#tutorial-exposing-class-operators-special-functions" id="id61">演算子・特殊関数</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-functions" id="id62">関数</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-functions-call-policies" id="id63">呼び出しポリシー</a></p></li>
<li><p><a class="reference internal" href="#tutorial-functions-overloading" id="id64">多重定義</a></p></li>
<li><p><a class="reference internal" href="#tutorial-functions-default-arguments" id="id65">既定の引数</a></p></li>
<li><p><a class="reference internal" href="#tutorial-functions-auto-overloading" id="id66">自動多重定義</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-object" id="id67">オブジェクトのインターフェイス</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-object-basic-interface" id="id68">基本的なインターフェイス</a></p></li>
<li><p><a class="reference internal" href="#object" id="id69">object の派生型</a></p></li>
<li><p><a class="reference internal" href="#c" id="id70">C++ オブジェクトの抽出</a></p></li>
<li><p><a class="reference internal" href="#tutorial-object-enums" id="id71">列挙</a></p></li>
<li><p><a class="reference internal" href="#pyobject-boost-python-object" id="id72"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject*</span></code> から <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">boost::python::object</span></code> を作成する</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-embedding" id="id73">組み込み</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-embedding-building-embedded-programs" id="id74">組み込みプログラムをビルドする</a></p></li>
<li><p><a class="reference internal" href="#tutorial-embedding-getting-started" id="id75">はじめに</a></p></li>
<li><p><a class="reference internal" href="#tutorial-embedding-using-the-interpreter" id="id76">インタープリタを使用する</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-iterators" id="id77">イテレータ</a></p>
<ul>
<li><p><a class="reference internal" href="#range" id="id78">range</a></p></li>
<li><p><a class="reference internal" href="#iterator" id="id79">iterator</a></p></li>
<li><p><a class="reference internal" href="#stl-input-iterator" id="id80">stl_input_iterator</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#tutorial-exception" id="id81">例外の変換</a></p></li>
<li><p><a class="reference internal" href="#tutorial-techniques" id="id82">典型的なテクニック</a></p>
<ul>
<li><p><a class="reference internal" href="#tutorial-techniques-creating-packages" id="id83">パッケージを作成する</a></p></li>
<li><p><a class="reference internal" href="#tutorial-techniques-extending-wrapped-objects-in-python" id="id84">ラップしたオブジェクトを Python で拡張する</a></p></li>
<li><p><a class="reference internal" href="#tutorial-techniques-reducing-compiling-time" id="id85">コンパイルにかかる時間を短縮する</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="tutorial-quickstart">
<span id="id3"></span><h2><a class="toc-backref" href="#id48">クイックスタート</a><a class="headerlink" href="#tutorial-quickstart" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Boost.Python ライブラリは Python と C++ 間のインターフェイスのためのフレームワークである。C++ のクラス、関数、オブジェクトをすばやくシームレスに Python へエクスポートでき、また逆に Python から C++ へエクスポートできる。特別なツールは必要なく、あなたのコンパイラだけで可能だ。このライブラリは C++ インターフェイスを非侵入的にラップするよう設計されており、C++ コードを変更する必要は一切ない。このため、サードパーティ製ライブラリを Python へエクスポートするには Boost.Python が最適である。ライブラリは高度なメタプログラミング技術を使ってその構文を単純化しており、コードのラッピングは宣言的なインターフェイス定義言語（IDL）のような見た目になっている。</p>
<div class="section" id="hello-world">
<span id="tutorial-quickstart-hello-world"></span><h3><a class="toc-backref" href="#id49">Hello World</a><a class="headerlink" href="#hello-world" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C/C++ の伝統に従い「hello, world」から始めるとしよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">greet</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="s">&quot;hello, world&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この C++ 関数は、次の Boost.Python ラッパを書くことで Python へエクスポートできる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">hello_ext</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>
    <span class="n">def</span><span class="p">(</span><span class="s">&quot;greet&quot;</span><span class="p">,</span> <span class="n">greet</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これですべてである。あとはこれを共有ライブラリとしてビルドすると、生成した DLL が Python から可視となる。以下は Python のセッション例である。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hello_ext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">hello_ext</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="go">hello, world</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tutorial-hello">
<span id="id4"></span><h2><a class="toc-backref" href="#id50">Hello World のビルド</a><a class="headerlink" href="#tutorial-hello" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="tutorial-hello-from-start-to-finish">
<span id="id5"></span><h3><a class="toc-backref" href="#id51">始めから終わりまで</a><a class="headerlink" href="#tutorial-hello-from-start-to-finish" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>まず最初は Hello World モジュールをビルドして Python で使ってみることだろう。本節でそのためのステップを明らかにする。あらゆる Boost ディストリビューションに付属するビルドツールである <strong class="program">bjam</strong> を使用する。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p class="rubric"><strong class="program">bjam</strong> を使用せずにビルドする</p>
<p>当然 <strong class="program">bjam</strong> 以外にモジュールをビルドする方法はある。ここに書いていることが「唯一の方法」というわけではない。<strong class="program">bjam</strong> の他にビルドツールは存在する。</p>
<p>しかしながら Boost.Python のビルドには <strong class="program">bjam</strong> が適していると記しておく。セットアップを失敗させる方法はたくさんある。経験から言えば「Boost.Python がビルドできない」という問題の 9 割は、他のツールを使用することを余儀なくされた人から寄せられた。</p>
</div>
<p>細かいことは省略する。ここでの目的は Hello World モジュールを簡単に作成して Python で走らせることである。Boost.Python のビルドについて完全なリファレンスは「<a class="reference internal" href="building.html"><span class="doc">ビルドとテスト</span></a>」を見るとよい。この短いチュートリアルが終わったら DLL のビルドが完了して Python のプログラムで拡張が走っているはずである。</p>
<p>チュートリアルの例はディレクトリ <code class="file docutils literal notranslate"><span class="pre">/libs/python/example/tutorial</span></code> にある。以下のファイルがある。</p>
<ul class="simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">hello.cpp</span></code></p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">hello.py</span></code></p></li>
<li><p><code class="file docutils literal notranslate"><span class="pre">Jamroot</span></code></p></li>
</ul>
<p><code class="file docutils literal notranslate"><span class="pre">hello.cpp</span></code> ファイルは C++ の Hello World 例、<code class="file docutils literal notranslate"><span class="pre">Jamroot</span></code> は DLL をビルドする最小限の bjam スクリプトである。そして <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> は <code class="file docutils literal notranslate"><span class="pre">hello.cpp</span></code> の拡張を使用する Python プログラムである。</p>
<p>何よりもまず bjam の実行可能ファイルを boost ディレクトリか、<strong class="program">bjam</strong> をコマンドラインから実行できるパスに置いておく。ほとんどのプラットフォームでビルド済み Boost.Jam 実行可能ファイルが利用できる。bjam 実行可能ファイルの完全なリストが<a class="reference external" href="http://sourceforge.net/project/showfiles.php?group_id=7586">ここ</a>にある。</p>
</div>
<div class="section" id="jam">
<span id="tutorial-hello-let-s-jam"></span><h3><a class="toc-backref" href="#id52">Jam ろう！</a><a class="headerlink" href="#jam" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>最小限の Jamroot ファイルを <code class="file docutils literal notranslate"><span class="pre">/libs/python/example/tutorial/Jamroot</span></code> に置いておく。そのままファイルをコピーして <code class="code docutils literal notranslate"><span class="pre">use-project</span> <span class="pre">boost</span></code> の部分を Boost のルートディレクトリに設定すればよい。</p>
<p>必要なことはこの Jamroot ファイルのコメントに書いてある。</p>
</div>
<div class="section" id="bjam">
<span id="tutorial-hello-running-bjam"></span><h3><a class="toc-backref" href="#id53">bjam を起動する</a><a class="headerlink" href="#bjam" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>オペレーティングシステムのコマンドラインインタープリタから <strong class="program">bjam</strong> を起動する。</p>
<p>では、始めるとしよう。</p>
<p><code class="file docutils literal notranslate"><span class="pre">user-config.jam</span></code> という名前のファイルをホームディレクトリに置いてツールを調整する。Windows の場合、コマンドプロンプトウィンドウで次のようにタイプするとホームディレクトリがわかる。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">ECHO %HOMEDRIVE%%HOMEPATH%</span>
</pre></div>
</div>
<p>ファイルには少なくともコンパイラと Python のインストールについてのルールを書いておく必要がある。Windows の場合は例えば以下のとおり：</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>#  Microsoft Visual C++ の設定
using msvc : 8.0 ;

#  Python の設定
using python : 2.4 : C:/dev/tools/Python ;
</pre></div>
</div>
<p>1 番目のルールで MSVC 8.0 とその関連ツールを使用することを bjam に設定している。2 番目のルールは Python についての設定であり、Python のバージョンと場所を指定している。上の例では <code class="file docutils literal notranslate"><span class="pre">C:/dev/tools/Python</span></code> に Python をインストールした想定である。Python を正しく「標準的に」インストールした場合はこの設定は不要である。</p>
<p>ここまで来れば準備は整った。チュートリアルの <code class="file docutils literal notranslate"><span class="pre">hello.cpp</span></code> と <code class="file docutils literal notranslate"><span class="pre">Jamroot</span></code> が置いてある <code class="file docutils literal notranslate"><span class="pre">libs/python/example/tutorial</span></code> に <strong class="program">cd</strong> で移動するのを忘れないように。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">bjam</span>
</pre></div>
</div>
<p>これでビルドが始まり、</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">cd C:\dev\boost\libs\python\example\tutorial</span>
<span class="go">bjam</span>
<span class="go">...patience...</span>
<span class="go">...found 1101 targets...</span>
<span class="go">...updating 35 targets...</span>
</pre></div>
</div>
<p>最終的に例えば以下のように表示される。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Creating library path-to-boost_python.dll</span>
<span class="go">Creating library /path-to-hello_ext.exp/</span>
<span class="go">**passed** ... hello.test</span>
<span class="go">...updated 35 targets...</span>
</pre></div>
</div>
<p>すべて問題なければ、DLL がビルドされ Python のプログラムが走るはずである。</p>
<p>さあ、楽しんでいただきたい！</p>
</div>
</div>
<div class="section" id="tutorial-exposing">
<span id="id7"></span><h2><a class="toc-backref" href="#id54">クラスのエクスポート</a><a class="headerlink" href="#tutorial-exposing" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>では C++ クラスを Python へエクスポートしよう。</p>
<p>エクスポートすべき C++ クラス・構造体を考えよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">World</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">greet</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">msg</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>相当する Boost.Python ラッパを書いて Python へエクスポートできる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">World</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;greet&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">greet</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;set&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">set</span><span class="p">)</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記のようにメンバ関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">greet</span></code> および <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">set</span></code> をエクスポートする C++ クラスラッパを書いた。このモジュールを共有ライブラリとしてビルドすると、Python 側から <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">World</span></code> クラスが使用できるようになる。次に示すのは Python のセッション例である。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">hello</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">planet</span> <span class="o">=</span> <span class="n">hello</span><span class="o">.</span><span class="n">World</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">planet</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;howdy&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">planet</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="go">&#39;howdy&#39;</span>
</pre></div>
</div>
<div class="section" id="tutorial-exposing-constructors">
<span id="id8"></span><h3><a class="toc-backref" href="#id55">コンストラクタ</a><a class="headerlink" href="#tutorial-exposing-constructors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前回の例では明示的なコンストラクタが登場しなかった。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">World</span></code> はプレーンな構造体として宣言したので、暗黙のデフォルトコンストラクタとなっていた。Boost.Python は既定ではデフォルトコンストラクタをエクスポートするので、以下のように書けた。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">planet</span> <span class="o">=</span> <span class="n">hello</span><span class="o">.</span><span class="n">World</span><span class="p">()</span>
</pre></div>
</div>
<p>デフォルトでないコンストラクタを使ってクラスをラップしたい場合もあるだろう。前回の例をビルドする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">World</span>
<span class="p">{</span>
    <span class="n">World</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span><span class="o">:</span> <span class="n">msg</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// コンストラクタを追加した</span>
    <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">greet</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">msg</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これで <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">World</span></code> にデフォルトコンストラクタはなくなった。前回のラップコードは、ライブラリをエクスポートするところでコンパイルに失敗するだろう。代わりにエクスポートしたいコンストラクタについて <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_&lt;World&gt;</span></code> に通知しなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">World</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;greet&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">greet</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;set&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">set</span><span class="p">)</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">init&lt;std::string&gt;</span></code> が、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> を引数にとるコンストラクタをエクスポートする（Python ではコンストラクタを「<code class="code docutils literal notranslate"><span class="pre">&quot;__init__&quot;</span></code>」と書く）。</p>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def()</span> <span class="pre">メンバ関数に</span> <span class="pre">:cpp:class:</span></code>!init&lt;...&gt;` を渡すことでエクスポートするコンストラクタを追加できる。例えば <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">World</span></code> に <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">double</span></code> を 2 つとる別のコンストラクタがあるとすれば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">World</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;greet&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">greet</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;set&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">World</span><span class="o">::</span><span class="n">set</span><span class="p">)</span>
<span class="p">;</span>
</pre></div>
</div>
<p>逆にコンストラクタを 1 つもエクスポートしたくない場合は、代わりに <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">no_init</span></code> を使う。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Abstract</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Abstract&quot;</span><span class="p">,</span> <span class="n">no_init</span><span class="p">)</span>
</pre></div>
</div>
<p>これは実際には、常に Python の <code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code> 例外を投げる <code class="xref py py-func docutils literal notranslate"><span class="pre">__init__</span></code> メソッドを追加する。</p>
</div>
<div class="section" id="tutorial-exposing-class-data-members">
<span id="id9"></span><h3><a class="toc-backref" href="#id56">クラスデータメンバ</a><a class="headerlink" href="#tutorial-exposing-class-data-members" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>データメンバもまた Python へエクスポートでき、対応する Python クラスの属性としてアクセス可能になる。各データメンバは<strong>読み取り専用</strong>か<strong>読み書き可能</strong>として見なすことができる。以下の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Var</span></code> クラスを考えよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Var</span>
<span class="p">{</span>
    <span class="n">Var</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">)</span> <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">value</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>C++ クラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Var</span></code> とそのデータメンバは次のようにして Python へエクスポートできる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Var</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Var&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def_readonly</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Var</span><span class="o">::</span><span class="n">name</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def_readwrite</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Var</span><span class="o">::</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>これで Python 側で <code class="xref py py-mod docutils literal notranslate"><span class="pre">hello</span></code> 名前空間内に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Var</span></code> クラスがあるように扱うことができる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">hello</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="s1">&#39;pi&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.14</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;is around&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span>
<span class="go">pi is around 3.14</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">name</span></code> を<strong>読み取り専用</strong>としてエクスポートしたいっぽうで、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">value</span></code> は<strong>読み書き可能</strong>としてエクスポートしたことに注意していただきたい。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;e&#39;</span> <span class="c1"># name は変更できない</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
<span class="gr">AttributeError</span>: <span class="n">can&#39;t set attribute</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-exposing-class-properties">
<span id="id10"></span><h3><a class="toc-backref" href="#id57">クラスプロパティ</a><a class="headerlink" href="#tutorial-exposing-class-properties" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C++ では、公開データメンバを持つクラスは受け入れられない。カプセル化を利用して適切に設計されたクラスは、クラスのデータメンバを隠蔽しているものである。クラスのデータにアクセスする唯一の方法はアクセス関数（getter および setter）を介したものである。アクセス関数はクラスのプロパティをエクスポートする。以下がその例である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Num</span>
<span class="p">{</span>
    <span class="n">Num</span><span class="p">();</span>
    <span class="kt">float</span> <span class="nf">get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>しかしながら Python における属性アクセスは優れたものである。ユーザが属性を直接処理しても、必ずしもカプセル化が破壊されるわけではない。属性はメソッド呼び出しの別の構文だからである。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Num</span></code> クラスを Boost.Python を使ってラップすると次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Num</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Num&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;rovalue&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Num</span><span class="o">::</span><span class="n">get</span><span class="p">)</span>
    <span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Num</span><span class="o">::</span><span class="n">get</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Num</span><span class="o">::</span><span class="n">set</span><span class="p">);</span>
</pre></div>
</div>
<p>これで Python 側は以下のようになる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Num</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">3.14</span><span class="o">&lt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">rovalue</span>
<span class="go">(3.14, 3.14)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">rovalue</span> <span class="o">=</span> <span class="mf">2.17</span> <span class="c1"># エラー！</span>
</pre></div>
</div>
<p>以下のように <code class="xref py py-attr docutils literal notranslate"><span class="pre">rovalue</span></code> の setter メンバ関数を渡していないため、クラスのプロパティ <code class="xref py py-attr docutils literal notranslate"><span class="pre">rovalue</span></code> は読み取り専用としてエクスポートされることに注意していただきたい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&quot;rovalue&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Num</span><span class="o">::</span><span class="n">get</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-exposing-inheritance">
<span id="id11"></span><h3><a class="toc-backref" href="#id58">継承</a><a class="headerlink" href="#tutorial-exposing-inheritance" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これまでの例では多態的でないクラスを扱ってきたが、通常、そうしたことはあまりない。多くの場合、多態的なクラスや継承が絡んだクラス階層をラップすることになるだろう。仮想基底クラスから派生したクラスについて Boost.Python ラッパを書かなければならなくなるだろう。</p>
<p>次のような簡単な継承構造を考えよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">();</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{};</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> と <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> インスタンスを処理する C++ 関数群もあるとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">b</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">d</span><span class="p">(</span><span class="n">Derived</span><span class="o">*</span><span class="p">);</span>
<span class="n">Base</span><span class="o">*</span> <span class="nf">factory</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Derived</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>基底クラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> をラップする方法は以前見た。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Base&quot;</span><span class="p">)</span>
    <span class="cm">/*...*/</span>
    <span class="p">;</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> とその基底クラスである <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> の関係について Boost.Python に伝える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Derived</span><span class="p">,</span> <span class="n">bases</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Derived&quot;</span><span class="p">)</span>
    <span class="cm">/*...*/</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>これで自動的に以下の効果が得られる：</p>
<ol class="arabic simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> のすべての Python メソッド（ラップされた C++ メンバ関数）を自動的に継承する。</p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> が多態的<strong>ならば</strong>、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> へのポインタか参照で Python へ渡した <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> オブジェクトは、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> へのポインタか参照が期待されているところに渡すことができる。</p></li>
</ol>
<p>次に C++ 自由関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">b</span></code> 、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">d</span></code> および <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">factory</span></code> をエクスポートする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="n">def</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="n">def</span><span class="p">(</span><span class="s">&quot;factory&quot;</span><span class="p">,</span> <span class="n">factory</span><span class="p">);</span>
</pre></div>
</div>
<p>自由関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">factory</span></code> が、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Derived</span></code> クラスの新しいインスタンスを生成するために使われることに注意していただきたい。このような場合は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_value_policy&lt;manage_new_object&gt;</span></code> を使って、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> へのポインタを受け入れ、Python のオブジェクトが破壊されるまでインスタンスを新しい Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> オブジェクトに保持しておくことを Python に伝える。Boost.Python の<a class="reference internal" href="#tutorial-functions-call-policies"><span class="std std-ref">呼び出しポリシー</span></a>については後で詳しく述べる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// factory の結果について所有権を取るよう Python に伝える</span>
<span class="n">def</span><span class="p">(</span><span class="s">&quot;factory&quot;</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span>
    <span class="n">return_value_policy</span><span class="o">&lt;</span><span class="n">manage_new_object</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-exposing-class-virtual-functions">
<span id="id12"></span><h3><a class="toc-backref" href="#id59">仮想関数</a><a class="headerlink" href="#tutorial-exposing-class-virtual-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>本節では仮想関数を使って関数に多態的な振る舞いをさせる方法について学ぶ。前の例に引き続き、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> クラスに仮想関数を 1 つ追加しよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Boost.Python の目標の 1 つが、既存の C++ の設計に対して侵入を最小限にすることである。原則的にはサードパーティ製ライブラリに対して、インターフェイス部分を変更することなくエクスポート可能であるべきである。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> クラスに何かを追加するのは望ましいことではない。しかし Python 側でオーバーライドし <strong>C++ から</strong>多態的に呼び出す関数の場合、正しく動作させるのに足場が必要になる。Python のオーバーライドが呼び出されるように仮想関数に非侵入的にフックする、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> から派生したラッパクラスを書くことである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">BaseWrap</span> <span class="o">:</span> <span class="n">Base</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">get_override</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">)();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> の継承に加え、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrapper&lt;Base&gt;</span></code> を多重継承していることに注意していただきたい（<a class="reference internal" href="reference/wrapper.html#v2-wrapper-wrapper-spec"><span class="std std-ref">ラッパ</span></a>の節を見よ）。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">wrapper</span></code> テンプレートはラップするクラスを Python 側でオーバーライドできるようにする段取りを容易にする。</p>
<div class="admonition caution">
<p class="admonition-title">注意</p>
<p class="rubric">msvc6/7 におけるバグの回避方法</p>
<p>Microsoft Visual C++ のバージョン 6 か 7 を使っている場合、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> は次のように書かなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">call</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">get_override</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">).</span><span class="n">ptr</span><span class="p">());</span>
</pre></div>
</div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">BaseWrap</span></code> のオーバーライドされた仮想メンバ関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> は、実際には <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">get_override</span></code> を介して Python オブジェクトの相当するメソッドを呼び出す。</p>
<p>最後に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Base</span></code> をエクスポートする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">BaseWrap</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Base&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">pure_virtual</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">))</span>
    <span class="p">;</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">pure_virtual</span></code> は、関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> が純粋仮想関数であることを Boost.Python に伝える。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p class="rubric">メンバ関数とメソッド</p>
<p>Python をはじめ、多くのオブジェクト指向言語では<strong>メソッド（methods）</strong>という用語を使う。メソッドは大雑把に言えば C++ の<strong>メンバ関数（member functions）</strong>に相当する。</p>
</div>
</div>
<div class="section" id="tutorial-exposing-virtual-functions-with-default-implementations">
<span id="id13"></span><h3><a class="toc-backref" href="#id60">既定の実装をもった仮想関数</a><a class="headerlink" href="#tutorial-exposing-virtual-functions-with-default-implementations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前節で Boost.Python の<a class="reference internal" href="reference/wrapper.html#v2-wrapper-wrapper-spec"><span class="std std-ref">クラスラッパ</span></a>機能を用いて純粋仮想関数を持ったクラスをラップする方法を見てきた。<strong>非</strong>純粋仮想関数をラップする場合、方法は少し異なる。</p>
<p><a class="reference internal" href="#tutorial-exposing-class-virtual-functions"><span class="std std-ref">前節</span></a>を思い出そう。C++ で実装するか Python で派生クラスを作成する、純粋仮想関数を持ったクラスをラップした。基底クラスは次のように純粋仮想関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> を持っていた。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>しかしながら、仮にメンバ関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> が純粋仮想関数として宣言されていなかったら、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>以下のようにラップする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">BaseWrap</span> <span class="o">:</span> <span class="n">Base</span><span class="p">,</span> <span class="n">wrapper</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">override</span> <span class="n">f</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">get_override</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// ＊注意＊</span>
        <span class="k">return</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">default_f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">BaseWrap::f</span></code> の実装方法に注意していただきたい。この場合、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> のオーバーライドが存在するかチェックしなければならない。存在しなければ <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Base::f</span></code> を呼び出すとよい。</p>
<div class="admonition caution">
<p class="admonition-title">注意</p>
<p class="rubric">MSVC6/7 におけるバグの回避方法</p>
<p>Microsoft Visual C++ のバージョン 6 か 7 を使っている場合、＊注意＊と書いた行を次のように変更しなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">call</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">ptr</span><span class="p">());</span>
</pre></div>
</div>
</div>
<p>最後にエスクポートを行う。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">BaseWrap</span><span class="p">,</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Base&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BaseWrap</span><span class="o">::</span><span class="n">default_f</span><span class="p">)</span>
    <span class="p">;</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">&amp;Base::f</span></code> と <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">&amp;BaseWrap::default_f</span></code> の両方をスクスポートしていることに注意していただきたい。Boost.Python は（1）転送（dispatch）関数fと（2）既定の実装への転送（forwarding）関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">default_f</span></code> の追跡を維持しなければならない。この目的のための特別な <a class="reference internal" href="reference/def.html#_CPPv4I0EN5boost6python3defEvPKc2Fn" title="boost::python::def"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def</span></code></a> 関数が用意されている。</p>
<p>Python 側では結果的に次のようになる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">Base</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">derived</span> <span class="o">=</span> <span class="n">Derived</span><span class="p">()</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">base.f</span></code> を呼び出すと次のようになる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">base</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">derived.f</span></code> を呼び出すと次のようになる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">derived</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>
<span class="go">42</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-exposing-class-operators-special-functions">
<span id="id14"></span><h3><a class="toc-backref" href="#id61">演算子・特殊関数</a><a class="headerlink" href="#tutorial-exposing-class-operators-special-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="python">
<span id="tutorial-exposing-class-operators-special-functions-python-operators"></span><h4>Python の演算子<a class="headerlink" href="#python" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>C は演算子が豊富なことでよく知られている。C++ はこれを演算子の多重定義を認めることにより極限まで拡張した。Boost.Python はこれを利用して、演算子を多用した C++ クラスのラップを容易にする。</p>
<p>ファイルの位置を表すクラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FilePos</span></code> と、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FilePos</span></code> インスタンスをとる演算子群を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FilePos</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>

<span class="n">FilePos</span>     <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">FilePos</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">FilePos</span>     <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">FilePos</span><span class="p">);</span>
<span class="kt">int</span>         <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">FilePos</span><span class="p">,</span> <span class="n">FilePos</span><span class="p">);</span>
<span class="n">FilePos</span>     <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">FilePos</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">FilePos</span><span class="o">&amp;</span>    <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">FilePos</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="n">FilePos</span><span class="o">&amp;</span>    <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="n">FilePos</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">bool</span>        <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">FilePos</span><span class="p">,</span> <span class="n">FilePos</span><span class="p">);</span>
</pre></div>
</div>
<p>これらのクラスと演算子群は幾分簡単かつ直感的に Python へエクスポートできる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">FilePos</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;FilePos&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">+</span> <span class="kt">int</span><span class="p">())</span>          <span class="c1">// __add__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="kt">int</span><span class="p">()</span> <span class="o">+</span> <span class="n">self</span><span class="p">)</span>          <span class="c1">// __radd__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">-</span> <span class="n">self</span><span class="p">)</span>           <span class="c1">// __sub__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">-</span> <span class="kt">int</span><span class="p">())</span>          <span class="c1">// __sub__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">+=</span> <span class="kt">int</span><span class="p">())</span>         <span class="c1">// __iadd__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">-=</span> <span class="n">other</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">self</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">);</span>          <span class="c1">// __lt__</span>
</pre></div>
</div>
<p>上記のコード片は非常に明確であり、ほとんど説明不要である。演算子のシグニチャと実質同じである。&lt;constant&gt;self&lt;/constant&gt; が <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">FilePos</span></code> オブジェクトを表すということにのみ注意していただきたい。また、演算子式に現れるクラス <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">T</span></code> がすべて（容易に）デフォルトコンストラクト可能であるとは限らない。「self 式」を書くときに実際の <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">T</span></code> インスタンスの代わりに <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/operators.html#_CPPv4I0EN5boost6python5otherE" title="boost::python::other"><span class="pre">other</span></a><span class="pre">&lt;</span><span class="pre">T</span><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">)</span></code> が使える。</p>
</div>
<div class="section" id="tutorial-exposing-class-operators-special-functions-special-methods">
<span id="id15"></span><h4>特殊メソッド<a class="headerlink" href="#tutorial-exposing-class-operators-special-functions-special-methods" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Python には他にいくつか<strong>特殊メソッド</strong>がある。Boost.Python は、実際の Python クラスインスタンスがサポートする標準的な特殊メソッド名をすべてサポートする。直感的なインターフェイス群で、これらの Python <strong>特殊関数</strong>に相当する C++ 関数をラップできる。以下に例を示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span>
<span class="p">{</span> <span class="k">public</span><span class="o">:</span> <span class="k">operator</span> <span class="kt">double</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="p">};</span>

<span class="n">Rational</span> <span class="nf">pow</span><span class="p">(</span><span class="n">Rational</span><span class="p">,</span> <span class="n">Rational</span><span class="p">);</span>
<span class="n">Rational</span> <span class="nf">abs</span><span class="p">(</span><span class="n">Rational</span><span class="p">);</span>
<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span><span class="p">,</span><span class="n">Rational</span><span class="p">);</span>

<span class="n">class_</span><span class="o">&lt;</span><span class="n">Rational</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Rational&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">float_</span><span class="p">(</span><span class="n">self</span><span class="p">))</span>                  <span class="c1">// __float__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">other</span><span class="o">&lt;</span><span class="n">Rational</span><span class="o">&gt;</span><span class="p">))</span>    <span class="c1">// __pow__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">self</span><span class="p">))</span>                     <span class="c1">// __abs__</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">str</span><span class="p">(</span><span class="n">self</span><span class="p">))</span>                     <span class="c1">// __str__</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>他に言うことは？</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><a class="reference internal" href="reference/object.html#_CPPv4I00EN5boost6pythonlsE6objectRK1LRK1R" title="boost::python::operator&lt;&lt;"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code></a> の役割は？ メソッド <code class="xref py py-meth docutils literal notranslate"><span class="pre">str</span></code> が動作するために <a class="reference internal" href="reference/object.html#_CPPv4I00EN5boost6pythonlsE6objectRK1LRK1R" title="boost::python::operator&lt;&lt;"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code></a> が必要なのだ（<a class="reference internal" href="reference/object.html#_CPPv4I00EN5boost6pythonlsE6objectRK1LRK1R" title="boost::python::operator&lt;&lt;"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code></a> は <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/def.html#_CPPv4I0EN5boost6python3defEvPKc2Fn" title="boost::python::def"><span class="pre">def</span></a><span class="pre">(</span><a class="reference internal" href="reference/str.html#_CPPv4N5boost6python3strE" title="boost::python::str"><span class="pre">str</span></a><span class="pre">(</span><a class="reference internal" href="reference/operators.html#_CPPv4N5boost6python4selfE" title="boost::python::self"><span class="pre">self</span></a><span class="pre">)</span><span class="pre">)</span></code> が定義するメソッドが使用する）。</p>
</div>
</div>
</div>
</div>
<div class="section" id="tutorial-functions">
<span id="id16"></span><h2><a class="toc-backref" href="#id62">関数</a><a class="headerlink" href="#tutorial-functions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>本章では、Boost.Python の強力な関数について詳細を見る。懸垂ポインタや懸垂参照のような潜在的な落とし穴を避けつつ、C++ 関数を Python へエクスポートするための機能について見ていく。また、多重定義や既定の引数といった C++ 機能を利用した C++ 関数のエクスポートを容易にする機能についても見ていく。</p>
<p>先を続けよう。</p>
<p>しかしその前に Python 2.2 以降を立ち上げて <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;&gt;</span> <span class="pre">import</span> <span class="pre">this</span></code> とタイプしたくなるかもしれない。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">this</span>
<span class="go">The Zen of Python, by Tim Peters</span>
<span class="go">Beautiful is better than ugly.</span>
<span class="go">Explicit is better than implicit.</span>
<span class="go">Simple is better than complex.</span>
<span class="go">Complex is better than complicated.</span>
<span class="go">Flat is better than nested.</span>
<span class="go">Sparse is better than dense.</span>
<span class="go">Readability counts.</span>
<span class="go">Special cases aren&#39;t special enough to break the rules.</span>
<span class="go">Although practicality beats purity.</span>
<span class="go">Errors should never pass silently.</span>
<span class="go">Unless explicitly silenced.</span>
<span class="go">In the face of ambiguity, refuse the temptation to guess.</span>
<span class="go">There should be one-- and preferably only one --obvious way to do it.</span>
<span class="go">Although that way may not be obvious at first unless you&#39;re Dutch.</span>
<span class="go">Now is better than never.</span>
<span class="go">Although never is often better than *right* now.</span>
<span class="go">If the implementation is hard to explain, it&#39;s a bad idea.</span>
<span class="go">If the implementation is easy to explain, it may be a good idea.</span>
<span class="go">Namespaces are one honking great idea -- let&#39;s do more of those!</span>
</pre></div>
</div>
<div class="section" id="tutorial-functions-call-policies">
<span id="id17"></span><h3><a class="toc-backref" href="#id63">呼び出しポリシー</a><a class="headerlink" href="#tutorial-functions-call-policies" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>C++ では引数や戻り値の型としてポインタや参照を扱うことがよくある。これら単純型は非常に低水準であり表現力に乏しい。少なくとも、ポインタや参照先のオブジェクトの所有権がどこにあるか知る方法はない。もっとも、Java や Python といった言語ではそのような低水準な実体を扱うことはない。C++ では、所有権のセマンティクスを正確に記述するスマートポインタの使用をよい慣習であると考えることが多い。それでも生の参照やポインタを使う C++ インターフェイスがよいとされる場合もあり、Boost.Python がそれらに対処できなければならない。このためには、あなたの助けが必要である。次のような C++ 関数を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="o">&amp;</span> <span class="nf">f</span><span class="p">(</span><span class="n">Y</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="n">Z</span><span class="o">*</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>ライブラリはこの関数をどのようにラップすべきだろうか？ 単純なアプローチとしては、返される参照について Python の <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X</span></code> オブジェクトを構築することである。この解法は動作する場合もあるが、動作しないこともある。以下が後者の例である。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="c1"># x は C++ の X を参照する</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">some_method</span><span class="p">()</span> <span class="c1"># クラッシュ！</span>
</pre></div>
</div>
<p>何が起きたのか？</p>
<p>実は <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> が次のように実装されていたのだった。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="o">&amp;</span> <span class="nf">f</span><span class="p">(</span><span class="n">Y</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="n">Z</span><span class="o">*</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>問題は、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> がオブジェクト <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> のメンバへの参照を返すため、結果の <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X&amp;</span></code> の寿命が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> の寿命に縛られることである。このイディオムは珍しいものではなく、C++ の文脈では完全に受け入れられるものである。しかしながら Python のユーザとしてはこの C++ インターフェイスを使用するだけでシステムをクラッシュさせるわけにはいかない。今回の場合、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> を削除した段階で <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X</span></code> への参照が無効となり、懸垂参照が残るのである。</p>
<p>以下のようなことが起こっている。</p>
<ol class="arabic simple">
<li><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> への参照と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">z</span></code> へのポインタを渡して <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> が呼び出される</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">y</span><span class="pre">.</span><span class="pre">x</span></code> への参照が返される</p></li>
<li><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> が削除される。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">x</span></code> は懸垂参照となる</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">x</span><span class="pre">.</span><span class="pre">some_method</span><span class="pre">(</span><span class="pre">)</span></code> が呼び出される</p></li>
<li><p><strong>バン！</strong></p></li>
</ol>
<p>結果を新しいオブジェクトにコピーしてみる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="c1"># 結果を消失</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>       <span class="c1"># クラッシュしないが、改善の余地がある</span>
<span class="go">3.14</span>
</pre></div>
</div>
<p>これは今回の C++ インターフェイスで本当に実現したかったことではない。Python インターフェイスが可能な限り綿密に C++ インターフェイスを反映すべきであるという約束を破っている。</p>
<p>問題はこれで終わりではない。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Y</span></code> の実装が次のようになっているとしたら、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Y</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">x</span><span class="p">;</span> <span class="n">Z</span><span class="o">*</span> <span class="n">z</span><span class="p">;</span>
    <span class="kt">int</span> <span class="nf">z_value</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>データメンバ <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">z</span></code> がクラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Y</span></code> に生のポインタで保持されていることに注意していただきたい。潜在的な懸垂ポインタの問題が <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Y</span></code> の内部で発生している。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="c1"># y は z を参照する</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">z</span>       <span class="c1"># オブジェクト z を削除</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">z_value</span><span class="p">()</span> <span class="c1"># クラッシュ！</span>
</pre></div>
</div>
<p>参考のために <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> の実装を再掲する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="o">&amp;</span> <span class="nf">f</span><span class="p">(</span><span class="n">Y</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">,</span> <span class="n">Z</span><span class="o">*</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">y</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下のようなことが起こっている。</p>
<ol class="arabic simple">
<li><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> への参照と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">z</span></code> へのポインタを渡して <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> が呼び出される</p></li>
<li><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">y</span></code> が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">z</span></code> へのポインタを保持する</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">y</span><span class="pre">.</span><span class="pre">x</span></code> への参照が返される</p></li>
<li><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">z</span></code> が削除される。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">y</span><span class="pre">.</span><span class="pre">z</span></code> は懸垂ポインタとなる</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">y</span><span class="pre">.</span><span class="pre">z_value</span><span class="pre">(</span><span class="pre">)</span></code> が呼び出される</p></li>
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">z</span><span class="pre">-&gt;</span><span class="pre">value</span><span class="pre">(</span><span class="pre">)</span></code> が呼び出される</p></li>
<li><p><strong>バン！</strong></p></li>
</ol>
<div class="section" id="tutorial-functions-call-policies-call-policies">
<span id="id18"></span><h4>呼び出しポリシー<a class="headerlink" href="#tutorial-functions-call-policies-call-policies" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>上で扱った例のような状況では、呼び出しポリシーが使える。今回の例では <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_internal_reference</span></code> と <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">with_custodian_and_ward</span></code> が助けになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
    <span class="n">return_internal_reference</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">with_custodian_and_ward</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<p>引数の <code class="docutils literal notranslate"><span class="pre">1</span></code> とか <code class="docutils literal notranslate"><span class="pre">2</span></code> って何だい？</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">return_internal_reference</span><span class="o">&lt;</span><span class="mi">1</span>
</pre></div>
</div>
<p>これは「1 番目の引数（<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">Y</span> <span class="pre">&amp;</span> <span class="pre">y</span></code>）が、返される参照（<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X&amp;</span></code>）の所有者である」と Boost.Python に伝えている。「1」は単に 1 番目の引数という意味である。まとめると「第 1 引数 <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">Y</span> <span class="pre">&amp;</span> <span class="pre">y</span></code> が所有する内部参照 <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X&amp;</span></code> を返す」となる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">with_custodian_and_ward</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>これは「ward（被後見人）で指定した引数（第 2 引数。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">Z</span> <span class="pre">*</span> <span class="pre">z</span></code>）の寿命が、custodian（後見人）で指定した引数（第 1 引数。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">Y</span> <span class="pre">&amp;</span> <span class="pre">y</span></code>）の寿命に依存する」と Boost.Python に伝えている。</p>
<p>上で 2 つのポリシーを定義していることに注意していただきたい。2 つ以上のポリシーは数珠繋ぎに結合できる。汎用的な構文は以下のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">policy1</span><span class="o">&lt;</span><span class="n">args</span><span class="p">...,</span>
    <span class="n">policy2</span><span class="o">&lt;</span><span class="n">args</span><span class="p">...,</span>
        <span class="n">policy3</span><span class="o">&lt;</span><span class="n">args</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
</pre></div>
</div>
<p>定義済みの呼び出しポリシーを以下のリストに挙げる。完全なリファレンスは<a class="reference internal" href="reference/functions.html#function-invocation-and-creation-models-of-callpolicies"><span class="std std-ref">ここ</span></a>にある。</p>
<dl class="simple">
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">with_custodian_and_ward</span></code></dt><dd><p>引数の寿命を他の引数で縛る</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">with_custodian_and_ward_postcall</span></code></dt><dd><p>引数の寿命を他の引数や返り値で縛る</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_internal_reference</span></code></dt><dd><p>1 つの引数の寿命を返り値の寿命で縛る</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">return_value_policy&lt;T&gt;</span></code>（<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">T</span></code> は以下のいずれか）</dt><dd><dl class="simple">
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">reference_existing_object</span></code></dt><dd><p>単純（で危険）なアプローチ</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">copy_const_reference</span></code></dt><dd><p>Boost.Python v1 のアプローチ</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">copy_non_const_reference</span></code></dt><dd><p>…</p>
</dd>
<dt><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">manage_new_object</span></code></dt><dd><p>ポインタを受け取りインスタンスを保持する</p>
</dd>
</dl>
</dd>
</dl>
<p>禅（Zen）を思い出そう、Luke <a class="footnote-reference brackets" href="#id46" id="id19">1</a>：</p>
<p>「ごちゃごちゃ難しいのより、白黒はっきりしてるのがいい」</p>
<p>「あいまいなことをてきとーに処理しちゃいけません」</p>
</div>
</div>
<div class="section" id="tutorial-functions-overloading">
<span id="id20"></span><h3><a class="toc-backref" href="#id64">多重定義</a><a class="headerlink" href="#tutorial-functions-overloading" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>多重定義したメンバ関数を手動でラップする方法を以下に示す。非メンバ関数の多重定義をラップする場合も、当然同様のテクニックが使える。</p>
<p>次のような C++ クラスを考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>クラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X</span></code> に多重定義された関数が 4 つある。まずメンバ関数ポインタ変数を導入するところから始める。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span>    <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx1</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span>              <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
<span class="kt">bool</span>    <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">)</span>      <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
<span class="kt">bool</span>    <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx3</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">char</span><span class="p">)</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
<span class="kt">int</span>     <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx4</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
</pre></div>
</div>
<p>これがあれば、続けて Python のために定義とラップができる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx1</span><span class="p">)</span>
<span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx2</span><span class="p">)</span>
<span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx3</span><span class="p">)</span>
<span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-functions-default-arguments">
<span id="id21"></span><h3><a class="toc-backref" href="#id65">既定の引数</a><a class="headerlink" href="#tutorial-functions-default-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Boost.Python は（メンバ）関数ポインタをラップするが、残念ながら C++ 関数ポインタは既定の引数について情報を持たない。既定の引数を持った関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>しかし関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> へのポインタ型は、その既定の引数について情報を持たない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span><span class="kt">double</span><span class="p">,</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>    <span class="c1">// 既定の引数が失われる！</span>
</pre></div>
</div>
<p>この関数ポインタを <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def</span></code> 関数へ渡すとしても、既定の引数を取得する方法はない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>                            <span class="c1">// 既定の引数が失われる！</span>
</pre></div>
</div>
<p>このため C++ ラップコードを書くときは、<a class="reference internal" href="#tutorial-functions-overloading"><span class="std std-ref">前節</span></a>で示したような手動のラップか薄いラッパを書くことに頼るしかない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 「薄いラッパ」を書く</span>
<span class="kt">int</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">);</span> <span class="p">}</span>

<span class="cm">/*...*/</span>

    <span class="c1">// init モジュール内</span>
    <span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>  <span class="c1">// 3 引数バージョン</span>
    <span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f2</span><span class="p">);</span> <span class="c1">// 2 引数バージョン</span>
    <span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">f1</span><span class="p">);</span> <span class="c1">// 1 引数バージョン</span>
</pre></div>
</div>
<p>以下のいずれかの関数（、メンバ関数）をラップするときは、次節に進むとよい。</p>
<ul class="simple">
<li><p>既定の引数を持つ</p></li>
<li><p>引数の先頭部分に共通列を持つ形で多重定義されている</p></li>
</ul>
<div class="section" id="boost-python-function-overloads">
<span id="tutorial-functions-default-arguments-boost-python-function-overloads"></span><h4>BOOST_PYTHON_FUNCTION_OVERLOADS<a class="headerlink" href="#boost-python-function-overloads" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Boost.Python はこれを容易にする方法を提供する。例えば次の関数が与えられたとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>次のマクロ呼び出しにより、薄いラッパが作成される。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BOOST_PYTHON_FUNCTION_OVERLOADS</span><span class="p">(</span><span class="n">foo_overloads</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>このマクロは、<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/def.html#_CPPv4I0EN5boost6python3defEvPKc2Fn" title="boost::python::def"><span class="pre">def</span></a><span class="sig-paren">(</span><span class="pre">...</span><span class="sig-paren">)</span></code> に渡すことができる <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">foo_overloads</span></code> クラスを作成する。このマクロの 3 番目と 4 番目の引数は、それぞれ引数の最小数と最大数である。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">foo</span></code> 関数では引数の最小数は 1 、最大数は 4 である。<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/def.html#_CPPv4I0EN5boost6python3defEvPKc2Fn" title="boost::python::def"><span class="pre">def</span></a><span class="sig-paren">(</span><span class="pre">...</span><span class="sig-paren">)</span></code> 関数は <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">foo</span></code> のファミリをすべて自動的に追加する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="n">foo_overloads</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="boost-python-member-function-overloads">
<span id="tutorial-functions-default-arguments-boost-python-member-function-overloads"></span><h4>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS<a class="headerlink" href="#boost-python-member-function-overloads" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>オブジェクトはここにも、そこにも、あそこにも、どこにでもある。Python にエクスポートするのは、クラスのメンバ関数が最も頻度が高い。ここでまた、以前の既定の引数や引数の先頭部分が共通列である多重定義の場合の不便が出てくる。これを容易にするマクロが提供されている。</p>
<p><a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_FUNCTION_OVERLOADS" title="BOOST_PYTHON_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_FUNCTION_OVERLOADS</span></code></a> と同様、メンバ関数をラップする薄いラッパを自動的に作成するのに <a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS" title="BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span></code></a> を使用する。例を挙げる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">george</span>
<span class="p">{</span>
    <span class="kt">void</span>
    <span class="nf">wack_em</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/*...*/</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ここで次のようにマクロを呼び出すと、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span><span class="p">(</span><span class="n">george_overloads</span><span class="p">,</span> <span class="n">wack_em</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">george</span></code> の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">wack_em</span></code> メンバ関数について最少で 1 、最多で 3（マクロの 3 番目と 4 番目の引数）の薄いラッパ群を生成する。薄いラッパはすべて <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">george_overloads</span></code> という名前のクラスに収められ、<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/def.html#_CPPv4I0EN5boost6python3defEvPKc2Fn" title="boost::python::def"><span class="pre">def</span></a><span class="sig-paren">(</span><span class="pre">...</span><span class="sig-paren">)</span></code> に引数として渡すことができる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;wack_em&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">george</span><span class="o">::</span><span class="n">wack_em</span><span class="p">,</span> <span class="n">george_overloads</span><span class="p">());</span>
</pre></div>
</div>
<p>詳細は<a class="reference internal" href="reference/overloads.html#v2-overloads-macros"><span class="std std-ref">多重定義のリファレンス</span></a>を見よ。</p>
</div>
<div class="section" id="init-optional">
<span id="tutorial-functions-default-arguments-init-and-optional"></span><h4>init と optional<a class="headerlink" href="#init-optional" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>クラスのコンストラクタ、特に既定の引数と多重定義については類似の機能が提供されている。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">init&lt;...&gt;</span></code> を覚えているだろうか？ 例えばクラス <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X</span></code> とそのコンストラクタがあるとすると、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="n">b</span> <span class="o">=</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">c</span> <span class="o">=</span> <span class="s">&quot;constructor&quot;</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このコンストラクタを一発で Boost.Python に追加するには、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">optional</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">init&lt;...&gt;</span></code> と <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">optional&lt;...&gt;</span></code> の使うことで、既定（省略可能な引数）であることを表現している点に注意していただきたい。</p>
</div>
</div>
<div class="section" id="tutorial-functions-auto-overloading">
<span id="id22"></span><h3><a class="toc-backref" href="#id66">自動多重定義</a><a class="headerlink" href="#tutorial-functions-auto-overloading" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>前節で <a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_FUNCTION_OVERLOADS" title="BOOST_PYTHON_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_FUNCTION_OVERLOADS</span></code></a> および <a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS" title="BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span></code></a> が、引数列の先頭部分が共通である多重定義関数およびメンバ関数に対しても使用できることを見た。以下に例を示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
   <span class="cm">/*...*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">bool</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/*...*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">bool</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/*...*/</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">bool</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前節と同様、これらの多重定義された関数について薄いラッパを一発で生成できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BOOST_PYTHON_FUNCTION_OVERLOADS</span><span class="p">(</span><span class="n">foo_overloads</span><span class="p">,</span> <span class="n">foo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>その結果、次のように書ける。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="p">))</span><span class="mi">0</span><span class="p">,</span> <span class="n">foo_overloads</span><span class="p">());</span>
</pre></div>
</div>
<p>この例では引数の個数は最少で 0 、最多で 3 となっていることに注意していただきたい。</p>
<div class="section" id="tutorial-functions-auto-overloading-manual-wrapping">
<span id="id23"></span><h4>手動のラッピング<a class="headerlink" href="#tutorial-functions-auto-overloading-manual-wrapping" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><strong>多重定義した関数は引数列の先頭に共通部分を持っていなければならない</strong>ということを強調しておく。それ以外の場合、上で述べた方法は動作せず、関数を<a class="reference internal" href="#tutorial-functions-overloading"><span class="std std-ref">手動で</span></a>ラップしなければならない。</p>
<p>実際には多重定義関数の手動ラッピングと、<a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS" title="BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span></code></a> とその姉妹版である <a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_FUNCTION_OVERLOADS" title="BOOST_PYTHON_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_FUNCTION_OVERLOADS</span></code></a> による自動的なラッピングを混用することは可能である。<a class="reference internal" href="#tutorial-functions-overloading"><span class="std std-ref">多重定義</span></a>の節で見た例だと 4 つの多重定義関数は引数の先頭列が共通であるので、<a class="reference internal" href="reference/overloads.html#c.BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS" title="BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS"><code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span></code></a> を使って最初の 3 つの <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">def</span></code> を自動的にラップでき、残り 1 つだけを手動でラップすることになる。以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</span><span class="p">(</span><span class="n">xf_overloads</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>両方の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">X::f</span></code> 多重定義について、以前と同様にメンバ関数ポインタを作成すると、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span>    <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx1</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">char</span><span class="p">)</span>    <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
<span class="kt">int</span>     <span class="p">(</span><span class="n">X</span><span class="o">::*</span><span class="n">fx2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span>        <span class="o">=</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">f</span><span class="p">;</span>
</pre></div>
</div>
<p>結果、以下のように書ける。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx1</span><span class="p">,</span> <span class="n">xf_overloads</span><span class="p">());</span>
<span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="n">fx2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="tutorial-object">
<span id="id24"></span><h2><a class="toc-backref" href="#id67">オブジェクトのインターフェイス</a><a class="headerlink" href="#tutorial-object" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ が静的型付けであるのに対し、Python は動的型付けである。Python の変数は整数、浮動小数点数、リスト、辞書、タプル、文字列、長整数、その他を保持できる。Boost.Python と C++ の視点では、これら Python 的な変数は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> クラスのインスタンスにすぎない。本章で Python のオブジェクトをどのように扱うか見ていく。</p>
<p>以前述べたように Boost.Python の目的の 1 つは、C++ と Python 間における Python 的な感覚の双方向マッピングの提供である。Boost.Python における C++ の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> は可能な限り Python に類似したものとなっている。これにより学習曲線は著しく最小化されるはずである。</p>
<div class="section" id="tutorial-object-basic-interface">
<span id="id25"></span><h3><a class="toc-backref" href="#id68">基本的なインターフェイス</a><a class="headerlink" href="#tutorial-object-basic-interface" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> クラスは <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject*</span></code> をラップする。参照カウントの管理といった <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject</span></code> の複雑な取り扱いは、すべて <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> クラスが処理する。C++ オブジェクトの相互運用性はシームレスなものである。実際のところ、Boost.Python における C++ の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> はあらゆる C++ オブジェクトから明示的に構築できる。</p>
<p>説明のために、以下のような Python コード片を考える。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="s1">&#39;foo&#39;</span><span class="p">):</span>
         <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
     <span class="k">else</span><span class="p">:</span>
         <span class="n">x</span><span class="o">.</span><span class="n">items</span> <span class="o">+=</span> <span class="n">y</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
     <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">getfunc</span><span class="p">():</span>
   <span class="k">return</span> <span class="n">f</span>
</pre></div>
</div>
<p>Boost.Python の機能を用いて C++ で書き直すと次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="nf">f</span><span class="p">(</span><span class="n">object</span> <span class="n">x</span><span class="p">,</span> <span class="n">object</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>
         <span class="n">x</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span> <span class="o">=</span> <span class="s">&quot;bar&quot;</span><span class="p">;</span>
     <span class="k">else</span>
         <span class="n">x</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;items&quot;</span><span class="p">)</span> <span class="o">+=</span> <span class="n">y</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">object</span> <span class="nf">getfunc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">object</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ でコードを書いているという外観的な差を除けば、そのルックアンドフィールは Python のプログラマにも明確である。</p>
</div>
<div class="section" id="object">
<span id="tutorial-object-derived-object-types"></span><h3><a class="toc-backref" href="#id69">object の派生型</a><a class="headerlink" href="#object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Boost.Python には、Python の各型に対応する <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> の派生型がある。</p>
<ul class="simple">
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">list</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">dict</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">tuple</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">str</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">long_</span></code></p></li>
<li><p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">enum_</span></code></p></li>
</ul>
<p>これらの <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> の派生型は実際の Python 型と同様に振舞う。例を挙げる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">str</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="s2">&quot;1&quot;</span>
</pre></div>
</div>
<p>個々の派生 <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> は対応する Python 型のメソッドを持つ。例えば <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">dict</span></code> は <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keys</span></code> メソッドを持つ。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>タプルリテラル</strong>を宣言するのに <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_tuple</span></code> が提供されている。例を挙げる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span> <span class="s">&quot;Hello, World&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</div>
<p>C++ において、Boost.Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> を関数の引数に渡す場合は派生型の一致が要求される。例えば以下に示す関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">f</span></code> をラップする場合、Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">str</span></code> 型とその派生型のみを受け付ける。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">str</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">object</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;upper&quot;</span><span class="p">)();</span>   <span class="c1">// NAME = name.upper()</span>
    <span class="n">str</span> <span class="n">NAME</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">upper</span><span class="p">();</span>            <span class="c1">// のほうがよい</span>
    <span class="n">object</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;%s is bigger than %s&quot;</span> <span class="o">%</span> <span class="n">make_tuple</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>細かく見ると、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">str</span> <span class="n">NAME</span> <span class="o">=</span> <span class="n">name</span><span class="p">.</span><span class="n">upper</span><span class="p">();</span>
</pre></div>
</div>
<p>このコードから分かるように、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">str</span></code> 型のメソッドを C++ メンバ関数として提供している。次に、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">msg</span> <span class="o">=</span> <span class="s">&quot;%s is bigger than %s&quot;</span> <span class="o">%</span> <span class="n">make_tuple</span><span class="p">(</span><span class="n">NAME</span><span class="p">,</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>上記のコードのように Python の <code class="code docutils literal notranslate"><span class="pre">&quot;format&quot;</span> <span class="pre">%</span> <span class="pre">x,y,z</span></code> を C++ で書ける。標準の C++ で同じことを簡単に行う方法がないため便利である。</p>
<div class="admonition caution">
<p class="admonition-title">注意</p>
<p>Python 同様、Python の可変型の多くがコンストラクタでコピーを行うというよく知られた落とし穴があるので注意が必要である。</p>
<p>Python の場合：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>     <span class="c1"># x.__dict__ をコピーする</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;whatever&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>        <span class="c1"># コピーを変更する</span>
</pre></div>
</div>
<p>C++ の場合：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">dict</span> <span class="nf">d</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;__dict__&quot;</span><span class="p">));</span>  <span class="c1">// x.__dict__ をコピーする</span>
<span class="n">d</span><span class="p">[</span><span class="s">&quot;whatever&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>           <span class="c1">// コピーを変更する</span>
</pre></div>
</div>
</div>
<div class="section" id="object-class-t">
<span id="tutorial-object-derived-object-types-class-t-as-objects"></span><h4>object としての class_&lt;T&gt;<a class="headerlink" href="#object-class-t" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Boost.Python における <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> の動的な性質に従えば、あらゆる <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_&lt;T&gt;</span></code> もまたこれら型の 1 つである！ 以下のコード片はクラス（型）オブジェクトをラップする。</p>
<p>これを使って、ラップされたインスタンスを作成できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">vec345</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">Vec2</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Vec2&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def_readonly</span><span class="p">(</span><span class="s">&quot;length&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">length</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def_readonly</span><span class="p">(</span><span class="s">&quot;angle&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Point</span><span class="o">::</span><span class="n">angle</span><span class="p">)</span>
    <span class="p">)(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">vec345</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;length&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mf">5.0</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="c">
<span id="tutorial-object-extracting-c-objects"></span><h3><a class="toc-backref" href="#id70">C++ オブジェクトの抽出</a><a class="headerlink" href="#c" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> インスタンスを使用せずに C++ の値が必要になることがある。これは <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">extract&lt;T&gt;</span></code> 関数で実現できる。以下を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;length&quot;</span><span class="p">);</span> <span class="c1">// コンパイルエラー</span>
</pre></div>
</div>
<p>Boost.Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">double</span></code> へ暗黙に変換できないため、上記のコードはコンパイルエラーとなる。代わりに以下のように書けば希望どおりとなる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">l</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;length&quot;</span><span class="p">));</span>
<span class="n">Vec2</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="n">Vec2</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">v</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
</pre></div>
</div>
<p>1 行目は Boost.Python の <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> の <code class="xref py py-attr docutils literal notranslate"><span class="pre">length</span></code> 属性を抽出しようとしている。2 行目は Boost.Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> が保持している <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Vec2</span></code> オブジェクトを抽出しようとしている。</p>
<p>「～しようとしている」と書いたことに注意していただきたい。Boost.Python の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> が実際には <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Vec2</span></code> 型を保持していなかったらどうなるだろうか？ これは Python の <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code> がもつ動的な性質を考えれば十分ありうることである。安全のため、希望する C++ 型を抽出できない場合は適当な例外が投げられる。例外を避けるには抽出できるかテストする必要がある。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">extract</span><span class="o">&lt;</span><span class="n">Vec2</span><span class="o">&amp;&gt;</span> <span class="n">x</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">check</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Vec2</span><span class="o">&amp;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">();</span> <span class="p">...</span>
</pre></div>
</div>
<p>明敏な読者は <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">extract&lt;T&gt;</span></code> の機能が変更可能コピーの問題を解決することに気付いたかもしれない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">dict</span> <span class="n">d</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="n">dict</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;__dict__&quot;</span><span class="p">));</span>
<span class="n">d</span><span class="p">[</span><span class="s">&quot;whatever&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>          <span class="c1">// x.__dict__ を変更する！</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-object-enums">
<span id="id26"></span><h3><a class="toc-backref" href="#id71">列挙</a><a class="headerlink" href="#tutorial-object-enums" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Boost.Python には、C++ の列挙を捕捉、ラップする気の利いた機能がある。Python に <code class="code docutils literal notranslate"><span class="pre">enum</span></code> 型はないが、C++ の列挙を Python へ <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> としてエクスポートしたいことがよくある。Python の動的型付けから C++ の強い静的型付けへの適切な変換に気を付けていれば Boost.Python の列挙機能で容易に可能である（C++ では、整数から列挙へ暗黙に変換することはできない）。次のような C++ の列挙があったとして、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">choice</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</pre></div>
</div>
<p>次のようにして Python へエクスポートする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">enum_</span><span class="o">&lt;</span><span class="n">choice</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;choice&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span>
    <span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="n">blue</span><span class="p">)</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>新しい列挙は現在の <a class="reference internal" href="reference/scope.html#_CPPv4N5boost6python5scope5scopeERK5scope" title="boost::python::scope::scope"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">scope</span></code></a> に作成される。これは大抵の場合現在のモジュールである。上記のコード片は Python の <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> 型から派生した、第 1 引数に渡した C++ 型に対応する Python クラスを作成する。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p class="rubric">scope とは</p>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">scope</span></code> は、新しい拡張クラスやラップした関数が属性として定義される Python の名前空間を制御するグローバルな関連 Python オブジェクトを持つクラスである。詳細は<a class="reference internal" href="reference/scope.html#v2-scope-scope-spec"><span class="std std-ref">リファレンス</span></a>を見よ。</p>
</div>
<p>Python からはこれらの値に以下のようにしてアクセスできる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_module</span><span class="o">.</span><span class="n">choice</span><span class="o">.</span><span class="n">red</span>
<span class="go">my_module.choice.red</span>
</pre></div>
</div>
<p>ここで <code class="xref py py-mod docutils literal notranslate"><span class="pre">my_module</span></code> は列挙を宣言したモジュールである。新しいスコープをクラスに対して作成することもできる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">scope</span> <span class="n">in_X</span> <span class="o">=</span> <span class="n">class_</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;X&quot;</span><span class="p">)</span>
                <span class="p">.</span><span class="n">def</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
                <span class="p">.</span><span class="n">def</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
            <span class="p">;</span>

<span class="c1">// X::nested を X.nested としてエクスポートする</span>
<span class="n">enum_</span><span class="o">&lt;</span><span class="n">X</span><span class="o">::</span><span class="n">nested</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;nested&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s">&quot;red&quot;</span><span class="p">,</span> <span class="n">red</span><span class="p">)</span>
    <span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="s">&quot;blue&quot;</span><span class="p">,</span> <span class="n">blue</span><span class="p">)</span>
    <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="pyobject-boost-python-object">
<span id="tutorial-object-creating-python-object"></span><h3><a class="toc-backref" href="#id72"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject*</span></code> から <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">boost::python::object</span></code> を作成する</a><a class="headerlink" href="#pyobject-boost-python-object" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject*</span></code> である <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">pyobj</span></code> へのポインタを <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">boost::python::object</span></code> で管理したい場合、以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">object</span> <span class="n">o</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">handle</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">pyobj</span><span class="p">));</span>
</pre></div>
</div>
<p>この場合、オブジェクト <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">o</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">pyobj</span></code> を管理するが、構築時に参照カウントを増やさない。</p>
<p>あるいは借用（borrowed）参照を使う方法として、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">object</span> <span class="n">o</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">handle</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="o">::</span><span class="n">borrowed</span><span class="p">(</span><span class="n">pyobj</span><span class="p">)));</span>
</pre></div>
</div>
<p>この場合 <code class="xref c c-macro docutils literal notranslate"><span class="pre">Py_INCREF</span></code> が呼び出されるので、オブジェクト <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">o</span></code> がスコープ外に出ても <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">pyobj</span></code> は破壊されない。</p>
</div>
</div>
<div class="section" id="tutorial-embedding">
<span id="id27"></span><h2><a class="toc-backref" href="#id73">組み込み</a><a class="headerlink" href="#tutorial-embedding" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Boost.Python を使って Python から C++ のコードを呼び出す方法について理解できたと思う。しかしときには逆のこと、つまり C++ 側から Python のコードを呼び出す必要が出てくるはずである。これには Python のインタープリタを C++ のプログラムに<strong>組み込む</strong>必要がある。</p>
<p>現時点では Boost.Python は組み込みに必要なことをすべてサポートしているわけではない。したがってこのギャップを埋めるには <a class="reference external" href="http://www.python.org/doc/current/api/api.html">Python の C API</a> を使う必要が出てくる。とはいえ Boost.Python は組み込みの大部分を容易にしており、将来のバージョンでは Python の C API に触れる必要はなくなるかもしれない。そういうわけだから期待しておいて欲しい。</p>
<div class="section" id="tutorial-embedding-building-embedded-programs">
<span id="id28"></span><h3><a class="toc-backref" href="#id74">組み込みプログラムをビルドする</a><a class="headerlink" href="#tutorial-embedding-building-embedded-programs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python をプログラムに組み込み可能にするには、Python だけでなく Boost.Python 本体の実行時ライブラリにもリンクしなければならない。</p>
<p>Boost.Python のライブラリは 2 種類ある。いずれも Boost の <code class="file docutils literal notranslate"><span class="pre">/libs/python/build/bin-stage</span></code> サブディレクトリにある。Windows ではライブラリの名前は <code class="file docutils literal notranslate"><span class="pre">boost_python.lib</span></code>（リリースビルド用）と <code class="file docutils literal notranslate"><span class="pre">boost_python_debug.lib</span></code>（デバッグ用）である。ライブラリが見つからない場合は、おそらくまだ Boost.Python をビルドしていないのだろう。<a class="reference internal" href="building.html"><span class="doc">ビルドとテスト</span></a>を見て方法を確認するとよい。</p>
<p>Python のライブラリは、Python ディレクトリの <code class="file docutils literal notranslate"><span class="pre">/libs</span></code> サブディレクトリにある。Windows では pythonXY.lib のような名前で、X.Y が Python のメジャーバージョンの番号である。</p>
<p>また Python の <code class="file docutils literal notranslate"><span class="pre">/include</span></code> サブディレクトリをインクルードパスに追加しておかなければならない。</p>
<p>Jamfile に以上のことをすべて要約すると、</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>projectroot c:\projects\embedded_program ; # プログラムの場所

# Python 用の規則
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;

exe embedded_program # 実行可能ファイルの名前
  : # ソースファイル
     embedded_program.cpp
  : # 必須条件
     &lt;find-library&gt;boost_python &lt;library-path&gt;c:\boost\libs\python
  $(PYTHON_PROPERTIES)
    &lt;library-path&gt;$(PYTHON_LIB_PATH)
    &lt;find-library&gt;$(PYTHON_EMBEDDED_LIBRARY) ;
</pre></div>
</div>
</div>
<div class="section" id="tutorial-embedding-getting-started">
<span id="id29"></span><h3><a class="toc-backref" href="#id75">はじめに</a><a class="headerlink" href="#tutorial-embedding-getting-started" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ビルドできるようになったのはよいが、まだビルドするものがない。Python のインタープリタを C++ のプログラムに組み込むには、以下の 3 段階が必要である。</p>
<ol class="arabic simple">
<li><p><code class="file docutils literal notranslate"><span class="pre">&lt;boost/python.hpp&gt;</span></code> をインクルードする。</p></li>
<li><p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Py_Initialize</span> <span class="pre">&lt;http://docs.python.jp/2/c-api/init.html#Py_Initialize&gt;</span></code> を呼び出してインタープリタを起動、<code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code> モジュールを作成する。</p></li>
<li><p>他の Python C API を呼び出してインタープリタを使用する。</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>現時点ではインタープリタを停止するのに <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">Py_Finalize</span> <span class="pre">&lt;http://docs.python.jp/2/c-api/init.html#Py_Finalize&gt;</span></code> を呼び出してはならない。これは Boost.Python の将来のバージョンで修正する。</p>
</div>
<p>（当然ながら、上記の各段階の間に他の C++ コードを挟んでもよい。）</p>
<p>これでプログラムにインタープリタを組み込み可能になった。次に使用方法を見ていく。</p>
</div>
<div class="section" id="tutorial-embedding-using-the-interpreter">
<span id="id30"></span><h3><a class="toc-backref" href="#id76">インタープリタを使用する</a><a class="headerlink" href="#tutorial-embedding-using-the-interpreter" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>すでに知っていることと思うが、Python のオブジェクトは参照カウントで管理されている。当然、Python C API の <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">PyObject</span></code> も参照カウンタを持っているが、違いがある。参照カウントは Python では完全に自動で行われているが、Python C API では<a class="reference external" href="http://docs.python.jp/2/c-api/refcounting.html">手動で</a>行う必要がある。これは厄介で、とりわけ C++ 例外が現れるコードで正しく取り扱うのが困難である。幸いにも Boost.Python には <a class="reference internal" href="reference/handle.html#_CPPv4I0EN5boost6python6handleE" title="boost::python::handle"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">handle</span></code></a> および <a class="reference internal" href="reference/object.html#_CPPv4N5boost6python6objectE" title="boost::python::object"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code></a> クラステンプレートがあり、この処理を自動化できる。</p>
<div class="section" id="tutorial-embedding-using-the-interpreter-running-python-code">
<span id="id32"></span><h4>Python のコードを起動する<a class="headerlink" href="#tutorial-embedding-using-the-interpreter-running-python-code" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Boost.Python は、C++ から Python のコードを起動する関数を 3 つ提供している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">eval</span><span class="p">(</span><span class="n">str</span> <span class="n">expression</span><span class="p">,</span> <span class="n">object</span> <span class="n">globals</span> <span class="o">=</span> <span class="n">object</span><span class="p">(),</span> <span class="n">object</span> <span class="n">locals</span> <span class="o">=</span> <span class="n">object</span><span class="p">())</span>
<span class="n">object</span> <span class="n">exec</span><span class="p">(</span><span class="n">str</span> <span class="n">code</span><span class="p">,</span> <span class="n">object</span> <span class="n">globals</span> <span class="o">=</span> <span class="n">object</span><span class="p">(),</span> <span class="n">object</span> <span class="n">locals</span> <span class="o">=</span> <span class="n">object</span><span class="p">())</span>
<span class="n">object</span> <span class="n">exec_file</span><span class="p">(</span><span class="n">str</span> <span class="n">filename</span><span class="p">,</span> <span class="n">object</span> <span class="n">globals</span> <span class="o">=</span> <span class="n">object</span><span class="p">(),</span> <span class="n">object</span> <span class="n">locals</span> <span class="o">=</span> <span class="n">object</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">eval</span></code> は与えられた式を評価し結果の値を返す。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">exec</span></code> は与えられたコード（典型的には文の集まり）を実行し結果を返す。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">exec_file</span></code> は与えられたファイル内のコードを実行する。</p>
<p>これらについては第 1 引数が <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">str</span></code> ではなく <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">char*</span> <span class="pre">const</span></code> となっている多重定義もある。</p>
<p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">globals</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">locals</span></code> 引数は、コードを実行するコンテキストの <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">globals</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">locals</span></code> に相当する Python の辞書である。ほとんどの目的において、<code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code> モジュールの名前空間辞書を両方の引数に使用するとよい。</p>
<p>Boost.Python はモジュールをインポートする関数を提供する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="k">import</span><span class="p">(</span><span class="n">str</span> <span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">import</span></code> は Python のモジュールをインポートし（潜在的には、はじめに起動しているプロセスに読み込む）、返す。</p>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code> モジュールをインポートし、その名前空間で Python のコードを走らせてみよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">main_module</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="s">&quot;__main__&quot;</span><span class="p">);</span>
<span class="n">object</span> <span class="n">main_namespace</span> <span class="o">=</span> <span class="n">main_module</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;__dict__&quot;</span><span class="p">);</span>

<span class="n">object</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">exec</span><span class="p">(</span><span class="s">&quot;hello = file(&#39;hello.txt&#39;, &#39;w&#39;)</span><span class="se">\n</span><span class="s">&quot;</span>
                      <span class="s">&quot;hello.write(&#39;Hello world!&#39;)</span><span class="se">\n</span><span class="s">&quot;</span>
                      <span class="s">&quot;hello.close()&quot;</span><span class="p">,</span>
                      <span class="n">main_namespace</span><span class="p">);</span>
</pre></div>
</div>
<p>このコードは現在のディレクトリに <code class="file docutils literal notranslate"><span class="pre">hello.txt</span></code> という名前のファイルを作成し、プログラミングサークルでよく知られたフレーズを書き込む。</p>
</div>
<div class="section" id="tutorial-embedding-using-the-interpreter-manipulating-python-objects">
<span id="id33"></span><h4>Python のオブジェクトを操作する<a class="headerlink" href="#tutorial-embedding-using-the-interpreter-manipulating-python-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Python オブジェクトを操作するクラスが欲しくなることがよくある。しかしすでに上記や<a class="reference internal" href="#tutorial-object"><span class="std std-ref">前節</span></a>でそのようなクラスを見た。文字通りの名前を持つ <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">object</span></code> とその派生型である。またそれらを <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">handle</span></code> から構築できることも見た。以下の例を見ればより明らかだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">main_module</span> <span class="o">=</span> <span class="k">import</span><span class="p">(</span><span class="s">&quot;__main__&quot;</span><span class="p">);</span>
<span class="n">object</span> <span class="n">main_namespace</span> <span class="o">=</span> <span class="n">main_module</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;__dict__&quot;</span><span class="p">);</span>
<span class="n">object</span> <span class="n">ignored</span> <span class="o">=</span> <span class="n">exec</span><span class="p">(</span><span class="s">&quot;result = 5 ** 2&quot;</span><span class="p">,</span> <span class="n">main_namespace</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">five_squared</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">main_namespace</span><span class="p">[</span><span class="s">&quot;result&quot;</span><span class="p">]);</span>
</pre></div>
</div>
<p><code class="xref py py-mod docutils literal notranslate"><span class="pre">__main__</span></code> モジュールの名前空間に相当する辞書オブジェクトを作成している。次に 5 の 2 乗を結果の変数に代入し、この変数を辞書から読んでいる。同じ結果を得る他の方法としては代わりに <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">eval</span></code> を使用する方法があり、こちらは結果を直接返す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="s">&quot;5 ** 2&quot;</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">five_squared</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-embedding-using-the-interpreter-exception-handling">
<span id="id34"></span><h4>例外処理<a class="headerlink" href="#tutorial-embedding-using-the-interpreter-exception-handling" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Python の式を評価中に例外を送出した場合、<a class="reference internal" href="reference/errors.html#_CPPv4N5boost6python17error_already_setE" title="boost::python::error_already_set"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">error_already_set</span></code></a> が投げられる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">try</span>
<span class="p">{</span>
    <span class="n">object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">eval</span><span class="p">(</span><span class="s">&quot;5/0&quot;</span><span class="p">);</span>
    <span class="c1">// ここには絶対に来ない：</span>
    <span class="kt">int</span> <span class="n">five_divided_by_zero</span> <span class="o">=</span> <span class="n">extract</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="n">error_already_set</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 何らかの方法で例外を処理する</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">error_already_set</span></code> 例外クラス自体は何の情報も持たない。送出された Python の例外について詳細を調べるには、catch 文内で Python C API の<a class="reference external" href="http://www.python.org/doc/api/exceptionHandling.html">例外処理関数</a>を使用する必要がある。これは単純に <a class="reference external" href="http://docs.python.jp/2/c-api/exceptions.html">PyErr_Print()</a> を呼び出して例外のトレースバックをコンソールへプリントするか、あるいは例外の型を<a class="reference external" href="http://docs.python.jp/2/c-api/exceptions.html#standardexceptions">標準の例外</a>と比較する程度となるだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">catch</span><span class="p">(</span><span class="n">error_already_set</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_ExceptionMatches</span><span class="p">(</span><span class="n">PyExc_ZeroDivisionError</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// ZeroDivisionError を特別扱いする</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// 他のすべてのエラーを stderr にプリントする</span>
        <span class="n">PyErr_Print</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>（例外についてより多くの情報を取得するには、<a class="reference external" href="http://docs.python.jp/2/c-api/exceptions.html">このリスト</a>にある例外処理関数を使用する。）</p>
</div>
</div>
</div>
<div class="section" id="tutorial-iterators">
<span id="id38"></span><h2><a class="toc-backref" href="#id77">イテレータ</a><a class="headerlink" href="#tutorial-iterators" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ 、特に STL においてイテレータはあらゆる場面で使用されている。Python にもイテレータがあるが、両者には大きな違いがある。</p>
<dl class="simple">
<dt>C++ のイテレータ：</dt><dd><ul class="simple">
<li><p>C++ のイテレータは 5 つに分類される（ランダムアクセス、双方向、単方向、入力、出力）</p></li>
<li><p>再配置とアクセスの 2 種類の操作がある</p></li>
<li><p>範囲を表すのにイテレータの組（先頭と末尾）が必要</p></li>
</ul>
</dd>
<dt>Python のイテレータ：</dt><dd><ul class="simple">
<li><p>分類は 1 つしかない（単方向）</p></li>
<li><p>操作は 1 種類しかない（<code class="code docutils literal notranslate"><span class="pre">next()</span></code>）</p></li>
<li><p>終了時に <code class="xref py py-exc docutils literal notranslate"><span class="pre">StopIteration</span></code> 例外を投げる</p></li>
</ul>
</dd>
</dl>
<p>典型的な Python の走査プロトコルである <code class="code docutils literal notranslate"><span class="pre">for</span> <span class="pre">y</span> <span class="pre">in</span> <span class="pre">x...</span></code> は以下のようである。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">iter</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>         <span class="c1"># イテレータを取得する</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>         <span class="c1"># 各要素を取得する</span>
    <span class="o">...</span>                     <span class="c1"># y を処理する</span>
<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span> <span class="k">pass</span>  <span class="c1"># イテレータが尽きた</span>
</pre></div>
</div>
<p>Boost.Python は、C++ のイテレータを Python のイテレータとして振舞うようにする機構をいくつか提供している。必要なことは C++ のイテレータから Python の走査プロトコルと互換性のある適切な <code class="xref py py-func docutils literal notranslate"><span class="pre">__iter__</span></code> 関数を用意することである。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">object</span> <span class="n">get_iterator</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">();</span>
<span class="n">object</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">get_iterator</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="n">object</span> <span class="n">first</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
</pre></div>
</div>
<p>あるいは <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_&lt;&gt;</span></code> で以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__iter__&quot;</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">())</span>
</pre></div>
</div>
<div class="section" id="range">
<h3><a class="toc-backref" href="#id78">range</a><a class="headerlink" href="#range" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">range</span></code> 関数を使用すると、Python の実践的なイテレータを作成できる。</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">range(start,</span> <span class="pre">finish)</span></code></p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">range&lt;Policies,</span> <span class="pre">Target&gt;(start,</span> <span class="pre">finish)</span></code></p></li>
</ul>
<p>ここで <code class="samp docutils literal notranslate"><em><span class="pre">start</span></em></code> 、<code class="samp docutils literal notranslate"><em><span class="pre">finish</span></em></code> は以下のいずれかである。</p>
<ul class="simple">
<li><p>メンバデータポインタ</p></li>
<li><p>メンバ関数ポインタ</p></li>
<li><p>関数オブジェクト（<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Target</span></code> 引数を使用）</p></li>
</ul>
</div>
<div class="section" id="iterator">
<h3><a class="toc-backref" href="#id79">iterator</a><a class="headerlink" href="#iterator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><p><code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/iterator.html#_CPPv4I00EN5boost6python8iteratorE" title="boost::python::iterator"><span class="pre">iterator</span></a><span class="pre">&lt;</span><span class="pre">T</span><span class="pre">,</span> <span class="pre">Policies</span><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">)</span></code></p></li>
</ul>
<p>コンテナ <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">T</span></code> が与えられた場合、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">iterator</span></code> は単に <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">&amp;</span><span class="pre">T</span><span class="pre">::</span><span class="pre">begin</span></code> と <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">&amp;</span><span class="pre">T</span><span class="pre">::</span><span class="pre">end</span></code> で <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">range</span></code> を呼び出すショートカットとなる。</p>
<p>実際にやってみよう。以下はある仮説の粒子加速器のコードからの例である。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">Field</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">pions</span><span class="p">:</span>
    <span class="n">smash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">bogons</span><span class="p">:</span>
    <span class="n">count</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>C++ のラッパは以下のようになるだろう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">class_</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;Field&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">property</span><span class="p">(</span><span class="s">&quot;pions&quot;</span><span class="p">,</span> <span class="n">range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">F</span><span class="o">::</span><span class="n">p_begin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">F</span><span class="o">::</span><span class="n">p_end</span><span class="p">))</span>
    <span class="p">.</span><span class="n">property</span><span class="p">(</span><span class="s">&quot;bogons&quot;</span><span class="p">,</span> <span class="n">range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">F</span><span class="o">::</span><span class="n">b_begin</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">F</span><span class="o">::</span><span class="n">b_end</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="stl-input-iterator">
<h3><a class="toc-backref" href="#id80">stl_input_iterator</a><a class="headerlink" href="#stl-input-iterator" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ここまで C++ のイテレータと範囲を Python へエクスポートする方法を見てきた。しかしこれ以外に、Python のシーケンスを STL アルゴリズムに渡したり、STL コンテナを初期化したい場合がある。Python のイテレータを STL のイテレータのように見せかける必要がある。これには <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">stl_input_iterator&lt;&gt;</span></code> を使用する。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">std::list&lt;int&gt;::assign</span></code> を Python へエクスポートする関数の実装方法を考えよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">list_assign</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">l</span><span class="p">,</span> <span class="n">object</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Python のシーケンスを STL の入力範囲に変換する</span>
    <span class="n">stl_input_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">begin</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">l</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// list&lt;int&gt; のラッパの一部</span>
<span class="n">class_</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;list_int&quot;</span><span class="p">)</span>
    <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;assign&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list_assign</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">)</span>
    <span class="c1">// ...</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>これで Python 側であらゆる整数シーケンスを <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">list_int</span></code> オブジェクトへ代入できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">list_int</span><span class="p">();</span>
<span class="n">x</span><span class="p">.</span><span class="n">assign</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="tutorial-exception">
<span id="id39"></span><h2><a class="toc-backref" href="#id81">例外の変換</a><a class="headerlink" href="#tutorial-exception" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>C++ の例外はすべて Python コードとの境界で捕捉しなければならない。この境界は C++ が Python と接する地点である。Boost.Python は、選択した標準の例外を変換して処理を中止する既定の例外ハンドラを提供する。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="s1">&#39;unidentifiable C++ Exception&#39;</span>
</pre></div>
</div>
<p>ユーザがカスタムの変換器を提供してもよい。例えば、<a class="footnote-reference brackets" href="#id47" id="id40">2</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">PodBayDoorException</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">translator</span><span class="p">(</span><span class="n">PodBayDoorException</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_UserWarning</span><span class="p">,</span> <span class="s">&quot;I&#39;m sorry Dave...&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">kubrick</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">register_exception_translator</span><span class="o">&lt;</span>
          <span class="n">PodBayDoorException</span><span class="o">&gt;</span><span class="p">(</span><span class="n">translator</span><span class="p">);</span>
     <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-techniques">
<span id="id41"></span><h2><a class="toc-backref" href="#id82">典型的なテクニック</a><a class="headerlink" href="#tutorial-techniques" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Boost.Python でコードをラップするのに使えるテクニックをいくつか紹介する。</p>
<div class="section" id="tutorial-techniques-creating-packages">
<span id="id42"></span><h3><a class="toc-backref" href="#id83">パッケージを作成する</a><a class="headerlink" href="#tutorial-techniques-creating-packages" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python のパッケージは、ユーザに一定の機能を提供するモジュールの集まりである。パッケージの作成についてなじみがなければ、<a class="reference external" href="http://docs.python.jp/2/tutorial/modules.html">Python のチュートリアル</a>によい導入がある。</p>
<p>しかし今は Boost.Python を使って C++ コードをラップしているのである。優れたパッケージインターフェイスをユーザに提供するにはどうすればよいだろうか？ 概念的なことを捉えるために例を使って考えよう。</p>
<p>音に関する C++ ライブラリがあったとする。様々な形式で読み書きし、音データにフィルタをかける等するものとする。（便宜的に）名前を <code class="xref py py-mod docutils literal notranslate"><span class="pre">sounds</span></code> としておこう。以下のような整理された C++ 名前空間の階層がすでにあるとする。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sounds::core
sounds::io
sounds::filters
</pre></div>
</div>
<p>Python ユーザに同じ階層を提示し、次のようなコードが書けるようにしたい。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sounds.filters</span>
<span class="n">sounds</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="c1"># echo は C++ 関数</span>
</pre></div>
</div>
<p>第 1 段階はラップコードを書くことである。以下のように Boost.Python を使って各モジュールを個別にエクスポートしなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ファイル core.cpp */</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 名前空間 sounds::core 内のものをすべてエクスポートする */</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* ファイル io.cpp */</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">io</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 名前空間 sounds::io 内のものをすべてエクスポートする */</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* ファイル filters.cpp */</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">filters</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 名前空間 sounds::filters 内のものをすべてエクスポートする */</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これらのファイルをコンパイルすると、<code class="file docutils literal notranslate"><span class="pre">core.pyd</span></code> 、<code class="file docutils literal notranslate"><span class="pre">io.pyd</span></code> および <code class="file docutils literal notranslate"><span class="pre">filters.pyd</span></code> の Python 拡張が生成される。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>拡張子 <code class="file docutils literal notranslate"><span class="pre">.pyd</span></code> は Python の拡張モジュールで使用するものであり、単純に共有ライブラリである。システムで既定のもの（Unix の場合は <code class="file docutils literal notranslate"><span class="pre">.so</span></code> 、Windows の場合は <code class="file docutils literal notranslate"><span class="pre">.dll</span></code>）を使用しても差し支えない。</p>
</div>
<p>次に以下の Python パッケージ用のディレクトリ構造を作成する。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sounds/
    __init__.py
    core.pyd
    filters.pyd
    io.pyd
</pre></div>
</div>
<p>ファイル <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> は、ディレクトリ <code class="file docutils literal notranslate"><span class="pre">sounds/</span></code> が実際は Python のパッケージであることを Python に伝える。このファイルは空でもよいが、後述するようにここでマジックを行うことも可能だ。</p>
<p>これでパッケージの準備が整った。ユーザがなすべきなのは、<code class="file docutils literal notranslate"><span class="pre">sounds</span></code> を <a class="reference external" href="http://docs.python.jp/2/tutorial/modules.html#tut-searchpath">PYTHONPATH</a> に置いてインタープリタを起動することだけである。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sounds.io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sounds.filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sound</span> <span class="o">=</span> <span class="n">sounds</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;file.mp3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_sound</span> <span class="o">=</span> <span class="n">sounds</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">sound</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>何も問題無いようだが、どうだろう？</p>
<p>これはパッケージ階層を作成する最も単純な方法だが、柔軟性がまるでない。<strong>純粋な</strong> Python の関数、例えば音オブジェクトに 3 つのフィルタを同時にかける関数を <code class="xref py py-mod docutils literal notranslate"><span class="pre">filters</span></code> パッケージに追加したい場合はどうだろうか？ 確かにC++ で書いてエクスポートすれば可能だが、Python でやってみてはどうか。そうすれば拡張モジュールの再コンパイルが不要で、書くのも簡単である。</p>
<p>こういった柔軟性が必要な場合、パッケージ階層を少しばかり複雑にしなければならない。まず拡張モジュール群の名前を変更しなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ファイル core.cpp */</span>
<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">_core</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* 名前空間 sounds::core 内のものをすべてエクスポートする */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>モジュール名にアンダースコアを追加したことに注意していただきたい。ファイル名も <code class="file docutils literal notranslate"><span class="pre">_core.pyd</span></code> に変わるはずである。他の拡張モジュールも同様である。これでパッケージ階層は以下のように変更された。</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sounds/
    __init__.py
    core/
        __init__.py
        _core.pyd
    filters/
        __init__.py
        _filters.pyd
    io/
        __init__.py
        _io.pyd
</pre></div>
</div>
<p>各拡張モジュールについてディレクトリを作成し、それぞれに <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> を追加したことに注意していただきたい。しかしこれをこのままおいておくと、ユーザは次のような構文で <code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code> モジュールの関数にアクセスしなければならない。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sounds.core._core</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sounds</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">_core</span><span class="o">.</span><span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>これは望ましいことではない。しかしここで <code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> のマジックが発動する。<code class="file docutils literal notranslate"><span class="pre">__init__.py</span></code> の名前空間に持ち込まれるものはすべてユーザが直接アクセスできるのである。そういうわけで、名前空間全体を <code class="file docutils literal notranslate"><span class="pre">_core.pyd</span></code> から <code class="file docutils literal notranslate"><span class="pre">core/__init__.py</span></code> へ持ち込むだけでよい。つまり次のコード行を <code class="file docutils literal notranslate"><span class="pre">sounds/core/__init__.py</span></code> へ追加する。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_core</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>他のパッケージも同様に行う。これでユーザは以前のように拡張モジュール内と関数とクラスにアクセスできるようになる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sounds.filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sounds</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>他にも純粋な Python 関数をあらゆるモジュールに容易に追加できるという利点もある。この方法であればユーザには C++ 関数と Python 関数の見分けが付かない。では<strong>純粋な</strong> Python 関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">echo_noise</span></code> を <code class="xref py py-mod docutils literal notranslate"><span class="pre">filters</span></code> パッケージに追加しよう。この関数は与えられた <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">sound</span></code> オブジェクトに <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">echo</span></code> と <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">noise</span></code> の両方のフィルタを順番に適用する。<code class="file docutils literal notranslate"><span class="pre">sounds/filters/echo_noise.py</span></code> という名前でファイルを作成して関数のコードを書く。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">_filters</span>
<span class="k">def</span> <span class="nf">echo_noise</span><span class="p">(</span><span class="n">sound</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">echo</span><span class="p">(</span><span class="n">sound</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_filters</span><span class="o">.</span><span class="n">noise</span><span class="p">(</span><span class="n">sound</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>
</pre></div>
</div>
<p>次に以下の行を <code class="file docutils literal notranslate"><span class="pre">sounds/filters/__init__.py</span></code> に追加する。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">echo_noise</span> <span class="kn">import</span> <span class="n">echo_noise</span>
</pre></div>
</div>
<p>これで終わりだ。ユーザは、<code class="xref py py-mod docutils literal notranslate"><span class="pre">filters</span></code> パッケージの他の関数と同様にこの関数にアクセスできる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sounds.filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sounds</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">echo_noise</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tutorial-techniques-extending-wrapped-objects-in-python">
<span id="id44"></span><h3><a class="toc-backref" href="#id84">ラップしたオブジェクトを Python で拡張する</a><a class="headerlink" href="#tutorial-techniques-extending-wrapped-objects-in-python" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Python の柔軟性に感謝することだ。クラスを作成した後であってもメソッドを容易に追加できる。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="k">pass</span>
<span class="go">&gt;&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;&gt; # 普通の関数</span>
<span class="go">&gt;&gt;&gt;&gt; def C_str(self): return &#39;C のインスタンス！&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># メンバ関数に変更する</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span><span class="o">.</span><span class="fm">__str__</span> <span class="o">=</span> <span class="n">C_str</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">c</span>
<span class="go">C のインスタンス！</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C_str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">C のインスタンス！</span>
</pre></div>
</div>
<p>やはり Python は素晴らしい。</p>
<p>同様のことが Boost.Python でラップしたクラスでもできる。C++ 側に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">point</span></code> クラスがあるとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">point</span> <span class="p">{...};</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">_geom</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;point&quot;</span><span class="p">)...;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>前節『<a class="reference internal" href="#tutorial-techniques-creating-packages"><span class="std std-ref">パッケージを作成する</span></a>』のテクニックを使うと <code class="file docutils literal notranslate"><span class="pre">geom/__init__.py</span></code> に直接コードが書ける。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">_geom</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># 普通の関数</span>
<span class="k">def</span> <span class="nf">point_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

<span class="c1"># メンバ関数に変更する</span>
<span class="n">point</span><span class="o">.</span><span class="fm">__str__</span> <span class="o">=</span> <span class="n">point_str</span>
</pre></div>
</div>
<p>C++ で作成した<strong>すべての</strong> <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">point</span></code> インスタンスがこのメンバ関数を持つことになる！ このテクニックには色々と利点がある。</p>
<ul class="simple">
<li><p>追加する関数についてのコンパイル時間増加がゼロになる</p></li>
<li><p>メモリのフットプリントが見かけ上ゼロに削減する</p></li>
<li><p>再コンパイルの必要が最小になる</p></li>
<li><p>高速なプロトタイピング（インターフェイスを変更しないことが要求されている場合、コードを C++ に移動することが可能）</p></li>
</ul>
<p>別の有用な考えとして、コンストラクタをファクトリ関数で置き換える方法がある。</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">_point</span> <span class="o">=</span> <span class="n">point</span>

<span class="k">def</span> <span class="nf">point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>このような簡単な例ではつまらない感じがするが、多重定義や引数が多数あるコンストラクタにおいては優れた単純化となることが多い。キーワードサポートに対してコンパイル時間のオーバーヘッドがゼロ、メモリのフットプリントも事実上ゼロとなる。</p>
</div>
<div class="section" id="tutorial-techniques-reducing-compiling-time">
<span id="id45"></span><h3><a class="toc-backref" href="#id85">コンパイルにかかる時間を短縮する</a><a class="headerlink" href="#tutorial-techniques-reducing-compiling-time" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>クラスを大量にエクスポートすると、Boost.Python ラッパのコンパイルにかなりの時間がかかる。またメモリの消費量が容易に過大となる。これが問題となるのであれば、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">class_</span></code> 定義を複数のファイルに分割するとよい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ファイル point.cpp */</span>
<span class="cp">#include</span> <span class="cpf">&lt;point.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">export_point</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;point&quot;</span><span class="p">)...;</span>
<span class="p">}</span>

<span class="cm">/* ファイル triangle.cpp */</span>
<span class="cp">#include</span> <span class="cpf">&lt;triangle.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">export_triangle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">triangle</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;triangle&quot;</span><span class="p">)...;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>そして <code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_PYTHON_MODULE</span></code> マクロを含んだ <code class="file docutils literal notranslate"><span class="pre">main.cpp</span></code> ファイルを作成し、その中でエクスポート関数を呼び出す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">export_point</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">export_triangle</span><span class="p">();</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">_geom</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">export_point</span><span class="p">();</span>
    <span class="n">export_triangle</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これらのファイルをすべてコンパイル、リンクすると、通常の方法の場合と同じ結果が得られる。しかしメモリはまともな状態が維持できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;point.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;triangle.h&gt;</span><span class="cp"></span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">_geom</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">point</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;point&quot;</span><span class="p">)...;</span>
    <span class="n">class_</span><span class="o">&lt;</span><span class="n">triangle</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;triangle&quot;</span><span class="p">)...;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++ ライブラリ開発と Python へのエクスポートを同時に行っている場合にも、この方法を推奨する。クラス内で変更があっても、ラッパコード全体ではなく単一の cpp ファイルについてコンパイルが必要になるだけである。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>巨大なソースファイルをコンパイルしてエラーメッセージ「致命的なエラー C1204：コンパイラの制限：内部構造がオーバーフローしました。」が出た場合にも、この方法を推奨する。<a class="reference internal" href="faq.html#faq-fatal-error-c1204-compiler-limit"><span class="std std-ref">FAQ</span></a> に説明がある。</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id46"><span class="brackets"><a class="fn-backref" href="#id19">1</a></span></dt>
<dd><p>訳注　この日本語訳は <a class="reference external" href="http://www.python.jp/Zope/Zope/articles/misc/zen">http://www.python.jp/Zope/Zope/articles/misc/zen</a> によりました（Copyright © 2001-2012 Python Japan User's Group）。</p>
</dd>
<dt class="label" id="id47"><span class="brackets"><a class="fn-backref" href="#id40">2</a></span></dt>
<dd><p>訳注　『2001 年宇宙の旅』（“2001: A Space Odyssey” : Stanley Kubrick and Arthur C. Clarke, 1968）かな？</p>
</dd>
</dl>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="building.html" class="btn btn-neutral float-right" title="ビルドとテスト" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="release_notes.html" class="btn btn-neutral float-left" title="リリースノート" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2020, exeal

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
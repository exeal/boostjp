

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ユーザーガイド &mdash; Boost.Xpressive（日本語訳）  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="リファレンス" href="reference/index.html" />
    <link rel="prev" title="前口上" href="preface.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Boost.Xpressive（日本語訳）
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目次</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">前口上 </a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">ユーザーガイド</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id3">はじめに</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#xpressive">xpressive とは何か</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hello-world">Hello, world!</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id9">xpressive のインストール</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">xpressive の入手</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">xpressive を使ったビルド</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id12">必要要件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id13">サポートするコンパイラ</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">クイックスタート</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#quick-start-know-your-iterator-type">イテレータの型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id17">タスク</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id18">正規表現オブジェクトの作成</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">静的正規表現</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">概要</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">構築と代入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">文字と文字列リテラル</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">結合と選択</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">グループ化と捕捉</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id27">動的正規表現</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id28">概要</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id29">構築と代入</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id30">動的 xpressive の構文</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">国際化</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id33">マッチと検索</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id34">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id36">文字列が正規表現にマッチするか調べる</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id37">部分文字列のマッチを検索する</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id38">結果へのアクセス</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id39">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#match-results">match_results</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sub-match">sub_match</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id40">効果の無効化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id41">文字列の置換</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regex-replace">regex_replace()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id42">置換のオプション</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ecma-262">ECMA-262 書式化シーケンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sed">sed 書式化シーケンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="#perl">Perl 書式化シーケンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boost">Boost 固有の書式化シーケンス</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id43">書式化オブジェクト</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id44">書式化式</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id45">文字列の分割とトークン分割</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">例 1：単純なトークン分割</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id49">例 2：単純なトークン分割・リローデッド</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id51">例 3：単純なトークン分割・レボリューションズ </a></li>
<li class="toctree-l3"><a class="reference internal" href="#id52">例 4：あまり単純でないトークン分割</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id55">名前付き捕捉</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id56">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id57">動的名前付き捕捉</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id58">静的名前付き捕捉</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id61">文法と入れ子マッチ</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id62">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id63">値による正規表現の組み込み</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id64">参照による正規表現の組み込み</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id65">文法の構築</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id66">動的正規表現文法</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id67">循環パターンにコピーにメモリ管理まで、まあ何てこと！</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id68">入れ子の正規表現と部分マッチのスコープ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id69">入れ子の結果</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id70">入れ子の結果のフィルタリング</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id71">意味アクションとユーザー定義表明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id72">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantic-actions">意味アクション（Semantic Actions）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id73">アクションの遅延実行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id74">アクションの即時実行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id75">遅延関数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id76">ローカル変数を参照する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantic-actions-and-user-defined-assertions-referring-to-non-local-variables">非ローカル変数を参照する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#semantic-actions-and-user-defined-assertions-user-defined-assertions">ユーザー定義表明</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id79">記号表と属性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id80">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id81">記号表</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id83">属性</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id85">地域化と正規表現特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id86">概要</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id87">既定の正規表現特性を設定する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id88">動的正規表現でカスタムの特性を使用する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id89">静的正規表現でカスタムの特性を使用する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#null-regex-traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">null_regex_traits</span></code> で非文字データを検索する</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id90">ヒント集</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id91">パターンのコンパイルは一度とし、再利用せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id92">match_results&lt;&gt; オブジェクトを再利用せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id93">match_results&lt;&gt; オブジェクトを引数に取るアルゴリズムを使用せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#null">null 終端文字列に対してはイテレータの範囲を引数に取るアルゴリズムを使用せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id94">静的正規表現を使用せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regex-constants-syntax-option-type-optimize"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">regex_constants::syntax_option_type::optimize</span></code> を理解せよ</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id95">よくある落とし穴</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id96">文法は単一のスレッドで作成せよ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id97">入れ子の数量子に注意せよ</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id98">コンセプト</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chart">CharT の要件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concepts-traits-requirements">特性の要件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id101">謝辞</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id105">例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#examples-see-if-a-whole-string-matches-a-regex">文字列全体が正規表現にマッチするか調べる</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-see-if-a-string-contains-a-sub-string-that-matches-a-regex">文字列が正規表現にマッチする部分文字列を含むか調べる</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-replace-all-sub-strings-that-match-a-regex">正規表現にマッチした部分文字列をすべて置換する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-find-all-the-sub-strings-that-match-a-regex-and-step-through-them-one-at-a-time">正規表現にマッチする部分文字列をすべて検索し、1 つずつ辿る</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-split-a-string-into-tokens-that-each-match-a-regex">文字列をそれぞれ正規表現にマッチするトークンに分割する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-split-a-string-using-a-regex-as-a-delimiter">正規表現を区切りとして文字列を分割する</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-display-a-tree-of-nested-results">入れ子になった結果木を表示する</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference/index.html">リファレンス</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">謝辞</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">付録</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boost.Xpressive（日本語訳）</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>ユーザーガイド</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/user_s_guide.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>ユーザーガイド<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="contents local topic" id="id2">
<ul class="simple">
<li><p><a class="reference internal" href="#id3" id="id127">はじめに</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id128">xpressive のインストール</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id129">クイックスタート</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id130">正規表現オブジェクトの作成</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id131">マッチと検索</a></p></li>
<li><p><a class="reference internal" href="#id38" id="id132">結果へのアクセス</a></p></li>
<li><p><a class="reference internal" href="#id41" id="id133">文字列の置換</a></p></li>
<li><p><a class="reference internal" href="#id45" id="id134">文字列の分割とトークン分割</a></p></li>
<li><p><a class="reference internal" href="#id55" id="id135">名前付き捕捉</a></p></li>
<li><p><a class="reference internal" href="#id61" id="id136">文法と入れ子マッチ</a></p></li>
<li><p><a class="reference internal" href="#id71" id="id137">意味アクションとユーザー定義表明</a></p></li>
<li><p><a class="reference internal" href="#id79" id="id138">記号表と属性</a></p></li>
<li><p><a class="reference internal" href="#id85" id="id139">地域化と正規表現特性</a></p></li>
<li><p><a class="reference internal" href="#id90" id="id140">ヒント集</a></p></li>
<li><p><a class="reference internal" href="#id98" id="id141">コンセプト</a></p></li>
<li><p><a class="reference internal" href="#id105" id="id142">例</a></p></li>
</ul>
</div>
<p>本節では xpressive を使ったテキスト処理、パース処理の方法を説明する。xpressive の特定のコンポーネントについて詳細な情報を探している場合は、<a class="reference internal" href="reference/index.html"><span class="doc">リファレンス</span></a>の節を見よ。</p>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id127">はじめに</a><a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="xpressive">
<h3>xpressive とは何か<a class="headerlink" href="#xpressive" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive は正規表現のテンプレートライブラリである。正規表現・正規式（regex とも<a class="footnote-reference brackets" href="#id6" id="id4">1</a>）は実行時に動的に解析される文字列としても（動的正規表現）、またはコンパイル時に解析される式テンプレート<a class="footnote-reference brackets" href="#id7" id="id5">2</a> としても（静的正規表現）記述できる。動的正規表現の利点は、実行時にユーザーが入力したり、初期化ファイルから読み取りが可能なことである。静的正規表現には利点がいくつかある。文字列ではなく C++ 式テンプレートなのでコンパイル時に構文チェックを受ける。また、プログラム内のコードとデータを参照可能なので、正規表現マッチの最中にコードを呼び出すこともできる。加えて静的束縛されるので、コンパイラは静的正規表現についてより高速なコードを生成する可能性がある。</p>
<p>xpressive のこの 2 本立ての機能は独特かつ強力である。静的 xpressive は <a class="reference external" href="http://spirit.sourceforge.net/">Spirit パーサフレームワーク</a>のようなものである。<a class="reference external" href="http://spirit.sourceforge.net/">Spirit</a> と同様、式テンプレートを使った静的正規表現で文法を構築できる（<a class="reference external" href="http://spirit.sourceforge.net/">Spirit</a> と異なり、xpressive はパターンマッチを探索するためにあらゆる可能性を試行する網羅的なバックトラックを行う）。動的正規表現は <a class="reference external" href="http://www.boost.org/libs/regex/">Boost.Regex</a> のようなものである。実際、xpressive のインターフェイスは <a class="reference external" href="http://www.boost.org/libs/regex/">Boost.Regex</a> を使ったことのある人にとっては親しみやすいはずである。xpressive の革新的な点は、静的正規表現と動的正規表現を同じプログラム内（同じ式内でも！）で混ぜてマッチできることである。動的正規表現を静的正規表現に組み込むことも<strong>その逆も</strong>可能である。組み込んだ正規表現はパターンマッチに必要な検索やバックトラックに対して完全に機能する。</p>
</div>
<div class="section" id="hello-world">
<h3>Hello, world!<a class="headerlink" href="#hello-world" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>理論は十分だ。xpressive スタイルの Hello World を見よう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span><span class="p">(</span> <span class="s">&quot;hello world!&quot;</span> <span class="p">);</span>

    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">w+) (</span><span class="se">\\</span><span class="s">w+)!&quot;</span> <span class="p">);</span>
    <span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="n">hello</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rex</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// マッチ全体</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1番目の捕捉</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2番目の捕捉</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">hello world!</span>
<span class="go">hello</span>
<span class="go">world</span>
</pre></div>
</div>
<p>このコードでまず注意すべきは、xpressive の型がすべて <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">boost::xpressive</span></code> 名前空間にあるということである。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>本文書における残りのほとんどの例では <code class="code docutils literal notranslate"><span class="pre">using</span> <span class="pre">namespace</span> <span class="pre">boost::xpressive;</span></code> ディレクティブを省略しているが、実際には必要である。</p>
</div>
<p>次に注意すべきは正規表現オブジェクトの型が <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex</span></code> ということである。<a class="reference external" href="http://www.boost.org/libs/regex/">Boost.Regex</a> に馴染んでいるのであれば、今まで使っていたものとは違うという点に気をつけなければならない。「<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex</span></code>」の「s」は「<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">string</span></code>」のことであり、この正規表現は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> オブジェクト内でパターンを探索するのに使用するということを表している。この違いとそれが意味するところについては後で述べる。</p>
<p>正規表現オブジェクトをどのように初期化するかに注目する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">w+) (</span><span class="se">\\</span><span class="s">w+)!&quot;</span> <span class="p">);</span>
</pre></div>
</div>
<p>正規表現オブジェクトを文字列から作成する場合、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::compile</span></code> といったファクトリメソッドを呼び出さなければならない。これもまた、xpressive が他のオブジェクト指向正規表現ライブラリと異なっている点である。他のライブラリでは正規表現は文字列の強化版のような扱いだが、xpressive では正規表現は文字列ではなく、ドメイン固有言語における小さなプログラムである。文字列はそのような言語の表現の 1 つにすぎない。もう1つの表現が式テンプレートである。例えば上のコード行は以下と等価である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>これは同じ正規表現を表しているが、静的 xpressive が定義するドメイン固有の組み込み言語を用いている点が異なる。</p>
<p>見てのとおり、静的正規表現の構文には標準的な Perl の構文と顕著に違う点がある。これは C++ 構文の制約によるもので、最も大きな違いは「後続」を表す <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> の使用である。例えば Perl では部分式を続けて書くことができる。</p>
<div class="highlight-perl notranslate"><div class="highlight"><pre><span></span><span class="n">abc</span>
</pre></div>
</div>
<p>しかし C++ では部分式を分離する演算子がなければならない。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">c</span>
</pre></div>
</div>
<p>Perlでは括弧 <code class="regexp docutils literal notranslate"><span class="pre">()</span></code> は特別な意味をもつ。これらはグループ化を行うが、<code class="regexp docutils literal notranslate"><span class="pre">$1</span></code> や <code class="regexp docutils literal notranslate"><span class="pre">$2</span></code> といった後方参照を作成するという副作用がある。C++ では括弧を多重定義して副作用を与えることはできない。そこで同じ効果を得るために <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> や <a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code></a> という特殊なトークンを使用する。これらに代入を行うことで後方参照を作成する（xpressive では部分マッチ（sub-match）という）。</p>
<p>他に注意すべき点として、1 回以上の繰り返しを表す + 演算子の位置が後置から前置になっているということがある。これは C++ が後置の + 演算子をもたないためである。よって、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;</span><span class="se">\\</span><span class="s">w+&quot;</span>
</pre></div>
</div>
<p>これは以下と同じである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">+</span><span class="n">_w</span>
</pre></div>
</div>
<p>他のすべての違いについては<a class="reference internal" href="grammars.html"><span class="doc">後で</span></a>触れる。</p>
<dl class="footnote brackets">
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id4">1</a></span></dt>
<dd><p>訳注　Regular expression の省略形ですが、翻訳版では省略せず「正規表現」「正規式」と書きます。</p>
</dd>
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id5">2</a></span></dt>
<dd><p><a class="reference external" href="http://www.osl.iu.edu/~tveldhui/papers/Expression-Templates/exprtmpl.html">Expression Templates</a>（英語）を参照。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id9">
<h2><a class="toc-backref" href="#id128">xpressive のインストール</a><a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id10">
<h3>xpressive の入手<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive の入手方法は 2 つある。第 1 のより簡単な方法は Boost の最新版をダウンロードすることである。<a class="reference external" href="http://sf.net/projects/boost">http://sf.net/projects/boost</a> へ行き、“Download” リンクをたどるだけである。</p>
<p>2 番目の方法は Boost の Subversion リポジトリに直接アクセスすることである。<a class="reference external" href="http://svn.boost.org/trac/boost">http://svn.boost.org/trac/boost</a> へ行き、そこにある匿名 Subversion アクセス方法に従うとよい。Boost Subversion にあるのは不安定版である。</p>
</div>
<div class="section" id="id11">
<h3>xpressive を使ったビルド<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive はヘッダのみのテンプレートライブラリであり、あなたのビルドスクリプトを書き直したり個別のライブラリファイルにリンクする必要はない。<code class="code docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;boost/xpressive/xpressive.hpp&gt;</span></code> とするだけでよい。使用するのが静的正規表現だけであれば、<code class="file docutils literal notranslate"><span class="pre">xpressive_static.hpp</span></code> だけをインクルードすることでコンパイル時間を短縮できる。同様に動的正規表現だけを使用するのであれば <code class="file docutils literal notranslate"><span class="pre">xpressive_dynamic.hpp</span></code> をインクルードするとよい。</p>
<p>静的正規表現とともに意味アクションやカスタム表明を使用したければ、<code class="file docutils literal notranslate"><span class="pre">regex_actions.hpp</span></code> も追加でインクルードする必要がある。</p>
</div>
<div class="section" id="id12">
<h3>必要要件<a class="headerlink" href="#id12" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive を使用するには Boost 1.34.1 以降が必要である。</p>
</div>
<div class="section" id="id13">
<h3>サポートするコンパイラ<a class="headerlink" href="#id13" title="このヘッドラインへのパーマリンク">¶</a></h3>
<ul class="simple">
<li><p>Visual C++ 7.1 以降</p></li>
<li><p>GNU C++ 3.4 以降</p></li>
<li><p>Intel for Linux 8.1 以降</p></li>
<li><p>Intel for Windows 10 以降</p></li>
<li><p>tru64cxx 71 以降</p></li>
<li><p>MinGW 3.4 以降</p></li>
<li><p>HP C/C++ A.06.14 以降</p></li>
</ul>
<p>Boost の<a class="reference external" href="http://beta.boost.org/development/tests/trunk/developer/xpressive.html">退行テスト結果のページ</a>にある最新テスト結果を参照するとよい。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>質問、コメント、バグ報告は eric &lt;at&gt; boost-consulting &lt;dot&gt; com に送ってほしい。</p>
</div>
</div>
</div>
<div class="section" id="id15">
<h2><a class="toc-backref" href="#id129">クイックスタート</a><a class="headerlink" href="#id15" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>xpressive で何かするのに知っておくべきことはそう多くない。xpressive が提供する型とアルゴリズムの 5 セント旅行に出かけよう。</p>
<table class="docutils align-default" id="id113">
<caption><span class="caption-text">xpressive のツールボックス</span><a class="headerlink" href="#id113" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>ツール</p></th>
<th class="head"><p>説明</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a></p></td>
<td><p>コンパイル済みの正規表現を保持する。<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> は xpressive で最も重要な型である。xpressive で何かする場合は <a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> 型のオブジェクトを作成することから始める。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 、<a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a></p></td>
<td><p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> は、<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> や <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> 操作の結果を保持する。<a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトのベクタのように振舞う。個別の <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトはマーク済み部分式（Perlにおける後方参照）を保持する。基本的にはマーク済み部分式の開始と終了を表すイテレータの組にすぎない。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a></p></td>
<td><p>文字列が正規表現にマッチするか調べる。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> が成功するのは、文字列全体の先頭から終端までが正規表現にマッチする場合である。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> に <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> を与えると、見つかったマーク済み部分式が書き込まれる。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a></p></td>
<td><p>正規表現にマッチする部分文字列を文字列内で検索する。<a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> は文字列内のあらゆる位置でマッチを検索する。文字列の先頭から開始し、マッチを見つけるか文字列内をすべて走査すると終了する。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> と同様、<a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> に <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> を与えると、見つかったマーク済み部分式が書き込まれる。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a></p></td>
<td><p>入力文字列、正規表現、置換文字列を与えると、<a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> は入力文字列内の正規表現にマッチした部分を置換文字列で置換した新しい文字列を構築する。置換文字列にはマーク済み部分式への参照を含めることができる。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a></p></td>
<td><p>文字列内の正規表現にマッチする位置を見つける STL 互換のイテレータ。<a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> を参照はがしすると <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> が返る。<a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> をインクリメントすると次のマッチを検索する。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a></p></td>
<td><p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> と似ているが、<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を参照はがしすると文字列が返る。既定では正規表現にマッチした部分文字列全体が返るが、一度にいずれかあるいはすべてのマーク済み部分式を 1 つずつ返すように設定することもできる。また、文字列の正規表現にマッチ<strong>しなかった</strong>部分を返すよう設定することもできる。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a></p></td>
<td><p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトのファクトリ。文字列を正規表現に「コンパイル」する。<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> クラスは内部で <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使用するファクトリメソッドをもっているので、大抵の場合 <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を直接取り扱う必要はない。しかし、<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトを異なる <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::locale</span></code> で作成するなど変わったことをする必要がある場合は、<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を明示的に使用しなければならない。</p></td>
</tr>
</tbody>
</table>
<p>xpressive が提供するツール群について少しは分かったと思う。次の 2 つの質問に答えれば正しいツールを選択できるだろう。</p>
<ol class="arabic simple">
<li><p>データを走査するのに使う<strong>イテレータ</strong>の型は何か。</p></li>
<li><p>データを使って何を<strong>したい</strong>のか。</p></li>
</ol>
<div class="section" id="quick-start-know-your-iterator-type">
<span id="id16"></span><h3>イテレータの型<a class="headerlink" href="#quick-start-know-your-iterator-type" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive において、ほとんどのクラスはイテレータ型を引数にもつテンプレートである。正しい型を簡単に選択できるように xpressive は共通の typedef をいくつか定義している。以下の表を見ればイテレータ型から正しい型が分かる。</p>
<table class="docutils align-default" id="id114">
<caption><span class="caption-text">xpressive の typedef とイテレータ型の対応</span><a class="headerlink" href="#id114" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>std::string::const_iterator</p></th>
<th class="head"><p>char const *</p></th>
<th class="head"><p>std::wstring::const_iterator</p></th>
<th class="head"><p>wchar_t const *</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex</span></code></a></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">cregex</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wcregex</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results</span></code></a></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">smatch</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">cmatch</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsmatch</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wcmatch</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler</span></code></a></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex_compiler</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">cregex_compiler</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex_compiler</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wcregex_compiler</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator</span></code></a></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">cregex_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wcregex_iterator</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></a></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex_token_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">cregex_token_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex_token_iterator</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wcregex_token_iterator</span></code></p></td>
</tr>
</tbody>
</table>
<p>機械的な名前付け規約に注意していただきたい。これらの型の多くは一緒に使用するため、名前付け規約は一貫性という点で助けになる。例えば <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sregex</span></code> があれば一緒に使うのは <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">smatch</span></code> という具合である。</p>
<p>これら 4 つのイテレータ型以外については、テンプレートを直接使用しイテレータ型を指定するとよい。</p>
</div>
<div class="section" id="id17">
<h3>タスク<a class="headerlink" href="#id17" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>パターンを使うのは 1 度か、複数回か。検索か置換か。xpressive はこれらをすべてカバーし、他にも多くの機能がある。以下が早見表である。</p>
<table class="docutils align-default" id="id115">
<caption><span class="caption-text">処理とツール</span><a class="headerlink" href="#id115" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>次を行うには…</p></th>
<th class="head"><p>以下を使用せよ</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-see-if-a-whole-string-matches-a-regex"><span class="std std-ref">文字列全体が正規表現にマッチするか調べる</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズム</p></td>
</tr>
<tr class="row-odd"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-see-if-a-string-contains-a-sub-string-that-matches-a-regex"><span class="std std-ref">文字列が正規表現にマッチする部分文字列を含むか調べる</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> アルゴリズム</p></td>
</tr>
<tr class="row-even"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-replace-all-sub-strings-that-match-a-regex"><span class="std std-ref">正規表現にマッチした部分文字列をすべて置換する</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> アルゴリズム</p></td>
</tr>
<tr class="row-odd"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-find-all-the-sub-strings-that-match-a-regex-and-step-through-them-one-at-a-time"><span class="std std-ref">正規表現にマッチする部分文字列をすべて検索し、1 つずつ辿る</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> クラス</p></td>
</tr>
<tr class="row-even"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-split-a-string-into-tokens-that-each-match-a-regex"><span class="std std-ref">文字列をそれぞれ正規表現にマッチするトークンに分割する</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> クラス</p></td>
</tr>
<tr class="row-odd"><td><div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="#examples-split-a-string-using-a-regex-as-a-delimiter"><span class="std std-ref">正規表現を区切りとして文字列を分割する</span></a></p>
</div>
</td>
<td><p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> クラス</p></td>
</tr>
</tbody>
</table>
<p>これらのアルゴリズムとクラスの厄介な詳細はリファレンスの節で述べる。</p>
<div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p>上の表の各処理をクリックすると、xpressive を使った完全なプログラム例が表示される。</p>
</div>
</div>
</div>
<div class="section" id="id18">
<h2><a class="toc-backref" href="#id130">正規表現オブジェクトの作成</a><a class="headerlink" href="#id18" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>xpressive を使う場合、最初に行うのが <a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトの作成である。本節では静的・動的の 2 つの表現方法による正規表現作成の基本を見ていく。</p>
<div class="section" id="id19">
<h3>静的正規表現<a class="headerlink" href="#id19" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="id20">
<h4>概要<a class="headerlink" href="#id20" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>xpressive が他の C/C++ 正規表現ライブラリと一線を画すのは、C++ の式を用いて正規表現を記述する機能による。xpressive は演算子の多重定義と<strong>式テンプレート</strong>という技術を使って、パターンマッチのための小言語を C++ に組み込むことでこれを実現している。これら「静的正規表現」には文字列ベースのものに比較して多くの利点がある。特に以下の点を挙げておく。</p>
<ul class="simple">
<li><p>コンパイル時に構文がチェックされる。実行時に構文エラーで失敗することがない。</p></li>
<li><p>他の C++ データ、コード、他の正規表現を自然に参照できる。正規表現の外部での文法構築、および正規表現マッチの一部として実行されるユーザー定義アクションの束縛が簡単になる。</p></li>
<li><p>静的束縛され、インライン化と最適化が促進される。静的正規表現は状態表、仮想関数、バイトコード、関数ポインタによる呼び出しといったコンパイル時に解決できないものを必要としない。</p></li>
<li><p>検索対象が文字列に限定されない。例えば、数値配列からパターンを探索する静的正規表現を宣言できる。</p></li>
<li><p>静的正規表現の組み立ては C++ の式を使うので、合法な C++ の式規則の制約を受ける。残念ながら、「伝統的な」正規表現構文をすべてきれいに C++ に対応させられるわけではない。そういうわけで、無理な対応は試みず C++ として合法な構文を用意する。</p></li>
</ul>
</div>
<div class="section" id="id21">
<h4>構築と代入<a class="headerlink" href="#id21" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>静的正規表現の作成は、<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> 型のオブジェクトへの代入により行う。例えば、以下は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> 型のオブジェクトに対してパターンを探索する正規表現を定義する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="sc">&#39;$&#39;</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;.&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span><span class="p">;</span>
</pre></div>
</div>
<p>代入の動作も似たようなものである。</p>
</div>
<div class="section" id="id22">
<h4>文字と文字列リテラル<a class="headerlink" href="#id22" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>静的正規表現において、文字と文字列リテラルはそれ自身にマッチする。例えば上の正規表現において <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'$'</span></code> と <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'.'</span></code> は、それぞれ文字 <code class="regexp docutils literal notranslate"><span class="pre">'$'</span></code> 、<code class="regexp docutils literal notranslate"><span class="pre">'.'</span></code> にマッチする。Perlにおいて <code class="regexp docutils literal notranslate"><span class="pre">$</span></code> と <code class="regexp docutils literal notranslate"><span class="pre">.</span></code> がメタ文字であるからといって混乱しないでいただきたい。xpressive ではリテラルは常にそれ自身を表す。</p>
<p>静的正規表現でリテラルを使用する場合は、少なくとも片方のオペランドはリテラル以外であることに注意しなければならない。例えば以下は正しい正規表現では<strong>ない</strong>。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">re1</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span>         <span class="c1">// エラー！</span>
<span class="n">sregex</span> <span class="n">re2</span> <span class="o">=</span> <span class="o">+</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>               <span class="c1">// エラー！</span>
</pre></div>
</div>
<p>二項 <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> 演算子の2つのオペランドが両方ともリテラル、また単項 <code class="code docutils literal notranslate"><span class="pre">+</span></code> 演算子のオペランドもリテラルになっている。よってこれらの文は組み込みの C++ 二項右シフト、単項プラス演算子をそれぞれ呼び出す。これは期待した動作ではない。演算子の多重定義が機能するには、少なくとも 1 つのオペランドがユーザー定義型でなければならない。xpressive の <a class="reference internal" href="reference/as_xpr.html#_CPPv4I0EN5boost9xpressive6as_xprE11unspecifiedRK7Literal" title="boost::xpressive::as_xpr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">as_xpr</span></code></a> ヘルパ関数を使うと式を正規表現の世界に「引き込み」、演算子の多重定義に正しい演算子を見つけるよう強制できる。上の 2 つは次のように書くべきだ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">re1</span> <span class="o">=</span> <span class="n">as_xpr</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span> <span class="c1">// OK</span>
<span class="n">sregex</span> <span class="n">re2</span> <span class="o">=</span> <span class="o">+</span><span class="n">as_xpr</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span>       <span class="c1">// OK</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h4>結合と選択<a class="headerlink" href="#id23" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>すでに見てきたように、静的正規表現における部分式は結合演算子 <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> で分離されていなければならない。この演算子は「～の後に」などと読み替えるとよい。 <a class="footnote-reference brackets" href="#id26" id="id24">3</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 後ろに数字が続く &#39;a&#39; にマッチ</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span><span class="p">;</span>
</pre></div>
</div>
<p>選択（分岐）は <code class="code docutils literal notranslate"><span class="pre">|</span></code> 演算子を使用する。Perl と同様の動作をする。この演算子は「または」などと読み替えるとよい。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1 文字以上の数字、または単語構成文字にマッチ</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="o">|</span> <span class="n">_w</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id25">
<h4>グループ化と捕捉<a class="headerlink" href="#id25" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Perl では括弧 <code class="code docutils literal notranslate"><span class="pre">()</span></code> は特別な意味をもつ。これらはグループ化を行うが、<code class="code docutils literal notranslate"><span class="pre">$1</span></code> や <code class="code docutils literal notranslate"><span class="pre">$2</span></code> といった後方参照を作成するという副作用がある。C++ では括弧を多重定義して副作用を与えることはできない。そこで同じ効果を得るために <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> や <a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code></a> という特殊なトークンを使用する。これらに代入を行うことで後方参照を作成する。後方参照は Perl の <code class="code docutils literal notranslate"><span class="pre">\\1</span></code> や <code class="code docutils literal notranslate"><span class="pre">\\2</span></code> のような使い方で式中で使用できる。例えば以下の HTML タグのマッチを探索する正規表現を考えよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="s">&quot;&lt;(</span><span class="se">\\</span><span class="s">w+)&gt;.*?&lt;/</span><span class="se">\\</span><span class="s">1&gt;&quot;</span>
</pre></div>
</div>
<p>静的正規表現では、次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="sc">&#39;&lt;&#39;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;&gt;&#39;</span> <span class="o">&gt;&gt;</span> <span class="o">-*</span><span class="n">_</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;&lt;/&quot;</span> <span class="o">&gt;&gt;</span> <span class="n">s1</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;&gt;&#39;</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> への代入により後方参照を捕捉し、パターンの後ろのほうでマッチする終了タグを探索するのに <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> を使っていることに注意していただきたい。</p>
<div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p>後方参照を捕捉せずにグループ化けを行う</p>
<ul class="simple">
<li><p>xpressive では、後方参照を捕捉せずにグループ化を行うには <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> なしで <code class="code docutils literal notranslate"><span class="pre">()</span></code> を使うだけでよい。これは Perl の捕捉なしのグループ化構造 <code class="regexp docutils literal notranslate"><span class="pre">(?:)</span></code> と等価である。</p></li>
</ul>
</div>
<dl class="footnote brackets">
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id24">3</a></span></dt>
<dd><p>訳注　原文は “followed by”。無理に日本語にしないほうがいいかもしれません…。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id27">
<h3>動的正規表現<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="id28">
<h4>概要<a class="headerlink" href="#id28" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>静的正規表現は一級品だが、ときにはもっと別の…、つまり動的正規表現が必要な場合もある。正規表現検索・置換機能を備えたテキストエディタを開発中だとしよう。正規表現は、実行時にエンドユーザーからの入力として受け付けなければならない。文字列を正規表現に解析する方法が必要であり、xpressive の動的正規表現がそれに相当する。これらは静的正規表現と同じコアコンポーネントから構築するが、遅延束縛のため実行時にパターンを指定できる。</p>
</div>
<div class="section" id="id29">
<h4>構築と代入<a class="headerlink" href="#id29" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>動的正規表現を作成する方法は2つある。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::compile</span></code> 関数によるものと <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> クラステンプレートによるものである。既定のロカールでよければ <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::compile</span></code> を使うとよい。別のロカールを指定する必要がある場合は、<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使用する。<a class="reference internal" href="grammars.html"><span class="doc">正規表現文法</span></a>の節で、<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> の他の使用について述べる。</p>
<p>以下は <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::compile</span></code> の使用例である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;this|that&quot;</span><span class="p">,</span> <span class="n">regex_constants</span><span class="o">::</span><span class="n">icase</span> <span class="p">);</span>
</pre></div>
</div>
<p>以下は <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使った同じ例である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex_compiler</span> <span class="n">compiler</span><span class="p">;</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;this|that&quot;</span><span class="p">,</span> <span class="n">regex_constants</span><span class="o">::</span><span class="n">icase</span> <span class="p">);</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::compile</span></code> は <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler</span></code></a> を使って実装している。</p>
</div>
<div class="section" id="id30">
<h4>動的 xpressive の構文<a class="headerlink" href="#id30" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>動的構文は合法な C++ の式規則による制約を受けないので、動的正規表現については慣れ親しんだ構文が使える。そういうわけで動的正規表現については xpressive は、正規表現を標準ライブラリに追加することになった John Maddock の<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">草案</a>に従った。本質的には <a class="reference external" href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMAScript</a> により標準化された構文であり、国際化のための細かい変更を加えてある。</p>
<p>構文の網羅的な文書は他にあるので、ここでは仕様の複製はせず、既存の標準を参照するにとどめる。</p>
</div>
<div class="section" id="id32">
<h4>国際化<a class="headerlink" href="#id32" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>静的正規表現と同様、動的正規表現の国際化サポートは別の <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::locale</span></code> を指定することによる。これを行うには <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使用しなければならない。<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> クラスは <a class="reference internal" href="reference/imbue.html#_CPPv4I0EN5boost9xpressive5imbueERK6Locale" title="boost::xpressive::imbue"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">imbue</span></code></a> 関数をもつ。<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> オブジェクトに対してカスタムの <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::locale</span></code> を使って <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">imbue</span></code> を呼び出すと、それ以降に <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> でコンパイルした正規表現オブジェクトはそのロカールを使用するようになる。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">my_locale</span> <span class="o">=</span> <span class="cm">/* ここでロカールオブジェクトを初期化する */</span><span class="p">;</span>
<span class="n">sregex_compiler</span> <span class="n">compiler</span><span class="p">;</span>
<span class="n">compiler</span><span class="p">.</span><span class="n">imbue</span><span class="p">(</span> <span class="n">my_locale</span> <span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">w+|</span><span class="se">\\</span><span class="s">d+&quot;</span> <span class="p">);</span>
</pre></div>
</div>
<p>この正規表現は、組み込みの文字集合 <code class="regexp docutils literal notranslate"><span class="pre">\w</span></code> および <code class="regexp docutils literal notranslate"><span class="pre">\d</span></code> を処理するのに <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">my_locale</span></code> を使用する。</p>
</div>
</div>
</div>
<div class="section" id="id33">
<h2><a class="toc-backref" href="#id131">マッチと検索</a><a class="headerlink" href="#id33" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id34">
<h3>概要<a class="headerlink" href="#id34" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現オブジェクトの作成が終わったら、<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> および <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> アルゴリズムで文字列からパターンを検索する。本節では正規表現のマッチと検索の基本について述べる。<a class="reference external" href="http://www.boost.org/libs/regex/">Boost.Regex</a> ライブラリの <a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> および <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> の振る舞いについて理解しているなら、xpressive 版でも同様の動作をすると考えてよい。</p>
</div>
<div class="section" id="id36">
<h3>文字列が正規表現にマッチするか調べる<a class="headerlink" href="#id36" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムは正規表現が与えられた入力にマッチするか調べる。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムは、正規表現が入力全体の先頭から終端までマッチした場合のみ成功する。正規表現が入力の一部分だけにマッチする場合は <a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> は偽を返す。文字列から正規表現にマッチする部分文字列を探す場合は、<a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> アルゴリズムを使うとよい。</p>
</div>
<p>入力は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code>、C 形式の null 終端文字列、イテレータの組といった双方向範囲である。いずれの場合でも、入力シーケンスを走査するイテレータ型は正規表現オブジェクトの宣言に使用したイテレータ型と一致していなければならない（イテレータに対する正しい正規表現の型は、<a class="reference internal" href="#quick-start-know-your-iterator-type"><span class="std std-ref">クイックスタート</span></a>の表を見れば分かる）。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cregex</span> <span class="n">cre</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">;</span>  <span class="c1">// C 形式の文字列にマッチ</span>
<span class="n">sregex</span> <span class="n">sre</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">;</span>  <span class="c1">// std::string にマッチ</span>

<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">cre</span> <span class="p">)</span> <span class="p">)</span>              <span class="c1">// OK</span>
    <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span> <span class="n">sre</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">// OK</span>
    <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">sre</span> <span class="p">)</span> <span class="p">)</span>              <span class="c1">// エラー！ イテレータが一致していない！</span>
    <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムは省略可能な出力引数として <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体を受け付ける。この引数が与えられると、<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムは正規表現のどの部分が入力のどの部分にマッチしたかの情報を <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体に書き込む。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cmatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">cregex</span> <span class="n">cre</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="n">_w</span><span class="p">);</span>

<span class="c1">// regex_match の結果を &quot;what&quot; に格納する</span>
<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">cre</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// &quot;o&quot; を印字する</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムはさらに省略可能な引数として <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_typeE" title="boost::xpressive::regex_constants::match_flag_type"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">match_flag_type</span></code></a> ビットマスクを受け付ける。<a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_typeE" title="boost::xpressive::regex_constants::match_flag_type"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">match_flag_type</span></code></a> を与えると、マッチをどのように行うかある程度制御できる。このフラグの完全なリストと意味については <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_typeE" title="boost::xpressive::regex_constants::match_flag_type"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">match_flag_type</span></code></a> のリファレンスを見よ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">sre</span> <span class="o">=</span> <span class="n">bol</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span><span class="p">;</span>

<span class="c1">// match_not_bol の意味は、「&quot;bol&quot;（行頭）は [begin,begin) にマッチしない」</span>
<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">sre</span><span class="p">,</span> <span class="n">regex_constants</span><span class="o">::</span><span class="n">match_not_bol</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ここには絶対にこない！</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> の使い方に関する完全なプログラム例は<a class="reference internal" href="#examples-see-if-a-whole-string-matches-a-regex"><span class="std std-ref">ここ</span></a>にある。利用可能な多重定義の完全なリストは <a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> のリファレンスを見よ。</p>
</div>
<div class="section" id="id37">
<h3>部分文字列のマッチを検索する<a class="headerlink" href="#id37" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入力シーケンスに正規表現にマッチする部分シーケンスが含まれているか調べるには <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> を使用する。<a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> は入力シーケンスの先頭で正規表現マッチを試行し、マッチを見つけるかシーケンスの終端に到達するまでシーケンスを走査する。</p>
<p>その他のすべての面で <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> の動作は <a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> と似たようなものである（上を見よ）。<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> 、C 形式の null 終端文字列、イテレータの範囲といった双方向範囲を取り扱うという点が特にそうである。正規表現のイテレータ型と入力シーケンスの型を一致させなければならない、ということについても同様の注意が必要である。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> と同様、<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体を与えて検索結果を受け取ったり、<a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_typeE" title="boost::xpressive::regex_constants::match_flag_type"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">match_flag_type</span></code></a> ビットマスクを使ってマッチをどのように行うかを制御できる。</p>
<p><a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> の使い方に関する完全なプログラム例は<a class="reference internal" href="#examples-see-if-a-string-contains-a-sub-string-that-matches-a-regex"><span class="std std-ref">ここ</span></a>にある。利用可能な多重定義の完全なリストは <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> のリファレンスを見よ。</p>
</div>
</div>
<div class="section" id="id38">
<h2><a class="toc-backref" href="#id132">結果へのアクセス</a><a class="headerlink" href="#id38" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id39">
<h3>概要<a class="headerlink" href="#id39" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> および <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> の成否が分かるだけでは十分でない場合もある。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> 、<a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> に <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 型のオブジェクトを渡すと、アルゴリズムが完全に成功した後 <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> に、正規表現のどの部分がシーケンスのどの部分にマッチしたかの追加情報が入る。Perl ではこれらの部分シーケンスを<strong>後方参照</strong>といい、変数 <code class="docutils literal notranslate"><span class="pre">$1</span></code> 、<code class="docutils literal notranslate"><span class="pre">$2</span></code> 、…に格納される。xpressive では <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> 型のオブジェクトであり、<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体に格納される。これらは <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトのベクタとして振舞う。</p>
</div>
<div class="section" id="match-results">
<h3>match_results<a class="headerlink" href="#match-results" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>さて、正規表現アルゴリズムに <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを渡し、アルゴリズムが成功したとする。結果を調べたくなるところだ。<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを使ってすることといえば、その内部に格納されている <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトへ添字を介してアクセスすることがほとんどである。しかし <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトには他にも少し使い道がある。</p>
<p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">what</span></code> という名前の <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトに格納されている情報にアクセスする方法を以下の表に示す。</p>
<table class="docutils align-default" id="id116">
<caption><span class="caption-text">match_results&lt;&gt; のアクセス子</span><a class="headerlink" href="#id116" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>アクセス子</p></th>
<th class="head"><p>効果</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">size</span><span class="pre">(</span><span class="pre">)</span></code></p></td>
<td><p>部分マッチの総数を返す。マッチ全体は 0 番目の部分マッチとして格納されるため、アルゴリズムが成功した場合は結果は常に 0 より大きい。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">[</span><span class="pre">n</span><span class="pre">]</span></code></p></td>
<td><p>n 番目の部分マッチを返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">length</span><span class="pre">(</span><span class="pre">n</span><span class="pre">)</span></code></p></td>
<td><p>n 番目の部分マッチの長さを返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">[</span><span class="pre">n</span><span class="pre">]</span><span class="pre">.</span><span class="pre">length</span><span class="pre">(</span><span class="pre">)</span></code> と同じ。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">str</span><span class="pre">(</span><span class="pre">n</span><span class="pre">)</span></code></p></td>
<td><p>n 番目の部分マッチから構築した <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::basic_string&lt;&gt;</span></code> を返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">[</span><span class="pre">n</span><span class="pre">]</span><span class="pre">.</span><span class="pre">str</span><span class="pre">(</span><span class="pre">)</span></code> と同じ。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">prefix</span></code></p></td>
<td><p>入力シーケンスの先頭から全体マッチ先頭までの部分シーケンスを表す <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトを返す。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">suffix</span></code></p></td>
<td><p>全体マッチの終端から入力シーケンスの終端までの部分シーケンスを表す <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトを返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">what</span><span class="pre">.</span><span class="pre">regex_id</span><span class="pre">(</span><span class="pre">)</span></code></p></td>
<td><p>この <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトで最後に使用した <a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトの <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">regex_id</span></code> を返す。</p></td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトには他にも使い道があるが、<a class="reference internal" href="grammars.html"><span class="doc">文法と入れ子マッチ</span></a>の項であらためて述べることにする。</p>
</div>
<div class="section" id="sub-match">
<h3>sub_match<a class="headerlink" href="#sub-match" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトに添字を介してアクセスすると <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトが得られる。<a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> は基本的にはイテレータの組である。定義は以下のようになっている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">BidirectionalIterator</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">sub_match</span>
    <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span> <span class="n">BidirectionalIterator</span><span class="p">,</span> <span class="n">BidirectionalIterator</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">matched</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::pair&lt;&gt;</span></code> を公開継承しているため、<a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">BidirectionalIterator</span></code> 型の <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">first</span></code> および <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">second</span></code> データメンバをもつ。これらは、この <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> が表す部分シーケンスの先頭と終端である。また <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> は論理型の <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">matched</span></code> データメンバをもち、この <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> が完全マッチに関与する場合に真となる。</p>
<p>名前を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">sub</span></code> とした場合の、<a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> オブジェクトに格納されている情報にアクセスする方法を以下の表に示す。</p>
<table class="docutils align-default" id="id117">
<caption><span class="caption-text">sub_match&lt;&gt; アクセス子</span><a class="headerlink" href="#id117" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>アクセス子</p></th>
<th class="head"><p>効果</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">sub</span><span class="pre">.</span><span class="pre">length</span><span class="pre">(</span><span class="pre">)</span></code></p></td>
<td><p>部分マッチの長さを返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">std</span><span class="pre">::</span><span class="pre">distance</span><span class="pre">(</span><span class="pre">sub</span><span class="pre">.</span><span class="pre">first</span><span class="pre">,</span> <span class="pre">sub</span><span class="pre">.</span><span class="pre">second</span><span class="pre">)</span></code> と同じ。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">sub</span><span class="pre">.</span><span class="pre">str</span><span class="pre">(</span><span class="pre">)</span></code></p></td>
<td><p>部分マッチから構築した <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::basic_string&lt;&gt;</span></code> を返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">std</span><span class="pre">::</span><span class="pre">basic</span><span class="pre">&lt;</span><span class="pre">char_type</span><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">sub</span><span class="pre">.</span><span class="pre">first</span><span class="pre">,</span> <span class="pre">sub</span><span class="pre">.</span><span class="pre">second</span><span class="pre">)</span></code> と同じ。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">sub</span><span class="pre">.</span><span class="pre">compare</span><span class="pre">(</span><a class="reference internal" href="reference/str.html#_CPPv4N5boost9xpressive3strE" title="boost::xpressive::str"><span class="pre">str</span></a><span class="pre">)</span></code></p></td>
<td><p>部分マッチと <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">str</span></code> の文字列比較を行う。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">str</span></code> は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::basic_string&lt;&gt;</span></code> 、C 形式の null 終端文字列、別の部分マッチのいずれでもよい。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">sub</span><span class="pre">.</span><span class="pre">str</span><span class="pre">(</span><span class="pre">)</span><span class="pre">.</span><span class="pre">compare</span><span class="pre">(</span><a class="reference internal" href="reference/str.html#_CPPv4N5boost9xpressive3strE" title="boost::xpressive::str"><span class="pre">str</span></a><span class="pre">)</span></code> と同じ。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id40">
<h3>効果の無効化<a class="headerlink" href="#id40" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>結果は入力シーケンス内のイテレータとして格納される。入力シーケンスが無効になるとマッチ結果もまた無効となる。例えば <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::string</span></code> オブジェクトに対してマッチを行った場合、結果が有効なのは、次にその <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::string</span></code> オブジェクトの非 const メンバ関数を呼び出すまでの間だけである。それ以降は <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトに格納されている結果は無効となるため、使用してはならない。</p>
</div>
</div>
<div class="section" id="id41">
<h2><a class="toc-backref" href="#id133">文字列の置換</a><a class="headerlink" href="#id41" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正規表現が威力を発揮するのはテキスト検索のときだけではない。テキストの<strong>操作</strong>においても有効である。最もありふれたテキスト操作の 1 つが、「検索して置換」である。xpressive は検索と置換のために <a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> アルゴリズムを提供する。</p>
<div class="section" id="regex-replace">
<h3>regex_replace()<a class="headerlink" href="#regex-replace" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> を用いた「検索して置換」処理は簡単である。必要なのは入力シーケンス、正規表現オブジェクト、および書式化文字列か書式化オブジェクトだけである。<a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> には複数のバージョンがあり、入力シーケンスを <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> のような双方向コンテナとして受け付けて結果を同じ型の新しいコンテナで返すものや、入力を null 終端文字列で受け付けて <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::string</span></code> を返すもの、イテレータの組で受け付けて結果を出力イテレータに書き込むものがある。置換は書式化シーケンスを含む文字列か書式化オブジェクトで指定する。文字列ベースの置換について、単純な使用例を以下に示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;This is his face&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">as_xpr</span><span class="p">(</span><span class="s">&quot;his&quot;</span><span class="p">);</span>                <span class="c1">// &quot;his&quot; をすべて検索し、...</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;her&quot;</span><span class="p">);</span>                <span class="c1">// ... &quot;her&quot; で置換する</span>

<span class="c1">// regex_replace() の対文字列版を使用</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span> <span class="n">input</span><span class="p">,</span> <span class="n">re</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

<span class="c1">// regex_replace() の対イテレータ版を使用</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span> <span class="kt">char</span> <span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="p">);</span>
<span class="n">regex_replace</span><span class="p">(</span> <span class="n">out_iter</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">re</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
</pre></div>
</div>
<p>上のプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Ther is her face</span>
<span class="go">Ther is her face</span>
</pre></div>
</div>
<p><code class="code docutils literal notranslate"><span class="pre">&quot;his&quot;</span></code> が<strong>すべて</strong> <code class="code docutils literal notranslate"><span class="pre">&quot;her&quot;</span></code> に置換されることに注意していただきたい。</p>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> の使い方に関する完全なプログラム例は<a class="reference internal" href="#examples-replace-all-sub-strings-that-match-a-regex"><span class="std std-ref">ここ</span></a>にある。利用可能な多重定義の完全なリストは <a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> のリファレンスを見よ。</p>
</div>
<div class="section" id="id42">
<h3>置換のオプション<a class="headerlink" href="#id42" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> アルゴリズムは、省略可能なビットマスク引数により書式化を制御する。使用可能なビットマスク値を以下に示す。</p>
<table class="docutils align-default" id="id118">
<caption><span class="caption-text">書式化フラグ</span><a class="headerlink" href="#id118" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>フラグ</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type14format_defaultE" title="boost::xpressive::regex_constants::match_flag_type::format_default"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_default</span></code></a></p></td>
<td><p>ECMA-262 の書式化シーケンスを使用する（後述）。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type17format_first_onlyE" title="boost::xpressive::regex_constants::match_flag_type::format_first_only"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_first_only</span></code></a></p></td>
<td><p>すべてのマッチの中で最初のものだけを置換する。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type14format_no_copyE" title="boost::xpressive::regex_constants::match_flag_type::format_no_copy"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_no_copy</span></code></a></p></td>
<td><p>入力シーケンス内の、正規表現にマッチしなかった部分を出力シーケンスにコピーしない。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type14format_literalE" title="boost::xpressive::regex_constants::match_flag_type::format_literal"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_literal</span></code></a></p></td>
<td><p>書式化文字列をリテラル（即値）として扱う。エスケープシーケンスを一切解釈しなくなる。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type11format_perlE" title="boost::xpressive::regex_constants::match_flag_type::format_perl"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_perl</span></code></a></p></td>
<td><p>Perl の書式化シーケンスを使用する（後述）。</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_sedE" title="boost::xpressive::regex_constants::match_flag_type::format_sed"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_sed</span></code></a></p></td>
<td><p>sed の書式化シーケンスを使用する（後述）。</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_allE" title="boost::xpressive::regex_constants::match_flag_type::format_all"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_all</span></code></a></p></td>
<td><p>Perl の書式化シーケンス、および Boost 固有の書式化シーケンスを使用する。</p></td>
</tr>
</tbody>
</table>
<p>これらのフラグは <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">xpressive::regex_constants</span></code> 名前空間内にある。置換の引数が文字列ではなく関数オブジェクトである場合は、<a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type14format_literalE" title="boost::xpressive::regex_constants::match_flag_type::format_literal"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_literal</span></code></a> 、<a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type11format_perlE" title="boost::xpressive::regex_constants::match_flag_type::format_perl"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_perl</span></code></a> 、<a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_sedE" title="boost::xpressive::regex_constants::match_flag_type::format_sed"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_sed</span></code></a> および <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_allE" title="boost::xpressive::regex_constants::match_flag_type::format_all"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_all</span></code></a> は無視される。</p>
</div>
<div class="section" id="ecma-262">
<h3>ECMA-262 書式化シーケンス<a class="headerlink" href="#ecma-262" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上記のフラグを指定せずに書式化文字列を渡した場合は、ECMAScript の標準である ECMA-262 の定義が使われる。ECMA-262 モードで使用するエスケープシーケンスを以下に示す。</p>
<table class="docutils align-default" id="id119">
<caption><span class="caption-text">書式化エスケープシーケンス</span><a class="headerlink" href="#id119" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>エスケープシーケンス</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$1</span></code> 、<code class="regex-substitution docutils literal notranslate"><span class="pre">$2</span></code> 、…</p></td>
<td><p>部分マッチ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>マッチ全体</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$`</span></code></p></td>
<td><p>マッチの前</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$'</span></code></p></td>
<td><p>マッチの後</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$$</span></code></p></td>
<td><p>リテラルの文字 <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'$'</span></code></p></td>
</tr>
</tbody>
</table>
<p>その他、<code class="regex-substitution docutils literal notranslate"><span class="pre">$</span></code> で始まるシーケンスは、単純にそれ自身を表す。例えば書式化文字列が <code class="regex-substitution docutils literal notranslate"><span class="pre">$a</span></code> であれば、出力シーケンスに「$a」が挿入される。</p>
</div>
<div class="section" id="sed">
<h3>sed 書式化シーケンス<a class="headerlink" href="#sed" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> に <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_sedE" title="boost::xpressive::regex_constants::match_flag_type::format_sed"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_sed</span></code></a> フラグを指定した場合に使用するエスケープシーケンスを以下に示す。</p>
<table class="docutils align-default" id="id120">
<caption><span class="caption-text">sed 書式化エスケープシーケンス</span><a class="headerlink" href="#id120" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>エスケープシーケンス</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">1</span></code> 、<code class="regex-substitution docutils literal notranslate"><span class="pre">2</span></code> 、…</p></td>
<td><p>部分マッチ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>マッチ全体</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">char_type</span><span class="pre">(</span><span class="pre">27</span><span class="pre">)</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'n'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">r</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">t</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'t'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">v</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'v'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">xFF</span></code></p></td>
<td><p>リテラルの <code class="samp docutils literal notranslate"><span class="pre">char_type(0x</span><em><span class="pre">FF</span></em><span class="pre">)</span></code>。<code class="samp docutils literal notranslate"><em><span class="pre">F</span></em></code> は 16 進数字</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">x{FFFF}</span></code></p></td>
<td><p>リテラルの <code class="samp docutils literal notranslate"><span class="pre">char_type(0x</span><em><span class="pre">FFFF</span></em><span class="pre">)</span></code>。<code class="samp docutils literal notranslate"><em><span class="pre">F</span></em></code> は 16 進数字&lt;/td&gt;</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">cX</span></code></p></td>
<td><p>制御文字 <code class="samp docutils literal notranslate"><em><span class="pre">X</span></em></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="perl">
<h3>Perl 書式化シーケンス<a class="headerlink" href="#perl" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> に <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type11format_perlE" title="boost::xpressive::regex_constants::match_flag_type::format_perl"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_perl</span></code></a> フラグを指定した場合に使用するエスケープシーケンスを以下に示す。</p>
<table class="docutils align-default" id="id121">
<caption><span class="caption-text">Perl 書式化エスケープシーケンス</span><a class="headerlink" href="#id121" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>エスケープシーケンス</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$1</span></code> 、<code class="regex-substitution docutils literal notranslate"><span class="pre">$2</span></code> 、…</p></td>
<td><p>部分マッチ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">&amp;</span></code></p></td>
<td><p>マッチ全体</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$`</span></code></p></td>
<td><p>マッチの前</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$'</span></code></p></td>
<td><p>マッチの後</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">$$</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'$'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'a'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">e</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">char_type</span><span class="pre">(</span><span class="pre">27</span><span class="pre">)</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">f</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'f'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">n</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'n'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">r</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'r'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">t</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'t'</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">v</span></code></p></td>
<td><p>リテラルの <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">'v'</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">xFF</span></code></p></td>
<td><p>リテラルの <code class="samp docutils literal notranslate"><span class="pre">char_type(0x</span><em><span class="pre">FF</span></em><span class="pre">)</span></code>。<code class="samp docutils literal notranslate"><em><span class="pre">F</span></em></code> は 16 進数字</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">x{FFFF}</span></code></p></td>
<td><p>リテラルの <code class="samp docutils literal notranslate"><span class="pre">char_type(0x</span><em><span class="pre">FFFF</span></em><span class="pre">)</span></code>。<code class="samp docutils literal notranslate"><em><span class="pre">F</span></em></code> は 16 進数字</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">cX</span></code></p></td>
<td><p>制御文字 <code class="samp docutils literal notranslate"><em><span class="pre">X</span></em></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">l</span></code></p></td>
<td><p>次の文字を小文字にする</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">L</span></code></p></td>
<td><p>次に <code class="docutils literal notranslate"><span class="pre">\E</span></code> が現れるまで残りの置換を小文字にする</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">u</span></code></p></td>
<td><p>次の文字を大文字にする</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">U</span></code></p></td>
<td><p>次に <code class="docutils literal notranslate"><span class="pre">\E</span></code> が現れるまで残りの置換を大文字にする</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">E</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">\L</span></code> 、<code class="docutils literal notranslate"><span class="pre">\U</span></code> の効果を終了する</p></td>
</tr>
<tr class="row-even"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">1</span></code> 、<code class="regex-substitution docutils literal notranslate"><span class="pre">2</span></code> 、…</p></td>
<td><p>部分マッチ</p></td>
</tr>
<tr class="row-odd"><td><p><code class="regex-substitution docutils literal notranslate"><span class="pre">g&lt;name&gt;</span></code></p></td>
<td><p>名前付き後方参照 <code class="samp docutils literal notranslate"><em><span class="pre">name</span></em></code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="boost">
<h3>Boost 固有の書式化シーケンス<a class="headerlink" href="#boost" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> に <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type10format_allE" title="boost::xpressive::regex_constants::match_flag_type::format_all"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_all</span></code></a> を指定した場合に使用するエスケープシーケンスは上に挙げた <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type11format_perlE" title="boost::xpressive::regex_constants::match_flag_type::format_perl"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_perl</span></code></a> と同じである。さらに以下の形式の条件式を使用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">?</span><span class="n">Ntrue</span><span class="o">-</span><span class="nl">expression</span><span class="p">:</span><span class="nb">false</span><span class="o">-</span><span class="n">expression</span>
</pre></div>
</div>
<p>N は部分マッチを表す 10 進数字である。この部分マッチがマッチ全体に含まれる場合は置換は true-expression となり、それ以外の場合は false-expression となる。このモードでは括弧 <code class="regexp docutils literal notranslate"><span class="pre">()</span></code> でグループ化を行う。リテラルの括弧は <code class="regexp docutils literal notranslate"><span class="pre">(</span></code> のようにエスケープが必要である。</p>
</div>
<div class="section" id="id43">
<h3>書式化オブジェクト<a class="headerlink" href="#id43" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>テキスト置換において、書式化文字列の表現能力が常に十分とは限らない。入力文字列を環境変数で置換して出力文字列にコピーする単純な例を考えよう。こういう場合は、書式化<strong>文字列</strong>ではなく書式化<strong>オブジェクト</strong>を使ったほうがよい。次のコードを考えよう。<code class="regex-input docutils literal notranslate"><span class="pre">$(xyz)</span></code> の形式で埋め込まれた環境変数を検索し、辞書に照らし合わせて見つかった置換文字列を算出する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">xpressive</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">env</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">format_fun</span><span class="p">(</span><span class="n">smatch</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">what</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">env</span><span class="p">[</span><span class="n">what</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">str</span><span class="p">()];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">env</span><span class="p">[</span><span class="s">&quot;X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;this&quot;</span><span class="p">;</span>
    <span class="n">env</span><span class="p">[</span><span class="s">&quot;Y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;that&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">$(X)</span><span class="se">\&quot;</span><span class="s"> has the value </span><span class="se">\&quot;</span><span class="s">$(Y)</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="c1">// &quot;$(XYZ)&quot; のような文字列を検索し、env[&quot;XYZ&quot;] の結果で置換する</span>
    <span class="n">sregex</span> <span class="n">envar</span> <span class="o">=</span> <span class="s">&quot;$(&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">envar</span><span class="p">,</span> <span class="n">format_fun</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合、関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">format_fun</span></code> を使って置換文字列をその場で算出している。この関数は現在のマッチ結果が入った <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを受け取る。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">format_fun</span></code> は「1 番目の部分マッチ」をグローバルな <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">env</span></code> 辞書のキーに使っている。上記コードは次を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">&quot;this&quot; has the value &quot;that&quot;</span>
</pre></div>
</div>
<p>書式化オブジェクトは単純な関数である必要はなく、クラス型のオブジェクトでもよい。また文字列を返す以外に、出力イテレータに置換結果を書き込んでもよい。以下は上記と機能的に等価なコードである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">xpressive</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">formatter</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">env_map</span><span class="p">;</span>
    <span class="n">env_map</span> <span class="n">env</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Out</span><span class="o">&gt;</span>
    <span class="n">Out</span> <span class="k">operator</span><span class="p">()(</span><span class="n">smatch</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">what</span><span class="p">,</span> <span class="n">Out</span> <span class="n">out</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">env_map</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">where</span> <span class="o">=</span> <span class="n">env</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">what</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">where</span> <span class="o">!=</span> <span class="n">env</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">sub</span> <span class="o">=</span> <span class="n">where</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sub</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">out</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">formatter</span> <span class="n">fmt</span><span class="p">;</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">env</span><span class="p">[</span><span class="s">&quot;X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;this&quot;</span><span class="p">;</span>
    <span class="n">fmt</span><span class="p">.</span><span class="n">env</span><span class="p">[</span><span class="s">&quot;Y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;that&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">$(X)</span><span class="se">\&quot;</span><span class="s"> has the value </span><span class="se">\&quot;</span><span class="s">$(Y)</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">sregex</span> <span class="n">envar</span> <span class="o">=</span> <span class="s">&quot;$(&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">envar</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>書式化オブジェクトは、シグニチャが以下の表に示す 3 種類のどれか 1 つである呼び出し可能オブジェクト（関数か関数オブジェクト）でなければならない。表中の <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">fmt</span></code> は関数ポインタか関数オブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">what</span></code> は <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">out</span></code> は OutputIterator 、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">flags</span></code> は <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_typeE" title="boost::xpressive::regex_constants::match_flag_type"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">regex_constants::match_flag_type</span></code></a> の値である。</p>
<table class="docutils align-default" id="id122">
<caption><span class="caption-text">書式化オブジェクトのシグニチャ</span><a class="headerlink" href="#id122" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>書式化オブジェクトの呼び出し</p></th>
<th class="head"><p>戻り値の型</p></th>
<th class="head"><p>意味</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">fmt</span><span class="pre">(</span><span class="pre">what</span><span class="pre">)</span></code></p></td>
<td><p>文字の範囲（<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::string</span></code> など）か null 終端文字列</p></td>
<td><p>正規表現にマッチした文字列を書式化オブジェクトが返した文字列で置換する。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">fmt</span><span class="pre">(</span><span class="pre">what</span><span class="pre">,</span> <span class="pre">out</span><span class="pre">)</span></code></p></td>
<td><p>OutputIterator</p></td>
<td><p>書式化オブジェクトは置換文字列を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">out</span></code> に書き込み、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">out</span></code> を返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">fmt</span><span class="pre">(</span><span class="pre">what</span><span class="pre">,</span> <span class="pre">out</span><span class="pre">,</span> <span class="pre">flags</span><span class="pre">)</span></code></p></td>
<td><p>OutputIterator</p></td>
<td><p>書式化オブジェクトは置換文字列を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">out</span></code> に書き込み、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">out</span></code> を返す。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">flags</span></code> 引数は <a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> アルゴリズムに渡したマッチフラグの値。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id44">
<h3>書式化式<a class="headerlink" href="#id44" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>書式化<strong>文字列</strong>、書式化<strong>オブジェクト</strong>に加えて、<a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> は書式化<strong>式</strong>も受け付ける。書式化式は文字列を生成するラムダ式である。使用する構文は後述する<a class="reference internal" href="actions.html"><span class="doc">意味アクション</span></a>と同じである。文字列を <a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> を用いて環境変数で置換する上の例を書式化式を使って書き直すと、次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/regex_actions.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">env</span><span class="p">;</span>
    <span class="n">env</span><span class="p">[</span><span class="s">&quot;X&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;this&quot;</span><span class="p">;</span>
    <span class="n">env</span><span class="p">[</span><span class="s">&quot;Y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;that&quot;</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">$(X)</span><span class="se">\&quot;</span><span class="s"> has the value </span><span class="se">\&quot;</span><span class="s">$(Y)</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="n">sregex</span> <span class="n">envar</span> <span class="o">=</span> <span class="s">&quot;$(&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s1</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">envar</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">env</span><span class="p">)[</span><span class="n">s1</span><span class="p">]);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">output</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上のコードの <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">env</span><span class="pre">)</span><span class="pre">[</span><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><span class="pre">s1</span></a><span class="pre">]</span></code> が書式化式で、1 番目の部分マッチの値 <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> を辞書 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">env</span></code> のキーとするという意味となる。ここで <a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xpressive::ref</span></code></a> を使っているのは、ローカル変数 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">env</span></code> への参照を<strong>遅延</strong>して <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> の置換対象が判明するまで添字演算を遅らせるためである。</p>
</div>
</div>
<div class="section" id="id45">
<h2><a class="toc-backref" href="#id134">文字列の分割とトークン分割</a><a class="headerlink" href="#id45" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> はテキスト操作の世界における GINSU <a class="footnote-reference brackets" href="#id53" id="id46">4</a> のナイフである。薄切りもさいの目切りも思いのまま！ 本節では高度に設定可能な <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></a> で入力シーケンスを分割する方法を述べる。</p>
<div class="section" id="id47">
<h3>概要<a class="headerlink" href="#id47" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> は入力シーケンス、正規表現、省略可能な設定引数で初期化する。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> は <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> を使って、シーケンス内で最初に正規表現にマッチする位置を見つける。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を参照はがしすると、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::basic_string</span></code> 形式で<strong>トークン</strong>を返す。どの文字列を返すかは設定引数による。既定ではマッチ全体に相当する文字列を返すが、マーク済み部分式のみならずシーケンス内のマッチ<strong>しなかった</strong>部分を返すことも可能である。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> をインクリメントすると次のトークンに移動する。次がどのトークンかは設定引数による。単純に現在のマッチにおける異なるマーク済み部分式の場合もあれば、次のマッチの全体か一部分である場合、マッチ<strong>しなかった</strong>部分である場合もある。</p>
<p>以上のことからわかるように、<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> には多くの機能がある。すべてを説明するのは難しいが、いくつか例を見れば理解できるだろう。</p>
</div>
<div class="section" id="id48">
<h3>例 1：単純なトークン分割<a class="headerlink" href="#id48" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例では <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使ってシーケンスを単語のトークンに切っている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;This is his face&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">;</span>                      <span class="c1">// 単語を検索する</span>

<span class="c1">// 入力中の単語をすべて走査する</span>
<span class="n">sregex_token_iterator</span> <span class="nf">begin</span><span class="p">(</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">re</span> <span class="p">),</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべての単語を std::cout に出力する</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_iter</span> <span class="p">);</span>
</pre></div>
</div>
<p>このプログラムは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">This</span>
<span class="go">is</span>
<span class="go">his</span>
<span class="go">face</span>
</pre></div>
</div>
</div>
<div class="section" id="id49">
<h3>例 2：単純なトークン分割・リローデッド<a class="headerlink" href="#id49" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例も <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></a> を使ってシーケンスを単語トークンに切っているが、正規表現を区切りとして使っている。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></a> コンストラクタの最後の引数に <code class="docutils literal notranslate"><span class="pre">-1</span></code> を渡すと、入力内の正規表現にマッチ<strong>しなかった</strong>部分がトークンとなる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;This is his face&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="o">+</span><span class="n">_s</span><span class="p">;</span>                      <span class="c1">// 空白を検索する</span>

<span class="c1">// 入力中の非空白をすべて走査する。-1 に注意</span>
<span class="n">sregex_token_iterator</span> <span class="nf">begin</span><span class="p">(</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">re</span><span class="p">,</span> <span class="mi">-1</span> <span class="p">),</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべての単語を std::cout に出力する</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_iter</span> <span class="p">);</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">This</span>
<span class="go">is</span>
<span class="go">his</span>
<span class="go">face</span>
</pre></div>
</div>
</div>
<div class="section" id="id51">
<h3>例 3：単純なトークン分割・レボリューションズ <a class="footnote-reference brackets" href="#id54" id="id50">5</a><a class="headerlink" href="#id51" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例も <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使って日付の束が入ったシーケンスを年だけのトークンに切っている。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator</span></code></a> コンストラクタの最後の引数に正の整数 <code class="samp docutils literal notranslate"><em><span class="pre">N</span></em></code> を渡すと、各マッチの <code class="samp docutils literal notranslate"><em><span class="pre">N</span></em></code> 番目のマーク済み部分式のみがトークンとなる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(</span><span class="se">\\</span><span class="s">d{2})/(</span><span class="se">\\</span><span class="s">d{2})/(</span><span class="se">\\</span><span class="s">d{4})&quot;</span><span class="p">);</span> <span class="c1">// 日付を検索する</span>

<span class="c1">// 入力中のすべての年を走査をする。3（3 番目の部分式）に注意</span>
<span class="n">sregex_token_iterator</span> <span class="nf">begin</span><span class="p">(</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">re</span><span class="p">,</span> <span class="mi">3</span> <span class="p">),</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべての単語を std::cout に出力する</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_iter</span> <span class="p">);</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">2003</span>
<span class="go">1999</span>
<span class="go">1981</span>
</pre></div>
</div>
</div>
<div class="section" id="id52">
<h3>例 4：あまり単純でないトークン分割<a class="headerlink" href="#id52" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例は 1 つ前のものと似ているが、年だけでなく月と日をトークンに入れている点が異なる。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> コンストラクタの最後の引数に整数の配列 <code class="code docutils literal notranslate"><span class="pre">{I,J,...}</span></code> を渡すと、各マッチの <code class="samp docutils literal notranslate"><em><span class="pre">I</span></em></code> 番目、<code class="samp docutils literal notranslate"><em><span class="pre">J</span></em></code> 番目、…のマーク済み部分式がトークンとなる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">input</span><span class="p">(</span><span class="s">&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(</span><span class="se">\\</span><span class="s">d{2})/(</span><span class="se">\\</span><span class="s">d{2})/(</span><span class="se">\\</span><span class="s">d{4})&quot;</span><span class="p">);</span> <span class="c1">// 日付を検索する</span>

<span class="c1">// 入力中の年月日を走査する</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">sub_matches</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// 日、月、年</span>
<span class="n">sregex_token_iterator</span> <span class="nf">begin</span><span class="p">(</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">re</span><span class="p">,</span> <span class="n">sub_matches</span> <span class="p">),</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべての単語を std::cout に出力する</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">out_iter</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">out_iter</span> <span class="p">);</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">02</span>
<span class="go">01</span>
<span class="go">2003</span>
<span class="go">23</span>
<span class="go">04</span>
<span class="go">1999</span>
<span class="go">13</span>
<span class="go">11</span>
<span class="go">1981</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">sub_matches</span></code> 配列により、<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> は最初に 2 番目の部分マッチ、次に 1 番目の部分マッチ、最後に 3 番目の部分マッチの値を取る。イテレータをインクリメントすると <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> を使って次のマッチを検索する。ここで処理が繰り返され、イテレータは 2 番目の部分マッチを取り、次に 1 番目…となる。</p>
<dl class="footnote brackets">
<dt class="label" id="id53"><span class="brackets"><a class="fn-backref" href="#id46">4</a></span></dt>
<dd><p>訳注　刃物メーカー（<a class="reference external" href="http://www.genuineginsu.com/">http://www.genuineginsu.com/</a>）。GINSU のナイフはよく切れると評判らしいです。Wikipedia によるとテレビ CM が画期的なものだったとか。</p>
</dd>
<dt class="label" id="id54"><span class="brackets"><a class="fn-backref" href="#id50">5</a></span></dt>
<dd><p>訳注　マトリックスですね。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id55">
<h2><a class="toc-backref" href="#id135">名前付き捕捉</a><a class="headerlink" href="#id55" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id56">
<h3>概要<a class="headerlink" href="#id56" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現が複雑になると、番号付き捕捉を取り扱うのが苦痛になる場合がある。左括弧の数を数えてどの捕捉に対応しているのか調べるのはつまらない仕事である。さらに面白くないのは、正規表現を編集するだけで捕捉に新しい番号が割り振られて古い番号を使っていた後方参照が無効になることである。</p>
<p>他の正規表現エンジンでは、<strong>名前付き捕捉</strong>という機能でこの問題を解決している。この機能を使うと捕捉に名前を付けることができ、番号ではなく名前で捕捉を後方参照できる。xpressive も動的・静的正規表現の両方で名前付き捕捉をサポートする。</p>
</div>
<div class="section" id="id57">
<h3>動的名前付き捕捉<a class="headerlink" href="#id57" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>動的正規表現については、xpressive は他の一般的な正規表現エンジンの名前付き捕捉の構文に従う。<code class="regexp docutils literal notranslate"><span class="pre">(?P&lt;xxx&gt;...)</span></code> で名前付き捕捉を作成し、<code class="regexp docutils literal notranslate"><span class="pre">(?P=xxx)</span></code> でこの捕捉を後方参照する。名前付き後方参照を作成し後方参照する例を以下に示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1 文字にマッチする &quot;char&quot; という名前付き捕捉を作成し、名前により後方参照する。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(?P&lt;char&gt;.)(?P=char)&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>上の正規表現は同じ文字が 2 つ続いた部分を検索する。</p>
<p>名前付き捕捉を使ってマッチか検索を行った後、捕捉の名前を使って <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> により名前付き捕捉にアクセスする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;tweet&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(?P&lt;char&gt;.)(?P=char)&quot;</span><span class="p">);</span>
<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;char = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="s">&quot;char&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上のコードは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">char = e</span>
</pre></div>
</div>
<p>名前付き捕捉を置換文字列から後方参照することも可能である。<code class="regexp docutils literal notranslate"><span class="pre">\\g&lt;xxx&gt;</span></code> という構文である。文字列置換において名前付き捕捉を使用する例を以下に示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;tweet&quot;</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(?P&lt;char&gt;.)(?P=char)&quot;</span><span class="p">);</span>
<span class="n">str</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="s">&quot;**</span><span class="se">\\</span><span class="s">g&lt;char&gt;**&quot;</span><span class="p">,</span> <span class="n">regex_constants</span><span class="o">::</span><span class="n">format_perl</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>名前付き捕捉を使用するには <a class="reference internal" href="reference/regex_constants.match_flag_type.html#_CPPv4N5boost9xpressive15regex_constants15match_flag_type11format_perlE" title="boost::xpressive::regex_constants::match_flag_type::format_perl"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">format_perl</span></code></a> を指定しなければならないことに注意していただきたい。<code class="regexp docutils literal notranslate"><span class="pre">\\g&lt;xxx&gt;</span></code> 構文を解釈するのは Perl の構文だけである。上のコードは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tw**e**t</span>
</pre></div>
</div>
</div>
<div class="section" id="id58">
<h3>静的名前付き捕捉<a class="headerlink" href="#id58" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>静的正規表現を使う場合は、名前付き捕捉の作成と使用はより簡単である。<a class="reference internal" href="reference/mark_tag.html#_CPPv4N5boost9xpressive8mark_tagE" title="boost::xpressive::mark_tag"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">mark_tag</span></code></a> 型を使って <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> 、<a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code></a> のような変数を作成するが、より意味のある名前を与えることができる。静的表現を使うと上の例は以下のようになる。<a class="footnote-reference brackets" href="#id60" id="id59">6</a></p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">mark_tag</span> <span class="nf">char_</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// char_ は s1 の別名となる</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">char_</span><span class="o">=</span> <span class="n">_</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">char_</span><span class="p">;</span>
</pre></div>
</div>
<p>マッチを行った後、<a class="reference internal" href="reference/mark_tag.html#_CPPv4N5boost9xpressive8mark_tagE" title="boost::xpressive::mark_tag"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">mark_tag</span></code></a> を <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> の添字にして名前付き捕捉にアクセスする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;tweet&quot;</span><span class="p">);</span>
<span class="n">mark_tag</span> <span class="nf">char_</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">char_</span><span class="o">=</span> <span class="n">_</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">char_</span><span class="p">;</span>
<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="n">char_</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上のコードは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">char = e</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/regex_replace.html#_CPPv4I000EN5boost9xpressive13regex_replaceE7OutIter7OutIter8BidiIter8BidiIterRK11basic_regexI8BidiIterERK9FormatterN15regex_constants15match_flag_typeE11unspecified" title="boost::xpressive::regex_replace"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_replace</span></code></a> を使って文字列置換を行う場合、以下のように名前付き捕捉を使用して<strong>書式化式</strong>を作成できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;tweet&quot;</span><span class="p">);</span>
<span class="n">mark_tag</span> <span class="nf">char_</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">char_</span><span class="o">=</span> <span class="n">_</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">char_</span><span class="p">;</span>
<span class="n">str</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rx</span><span class="p">,</span> <span class="s">&quot;**&quot;</span> <span class="o">+</span> <span class="n">char_</span> <span class="o">+</span> <span class="s">&quot;**&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>上のコードは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">tw**e**t</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>書式化式を使用するには <code class="file docutils literal notranslate"><span class="pre">&lt;boost/xpressive/regex_actions.hpp&gt;</span></code> をインクルードしなければならない。</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id60"><span class="brackets"><a class="fn-backref" href="#id59">6</a></span></dt>
<dd><p>訳注　リファレンスの項にあるとおり、<a class="reference internal" href="reference/mark_tag.html#_CPPv4N5boost9xpressive8mark_tagE" title="boost::xpressive::mark_tag"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">mark_tag</span></code></a> の初期化に使用する整数は正規表現内で一意でなければなりません。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id61">
<h2><a class="toc-backref" href="#id136">文法と入れ子マッチ</a><a class="headerlink" href="#id61" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id62">
<h3>概要<a class="headerlink" href="#id62" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現を C++ の式で表現することの重要な利点の 1 つは、正規表現中から他の C++ コードやデータに容易にアクセスできることである。これにより、他の正規表現で不可能なプログラミングイディオムが可能になる。特に注意していただきたいのは、正規表現が他の正規表現を参照する機能で、これにより正規表現の外部で文法を構築できる。この節では正規表現を他の正規表現に値や参照で組み込む方法、正規表現が他の正規表現を参照したときの振る舞い、解析が成功した後の結果木にアクセスする方法を説明する。</p>
</div>
<div class="section" id="id63">
<h3>値による正規表現の組み込み<a class="headerlink" href="#id63" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトは値のセマンティクスをもつ。正規表現オブジェクトが別の正規表現定義の右辺に現れると、値による組み込みが起こるとみなされる。つまり、入れ子の正規表現のコピーが外側の正規表現に格納される。内側の正規表現は、パターンマッチ時に外側の正規表現により呼び出される。内側の正規表現をマッチに対して完全に消耗すると、マッチを成功させるためにバックトラックが起こる。</p>
<p>単語単位の正規表現検索機能をもつテキストエディタを考える。これを xpressive で実装すると次のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">find_dialog</span> <span class="n">dlg</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span> <span class="n">dialog_ok</span> <span class="o">==</span> <span class="n">dlg</span><span class="p">.</span><span class="n">do_modal</span><span class="p">()</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">dlg</span><span class="p">.</span><span class="n">get_text</span><span class="p">();</span>          <span class="c1">// ユーザーが入力したパターン</span>
    <span class="kt">bool</span> <span class="n">whole_word</span> <span class="o">=</span> <span class="n">dlg</span><span class="p">.</span><span class="n">whole_word</span><span class="p">.</span><span class="n">is_checked</span><span class="p">();</span> <span class="c1">// ユーザーが単語単位のオプションを選択したか？</span>

    <span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="n">pattern</span> <span class="p">);</span>        <span class="c1">// パターンのコンパイル</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">whole_word</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 正規表現を単語の先頭、単語の終端表明で囲む</span>
        <span class="n">re</span> <span class="o">=</span> <span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="n">re</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ... re を使う ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この行に注目する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 正規表現を単語の先頭、単語の終端表明で囲む</span>
<span class="n">re</span> <span class="o">=</span> <span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="n">re</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">;</span>
</pre></div>
</div>
<p>この行は既存の正規表現を値で組み込んだ正規表現を新たに作成し、元の正規表現に代入している。元の正規表現のコピーが右辺にあるので、これは期待したとおりに動作する。つまり、新しい正規表現の振る舞いは元の正規表現を単語先頭と単語終端の表明で囲んだものとなる。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>既定では正規表現オブジェクトは値で組み込まれるため、<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">re</span> <span class="pre">=</span> <a class="reference internal" href="reference/bow.html#_CPPv4N5boost9xpressive3bowE" title="boost::xpressive::bow"><span class="pre">bow</span></a> <span class="pre">&gt;&gt;</span> <span class="pre">re</span> <span class="pre">&gt;&gt;</span> <a class="reference internal" href="reference/eow.html#_CPPv4N5boost9xpressive3eowE" title="boost::xpressive::eow"><span class="pre">eow</span></a></code> は再帰正規表現を定義<strong>しない</strong>ことに注意していただきたい。次の節では、正規表現を参照で組み込んで再帰正規表現を定義する方法を述べる。</p>
</div>
</div>
<div class="section" id="id64">
<h3>参照による正規表現の組み込み<a class="headerlink" href="#id64" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>再帰正規表現および文脈自由文法を構築するには、値による正規表現の組み込みでは不十分である。正規表現を自己参照的にする必要がある。大半の正規表現エンジンにはそういった能力はないが、xpressive では可能である。</p>
<div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p>理論コンピュータ科学者は、自己参照的な正規表現は「正規（正則）」ではないと指摘するかもしれない。そういう意味では、厳密には xpressive は本当は<strong>正規</strong>表現エンジンではない。しかし Larry Wall がかつてこう言ったことがある。「項 [regular expression] は我々のパターンマッチエンジンとともに成長した。言語の必要性と戦うつもりはない。」</p>
</div>
<p>次のコードを考える。<a class="reference internal" href="reference/by_ref.html#_CPPv4I0EN5boost9xpressive6by_refEKN5proto8terminalI17reference_wrapperIK11basic_regexI8BidiIterEEE4typeERK11basic_regexI8BidiIterE" title="boost::xpressive::by_ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">by_ref</span></code></a> ヘルパを使って、数の合った入れ子の括弧にマッチする再帰正規表現を定義している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">parentheses</span><span class="p">;</span>
<span class="n">parentheses</span>                          <span class="c1">// 数の合った括弧群は...</span>
    <span class="o">=</span> <span class="sc">&#39;(&#39;</span>                            <span class="c1">// 最初に 1 つの開き括弧があり...</span>
        <span class="o">&gt;&gt;</span>                           <span class="c1">// その後ろに...</span>
         <span class="o">*</span><span class="p">(</span>                          <span class="c1">// 0 か 1 つ以上の...</span>
            <span class="n">keep</span><span class="p">(</span> <span class="o">+~</span><span class="p">(</span><span class="n">set</span><span class="o">=</span><span class="sc">&#39;(&#39;</span><span class="p">,</span><span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">)</span>  <span class="c1">// 括弧以外のものの塊か...</span>
          <span class="o">|</span>                          <span class="c1">// あるいは...</span>
            <span class="n">by_ref</span><span class="p">(</span><span class="n">parentheses</span><span class="p">)</span>      <span class="c1">// 数の合った括弧群があり</span>
          <span class="p">)</span>                          <span class="c1">//   （これだ、再帰している！）...</span>
        <span class="o">&gt;&gt;</span>                           <span class="c1">// その後ろに...</span>
      <span class="sc">&#39;)&#39;</span>                            <span class="c1">// 1 つの閉じ括弧がある</span>
    <span class="p">;</span>
</pre></div>
</div>
<p>数の合った入れ子のタグに対するマッチは重要なテキスト処理であり、「旧式の」正規表現では不可能なことの 1 つである。<a class="reference internal" href="reference/by_ref.html#_CPPv4I0EN5boost9xpressive6by_refEKN5proto8terminalI17reference_wrapperIK11basic_regexI8BidiIterEEE4typeERK11basic_regexI8BidiIterE" title="boost::xpressive::by_ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">by_ref</span></code></a> ヘルパがこれを可能にする。これによりある正規表現を別の正規表現から<strong>参照により</strong>組み込むことができる。右辺が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">parentheses</span></code> を参照で保持しているので、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">parentheses</span></code> に右辺を代入すると循環が生まれ再帰的に実行される。</p>
</div>
<div class="section" id="id65">
<h3>文法の構築<a class="headerlink" href="#id65" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現が自己再帰的になりさえすれば、もう後戻りする必要はない。楽しみにしていたことがすべて可能になる。特に正規表現の外部で文法を構築できるようになる。text-book 文法の例を見よう。ちょっとした計算機だ。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">group</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">term</span><span class="p">,</span> <span class="n">expression</span><span class="p">;</span>

<span class="n">group</span>       <span class="o">=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">by_ref</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
<span class="n">factor</span>      <span class="o">=</span> <span class="o">+</span><span class="n">_d</span> <span class="o">|</span> <span class="n">group</span><span class="p">;</span>
<span class="n">term</span>        <span class="o">=</span> <span class="n">factor</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">((</span><span class="sc">&#39;*&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">factor</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;/&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">factor</span><span class="p">));</span>
<span class="n">expression</span>  <span class="o">=</span> <span class="n">term</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">((</span><span class="sc">&#39;+&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">term</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="sc">&#39;-&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">term</span><span class="p">));</span>
</pre></div>
</div>
<p>上で定義した正規表現 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">expression</span></code> は正規表現としては非常に注目すべき動作をする。数式にマッチするのである。例えば入力文字列が <code class="regexp docutils literal notranslate"><span class="pre">foo</span> <span class="pre">9*(10+3)</span> <span class="pre">bar</span></code> であれば、このパターンは <code class="regex-input docutils literal notranslate"><span class="pre">9*(10+3)</span></code> にマッチする。この正規表現がマッチするのは正しい形式の数式、つまり括弧の数が合っており、中置演算子が引数を2つもつ場合のみである。他の正規表現エンジンでこれを試してはいけませんぞ！</p>
<p>この正規表現文法をもっとよく見てみよう。循環していることに注意していただきたい。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">expression</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">term</span></code> を使って実装してあり、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">term</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">factor</span></code> を使って実装してある。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">factor</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">group</span></code> を使って実装してあり、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">group</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">expression</span></code> を使って実装してある。というわけでループが閉じている。大抵の場合、循環文法の定義は正規表現オブジェクトの前方宣言とこれら未初期化の正規表現の参照による組み込みにより行う。上の文法では、未初期化の正規表現オブジェクトを参照する必要があるのは1箇所だけである。それが <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">group</span></code> の定義であり、<a class="reference internal" href="reference/by_ref.html#_CPPv4I0EN5boost9xpressive6by_refEKN5proto8terminalI17reference_wrapperIK11basic_regexI8BidiIterEEE4typeERK11basic_regexI8BidiIterE" title="boost::xpressive::by_ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">by_ref</span></code></a> を使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">expression</span></code> を参照により組み込んでいる。他の正規表現オブジェクトはすべて初期化済みで値が変化することもないため、値による組み込みで事足りている。</p>
<div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p class="rubric">ヒント：可能な限り、値による組み込みを使え</p>
<p>通常、正規表現の組み込みは参照よりも値で行うほうが望ましい。そのほうが分かりやすいし、パターンマッチが少し高速になる。その上、値のセマンティクスは簡単で文法の推論が容易になる。正規表現の「コピー」の負荷については心配しないでいただきたい。各正規表現オブジェクトはコピー間で実装を共有する。</p>
</div>
</div>
<div class="section" id="id66">
<h3>動的正規表現文法<a class="headerlink" href="#id66" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使用して動的正規表現の外部で文法を構築することもできる。名前付きの正規表現を作成し、他の正規表現から名前で参照するのである。各 <a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> インスタンスは名前と正規表現の対応を保持する。</p>
<p>名前付き動的正規表現を作成するには、正規表現の先頭に <code class="regexp docutils literal notranslate"><span class="pre">(?$name=)</span></code> を付ける。<code class="samp docutils literal notranslate"><em><span class="pre">name</span></em></code> は正規表現の名前である。名前付き正規表現を他の正規表現から名前で参照するには <code class="regexp docutils literal notranslate"><span class="pre">(?$name)</span></code> とする。名前付き正規表現は他の正規表現から参照する時点では存在していなくても構わないが、正規表現を使用する時点では存在していなければならない。</p>
<p>以下のコード片は、動的正規表現文法を使って上の計算機の例を実装している。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">regex_constants</span><span class="p">;</span>

<span class="n">sregex</span> <span class="n">expr</span><span class="p">;</span>

<span class="p">{</span>
     <span class="n">sregex_compiler</span> <span class="n">compiler</span><span class="p">;</span>
     <span class="n">syntax_option_type</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ignore_white_space</span><span class="p">;</span>

            <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(? $group  = ) </span><span class="se">\\</span><span class="s">( (? $expr ) </span><span class="se">\\</span><span class="s">) &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(? $factor = ) </span><span class="se">\\</span><span class="s">d+ | (? $group ) &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(? $term   = ) (? $factor )&quot;</span>
                             <span class="s">&quot; ( </span><span class="se">\\</span><span class="s">* (? $factor ) | / (? $factor ) )* &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
     <span class="n">expr</span> <span class="o">=</span> <span class="n">compiler</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;(? $expr   = ) (? $term )&quot;</span>
                             <span class="s">&quot;   ( </span><span class="se">\\</span><span class="s">+ (? $term ) | - (? $term )   )* &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;foo 9*(10+3) bar&quot;</span><span class="p">);</span>
<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span><span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">expr</span><span class="p">))</span>
<span class="p">{</span>
     <span class="c1">// &quot;9*(10+3)&quot; を印字する:</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>静的正規表現の場合と同様、入れ子の正規表現を呼び出すと入れ子のマッチ結果が作成される（以下の「入れ子の結果」を見よ）。結果はマッチした文字列の完全な解析木である。静的正規表現と異なり、動的正規表現は常に値ではなく参照による組み込みとなる。</p>
</div>
<div class="section" id="id67">
<h3>循環パターンにコピーにメモリ管理まで、まあ何てこと！<a class="headerlink" href="#id67" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上の計算機の例で非常に複雑なメモリ管理の問題が持ち上がる。4 つの正規表現オブジェクトは直接・間接的に、また値・参照でお互いを参照している。このうちの 1 つを関数から返し、残りがスコープの外に出るとどうなるのか？ 参照はどうなるのか？ 答えは、正規表現オブジェクトは内部に参照カウントを持つため必要な限り正規表現による参照は保持される、である。よって正規表現オブジェクトを値で渡しても、それがスコープの外に行ってしまった正規表現オブジェクトを参照していたとしても問題は起きない。</p>
<p>参照カウントに詳しい人はおそらくその唯一の弱点についてもご存知と思う。循環参照である。正規表現オブジェクトを参照カウントすると、計算機の例で作成したような循環はどうなるのか？ リークが起こるのか？ 答えはノーであり、リークは起きない。<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトは技巧的な参照追跡コードを使っており、最後の外部参照が無くなったときに循環正規表現文法はクリーンアップされる。そういうわけで心配無用だ。好きなだけ循環文法を作成したり、正規表現オブジェクトを渡したりコピーしていただきたい。高速かつ高効率で、リークや懸垂参照（dangling references）が起きないことが保証されている。</p>
</div>
<div class="section" id="id68">
<h3>入れ子の正規表現と部分マッチのスコープ<a class="headerlink" href="#id68" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現を入れ子にすると部分マッチのスコープの問題が持ち上がる。内側と外側の両方の正規表現が同じ部分マッチのベクタを読み書きすると、混乱が起こる。外側の正規表現が書き込んだ部分マッチを内側の正規表現が台無しにするわけだ。例えば、これはどうなるか。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">inner</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(.)</span><span class="se">\\</span><span class="s">1&quot;</span> <span class="p">);</span>
<span class="n">sregex</span> <span class="n">outer</span> <span class="o">=</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="n">_</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">inner</span> <span class="o">&gt;&gt;</span> <span class="n">s1</span><span class="p">;</span>
</pre></div>
</div>
<p>外側の正規表現が書き込んだ部分マッチを内側の正規表現が上書きしているが、おそらくこのコードの作者が意図するところではないだろう。内側の正規表現がユーザーから入力である場合は、特に大問題である。内側の正規表現が部分マッチのベクタを破壊するかどうか知る方法が無いのである。これは明らかに許容できるものではない。</p>
<p>代わりにどうするのかというと、入れ子の正規表現を呼び出すたびに自身のスコープを形成する。つまり入れ子の正規表現はそれぞれ対象となる部分マッチのベクタについて自分用のコピーを取得するため、外側の正規表現の部分マッチを内側の正規表現が台無しにする可能性は無くなる。例えば上で定義した正規表現 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">outer</span></code> は、当然 <code class="regex-input docutils literal notranslate"><span class="pre">ABBA</span></code> にマッチする。</p>
</div>
<div class="section" id="id69">
<h3>入れ子の結果<a class="headerlink" href="#id69" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入れ子の正規表現が自身の部分マッチをもつのであれば、マッチ成功後にそれらにアクセスする方法があってしかるべきである。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> か <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> の後、<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体は入れ子の結果を表す木の頂点のように振舞う。<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> クラスは、入れ子の正規表現の結果を表す <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> 構造体の順序付きシーケンスを返す <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">nested_results</span></code> メンバ関数を提供する。入れ子の結果の順序は、入れ子の正規表現がマッチした順序と同じである。</p>
<p>前に見た、数の合った入れ子の括弧の正規表現を例にとる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">parentheses</span><span class="p">;</span>
<span class="n">parentheses</span> <span class="o">=</span> <span class="sc">&#39;(&#39;</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">(</span> <span class="n">keep</span><span class="p">(</span> <span class="o">+~</span><span class="p">(</span><span class="n">set</span><span class="o">=</span><span class="sc">&#39;(&#39;</span><span class="p">,</span><span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="o">|</span> <span class="n">by_ref</span><span class="p">(</span><span class="n">parentheses</span><span class="p">)</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>

<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span> <span class="s">&quot;blah blah( a(b)c (c(e)f (g)h )i (j)6 )blah&quot;</span> <span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">regex_search</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">parentheses</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// マッチ全体を表示する</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// 入れ子の結果を表示する</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span>
        <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span>
        <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">end</span><span class="p">(),</span>
        <span class="n">output_nested_results</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">( a(b)</span><span class="go">c (c(e)f (g)h )i (j)6 )</span>
<span class="go">    (b)</span>
<span class="go">    (c(e)f (g)h )</span>
<span class="go">        (e)</span>
<span class="go">        (g)</span>
<span class="go">    (j)</span>
</pre></div>
</div>
<p>結果がどのように入れ子になるか、それらが見つかった順に格納されていることが分かったと思う。</p>
<div class="admonition tip">
<p class="admonition-title">ちなみに</p>
<p><a class="reference internal" href="examples.html"><span class="doc">例</span></a>の節にある <a class="reference internal" href="#examples-display-a-tree-of-nested-results"><span class="std std-ref">output_nested_results</span></a> の定義を見よ。</p>
</div>
</div>
<div class="section" id="id70">
<h3>入れ子の結果のフィルタリング<a class="headerlink" href="#id70" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>1 つの正規表現の中に複数の入れ子の正規表現があり、どの結果がどの正規表現に対応するのか知りたい場合がある。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::regex_id</span></code> と <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">match_results::regex_id</span></code> が役に立つ場面である。入れ子の結果を走査しているときに、結果の正規表現 ID と目的の正規表現オブジェクトの ID を比較するとよい。</p>
<p>これを少し容易にするために、xpressive は特定の入れ子正規表現に相当する結果だけを列挙する述語を提供している。これが <a class="reference internal" href="reference/regex_id_filter_predicate.html#_CPPv4I0EN5boost9xpressive25regex_id_filter_predicateE" title="boost::xpressive::regex_id_filter_predicate"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_id_filter_predicate</span></code></a> であり、<a class="reference external" href="http://www.boost.org/libs/iterator/">Boost.Iterator</a> とともに使用することを意図している。以下のように使用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">name</span> <span class="o">=</span> <span class="o">+</span><span class="n">alpha</span><span class="p">;</span>
<span class="n">sregex</span> <span class="n">integer</span> <span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">;</span>
<span class="n">sregex</span> <span class="n">re</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span> <span class="o">*</span><span class="n">_s</span> <span class="o">&gt;&gt;</span> <span class="p">(</span> <span class="n">name</span> <span class="o">|</span> <span class="n">integer</span> <span class="p">)</span> <span class="p">);</span>

<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span> <span class="s">&quot;marsha 123 jan 456 cindy 789&quot;</span> <span class="p">);</span>

<span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">re</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">smatch</span><span class="o">::</span><span class="n">nested_results_type</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">smatch</span><span class="o">::</span><span class="n">nested_results_type</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">end</span>   <span class="o">=</span> <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">end</span><span class="p">();</span>

    <span class="c1">// 名前（name）か整数（integer）だけを選択する述語フィルタを宣言する</span>
    <span class="n">sregex_id_filter_predicate</span> <span class="nf">name_id</span><span class="p">(</span> <span class="n">name</span><span class="p">.</span><span class="n">regex_id</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">sregex_id_filter_predicate</span> <span class="nf">integer_id</span><span class="p">(</span> <span class="n">integer</span><span class="p">.</span><span class="n">regex_id</span><span class="p">()</span> <span class="p">);</span>

    <span class="c1">// 正規表現 name の結果だけを走査する</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">make_filter_iterator</span><span class="p">(</span> <span class="n">name_id</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">make_filter_iterator</span><span class="p">(</span> <span class="n">name_id</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="p">),</span>
        <span class="n">output_result</span>
        <span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// 正規表現 integer の結果だけを走査する</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">make_filter_iterator</span><span class="p">(</span> <span class="n">integer_id</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="p">),</span>
        <span class="n">boost</span><span class="o">::</span><span class="n">make_filter_iterator</span><span class="p">(</span> <span class="n">integer_id</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">end</span> <span class="p">),</span>
        <span class="n">output_result</span>
        <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">output_results</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">smatch</span></code> を受け取りマッチ全体を表示する単純な関数である。特定の入れ子正規表現に相当する結果だけを選択するのに <a class="reference internal" href="reference/regex_id_filter_predicate.html#_CPPv4I0EN5boost9xpressive25regex_id_filter_predicateE" title="boost::xpressive::regex_id_filter_predicate"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_id_filter_predicate</span></code></a> を <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basic_regex::regex_id</span></code> と <a class="reference external" href="http://www.boost.org/libs/iterator/">Boost.Iterator</a> の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::make_filter_iterator</span></code> とともに使っている点に注意していただきたい。このプログラムは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">marsha</span>
<span class="go">jan</span>
<span class="go">cindy</span>
<span class="go">123</span>
<span class="go">456</span>
<span class="go">789</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id71">
<h2><a class="toc-backref" href="#id137">意味アクションとユーザー定義表明</a><a class="headerlink" href="#id71" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id72">
<h3>概要<a class="headerlink" href="#id72" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入力文字列を解析し、そこから <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> を構築したいとする。このような場合、正規表現では不十分である。正規表現マッチの部分で<strong>何か</strong>をしたい。xpressive は、静的正規表現の部分に意味アクションを結びつける方法を提供する。本節ではその方法を説明する。</p>
</div>
<div class="section" id="semantic-actions">
<h3>意味アクション（Semantic Actions）<a class="headerlink" href="#semantic-actions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のコードを考える。xpressive の意味アクションを使って単語と整数の組からなる文字列を解析し、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> に詰め込んでいる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/regex_actions.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

    <span class="c1">// =&gt; で区切られた単語と整数にマッチし、</span>
    <span class="c1">// 結果を std::map&lt;&gt; に詰め込む</span>
    <span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">[</span> <span class="n">ref</span><span class="p">(</span><span class="n">result</span><span class="p">)[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

    <span class="c1">// 空白で区切られた 1 つ以上の単語・整数の組にマッチする。</span>
    <span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">pair</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">(</span><span class="o">+</span><span class="n">_s</span> <span class="o">&gt;&gt;</span> <span class="n">pair</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">regex_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
<p>正規表現 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">pair</span></code> は、パターンとアクションの 2 つの部分からなる。単語のマッチを 1 番目の部分マッチで捕捉し、<code class="regex-input docutils literal notranslate"><span class="pre">=&gt;</span></code> で区切られた整数のマッチを 2 番目の部分マッチで捕捉するというのがパターンが表現するところである。アクションは角括弧 <code class="code docutils literal notranslate"><span class="pre">[</span> <span class="pre">ref(result)[s1]</span> <span class="pre">=</span> <span class="pre">as&lt;int&gt;(s2)</span> <span class="pre">]</span></code> の内側である。これは 1 番目の部分マッチを <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">results</span></code> 辞書の添字に使用し、そこに2番目の部分マッチを整数に変換した結果を代入するという意味である。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>静的正規表現で意味アクションを使用するには、<code class="file docutils literal notranslate"><span class="pre">&lt;boost/xpressive/regex_actions.hpp&gt;</span></code> をインクルードしなければならない。</p>
</div>
<p>このコードはどのように動作するのだろう？ 静的正規表現の残りの部分だけ見ると括弧の間は式テンプレートになっている。これでアクションがコード化され、後で実行される。式 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> への遅延参照を作成する。より大きな式である <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span><span class="pre">[</span><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><span class="pre">s1</span></a><span class="pre">]</span></code> は辞書に対する添字操作の遅延である。後でこのアクションを実行すると <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code> は 1 番目の <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> で置換される。同様に <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/as.html#_CPPv4I00EN5boost9xpressive2asE11unspecifiedRK1A" title="boost::xpressive::as"><span class="pre">as</span></a><span class="pre">&lt;</span><span class="pre">int</span><span class="pre">&gt;</span><span class="pre">(</span><a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><span class="pre">s2</span></a><span class="pre">)</span></code> を実行すると <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code> は 2 番目の <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> で置換される。<a class="reference internal" href="reference/as.html#_CPPv4I00EN5boost9xpressive2asE11unspecifiedRK1A" title="boost::xpressive::as"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">as&lt;&gt;</span></code></a> アクションは引数を Boost.Lexical_cast を使って要求の型に変換する。アクション全体の効果としては、新しい単語・整数の組を辞書に挿入する、となる。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="file docutils literal notranslate"><span class="pre">&lt;boost/ref.hpp&gt;</span></code> の関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::ref</span></code> と <code class="file docutils literal notranslate"><span class="pre">&lt;boost/xpressive/regex_actions.hpp&gt;</span></code> の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::xpressive::ref</span></code> には重大な違いがある。前者は通常の参照とほぼ同様の振る舞いをする素の <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference_wrapper&lt;&gt;</span></code> を返す。一方 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::xpressive::ref</span></code> が返すのは、遅延実行する式内で使用する遅延参照である。これが、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> が <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> を受け取る <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">operator[]</span></code> をもたないにも関わらず <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span><span class="pre">[</span><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><span class="pre">s1</span></a><span class="pre">]</span></code> とする理由である。</p>
</div>
<p>部分マッチのプレースホルダ <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> 、<a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code></a> に加えて、アクションが結び付けられている部分式にマッチした文字列を後方参照するのにアクション内で使用するプレースホルダー <a class="reference internal" href="reference/_.html#_CPPv4N5boost9xpressive1_E" title="boost::xpressive::_"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_</span></code></a> がある。例えば以下の正規表現は数字列にマッチし、それらを整数として解釈して結果をローカル変数に代入する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// ここで _ は (+_d) にマッチしたすべての文字を後方参照する</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span> <span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="id73">
<h3>アクションの遅延実行<a class="headerlink" href="#id73" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>アクションを正規表現のある部分に結び付けてマッチを行うとは、実際にはどういう意味なのか？ アクションが実行されるのはいつなのか？ アクションが繰り返し部分式の一部である場合は、アクションが実行される回数は1度なのか複数回なのか？ また部分式が最初はマッチしていたが正規表現の残りの部分がマッチせず最終的に失敗した場合は、アクションはまったく実行されないのか？</p>
<p>答えは既定では、アクションは<strong>遅延</strong>実行される、である。部分式が文字列にマッチすると、そのアクションはアクションが参照する部分マッチの現在の値とともに待ち行列に置かれる。マッチアルゴリズムがバックトラックしなければならなくなると、アクションは必要に応じて待ち行列から取り出される。アクションが実際に実行されるのは、正規表現全体のマッチが成功した後だけである。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> が制御を返す直前の段階で、これらは待ち行列に追加した順番で一度にすべて実行される。</p>
<p>例として、以下の数字を見つけるたびにカウンタを増やす正規表現を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 感嘆符の付いた数字は数えるが、疑問符付きのものは数えない。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</pre></div>
</div>
<p>アクション <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">i</span><span class="pre">)</span></code> は 3 回（数字が見つかるたびに 1 回ずつ）待ち行列に入る。しかし<strong>実行</strong>されるのは 2 回だけ（後ろに <code class="regex-input docutils literal notranslate"><span class="pre">!</span></code> 文字がある数字 1 字について 1 回ずつ）である。<code class="regex-input docutils literal notranslate"><span class="pre">?</span></code> 文字に遭遇するとマッチアルゴリズムはバックトラックを行い、待ち行列から最後のアクションを削除する。</p>
</div>
<div class="section" id="id74">
<h3>アクションの即時実行<a class="headerlink" href="#id74" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>意味アクションを即時実行したい場合は、そのアクションを含む部分式を <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> で包む。<a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> は当該部分式についてバックトラックを無効にし、その部分式の待ち行列に入っているあらゆるアクションを <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> の終了とともに実行する。これにより、あたかも <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> 内の部分式が別の正規表現オブジェクトにコンパイルされ、<a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> のマッチングが <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> を個別に呼び出して実行されたかのようになる。結果この部分式は文字にマッチしアクションを実行するが、バックトラックも巻き戻しもしない。例えば上の例を以下のように書き換えたとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 数字をすべて数える。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">keep</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">);</span>
</pre></div>
</div>
<p>部分式 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/_d.html#_CPPv4N5boost9xpressive2_dE" title="boost::xpressive::_d"><span class="pre">_d</span></a><span class="pre">[</span><span class="pre">++</span><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">i</span><span class="pre">)</span><span class="pre">]</span></code> を <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> で包んだ。こうすることでこの正規表現が数字にマッチするとアクションが待ち行列に入り、<code class="regex-input docutils literal notranslate"><span class="pre">!</span></code> 文字のマッチを試行する前に即時実行されるようになる。この場合、アクションは 3 回実行される。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> と同様、<a class="reference internal" href="reference/before.html#_CPPv4I0EN5boost9xpressive6beforeE11unspecifiedRK4Expr" title="boost::xpressive::before"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">before</span></code></a> と <a class="reference internal" href="reference/after.html#_CPPv4I0EN5boost9xpressive5afterE11unspecifiedRK4Expr" title="boost::xpressive::after"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">after</span></code></a> 内のアクションも、その部分式がマッチしたときに早期実行される。</p>
</div>
</div>
<div class="section" id="id75">
<h3>遅延関数<a class="headerlink" href="#id75" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>ここまで変数と演算子からなる意味アクションの記述方法について見てきたが、意味アクションから関数を呼び出す方法についてはどうだろう？ xpressive にはそのための機構がある。</p>
<p>まず関数オブジェクト型を定義する。以下の例は引数に対して <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">push</span></code> を呼び出す関数オブジェクトである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">push_impl</span>
<span class="p">{</span>
    <span class="c1">// 戻り値の型（tr1::result_of のために必要）</span>
    <span class="k">typedef</span> <span class="kt">void</span> <span class="n">result_type</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Sequence</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Value</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Sequence</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">,</span> <span class="n">Value</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">seq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>次に xpressive の <a class="reference internal" href="reference/function.html#_CPPv4I0EN5boost9xpressive8functionE" title="boost::xpressive::function"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">function&lt;&gt;</span></code></a> テンプレートを使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> という名前の関数オブジェクトを定義する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// グローバルな &quot;push&quot; 関数オブジェクト。</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">push_impl</span><span class="o">&gt;::</span><span class="n">type</span> <span class="k">const</span> <span class="n">push</span> <span class="o">=</span> <span class="p">{{}};</span>
</pre></div>
</div>
<p>初期化はいささか奇妙に見えるが、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> を静的に初期化するためである。これは実行時に構築する必要はないということを意味する。以下のように <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> を意味アクション内で使用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>
<span class="c1">// 数字がマッチしたら int へキャストし、スタックに積む。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span><span class="n">push</span><span class="p">(</span><span class="n">ref</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">))];</span>
</pre></div>
</div>
<p>この方法だとメンバ関数の呼び出しがただの関数呼び出しに見えてしまうことに気付くと思う。意味アクションを、よりメンバ関数呼び出しらしく見えるように記述する方法がある。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span><span class="n">ref</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span><span class="o">-&gt;*</span><span class="n">push</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">))];</span>
</pre></div>
</div>
<p>xpressive は <code class="code docutils literal notranslate"><span class="pre">-&gt;*</span></code> を認識し、この式を上のコードとまったく同等に扱う。</p>
<p>関数オブジェクトが引数によって戻り値の型を変えなければならない場合は、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">result_type</span></code> 型定義の代わりに <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">result&lt;&gt;</span></code> メンバテンプレートを使用するとよい。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::pair&lt;&gt;</span></code> か <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> の <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">first</span></code> メンバを返す <a class="reference internal" href="reference/first.html#_CPPv4N5boost9xpressive5firstE" title="boost::xpressive::first"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">first</span></code></a> 関数オブジェクトの例である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 組の第 1 要素を返す関数オブジェクト。</span>
<span class="k">struct</span> <span class="nc">first_impl</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Sig</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">result</span> <span class="p">{};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">This</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pair</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">result</span><span class="o">&lt;</span><span class="n">This</span><span class="p">(</span><span class="n">Pair</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span>
            <span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">first_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pair</span><span class="o">&gt;</span>
    <span class="k">typename</span> <span class="nc">Pair</span><span class="o">::</span><span class="n">first_type</span>
    <span class="k">operator</span><span class="p">()(</span><span class="n">Pair</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// OK、first(s1) により s1 が参照する部分マッチの先頭を指すイテレータを得る。</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">first_impl</span><span class="o">&gt;::</span><span class="n">type</span> <span class="k">const</span> <span class="n">first</span> <span class="o">=</span> <span class="p">{{}};</span>
</pre></div>
</div>
</div>
<div class="section" id="id76">
<h3>ローカル変数を参照する<a class="headerlink" href="#id76" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>上の例で見たように、<a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xpressive::ref</span></code></a> を使用するとアクション内からローカル変数を参照できる。この変数は正規表現による参照に保持されるが、これらの参照が懸垂しないよう注意が必要である。例えば以下のコードでは、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">bad_voodoo</span></code> が制御を返すと <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> に対する参照が懸垂する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="nf">bad_voodoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
    <span class="c1">// エラー！ rex はローカル変数を参照により参照しており、</span>
    <span class="c1">// bad_voodoo() が制御を返した後に懸垂する。</span>
    <span class="k">return</span> <span class="n">rex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>意味アクションを記述するときは、すべての参照が懸垂しないよう注意を払わなければならない。1 つの方法は変数を、正規表現が値により保持する共有ポインタにすることである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="nf">good_voodoo</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// val() を使って shared_ptr を値で保持する:</span>
    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">val</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
    <span class="c1">// OK、rex は整数への参照カウントを保持する。</span>
    <span class="k">return</span> <span class="n">rex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上のコードでは、<a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xpressive::val</span></code></a> を使って共有ポインタを値で保持している。アクション内のローカル変数は既定では値で保持されるため、通常この処理は必要ないが、この場合は必要である。アクションを <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><span class="pre">pi</span></code> と記述してしまうと即時実行されてしまう。これは <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><span class="pre">pi</span></code> が式テンプレートでないためである（<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><span class="pre">val</span></a><span class="pre">(</span><span class="pre">pi</span><span class="pre">)</span></code> は式テンプレートである）。</p>
<p>アクション内の変数をすべて <a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ref</span></code></a> と <a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">val</span></code></a> で包むのはうんざりするかもしれない。これを容易にするために xpressive は <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> および <a class="reference internal" href="reference/value.html#_CPPv4I0EN5boost9xpressive5valueE" title="boost::xpressive::value"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">value&lt;&gt;</span></code></a> テンプレートを提供している。対応を以下の表に示す。</p>
<table class="docutils align-default" id="id123">
<caption><span class="caption-text">reference&lt;&gt; と value&lt;&gt;</span><a class="headerlink" href="#id123" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>これは…</p></th>
<th class="head"><p>…以下と等価である</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">reference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ri</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ri</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">val</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">value</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vpi</span><span class="p">(</span><span class="n">pi</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">vpi</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>上で見たように <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> を使用する場合、始めにローカル変数を宣言してから <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> する。<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> を使用するとこの 2 段階を 1 つにまとめられる。</p>
<table class="docutils align-default" id="id124">
<caption><span class="caption-text">local&lt;&gt; 対 reference&lt;&gt;</span><a class="headerlink" href="#id124" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>これは…</p></th>
<th class="head"><p>…以下と等価である</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">local</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">i</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">reference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ri</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ri</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>上の例を <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> を使用して書き直すと以下のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">local</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 感嘆符の付いた数字は数えるが、疑問符付きのものは数えない。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">i</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/local.html#_CPPv4N5boost9xpressive5local3getEv" title="boost::xpressive::local::get"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">local::get</span></code></a> を使ってローカル変数の値にアクセスしていることに注意していただきたい。また <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> 同様、<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> が懸垂参照を作成する可能性があることに注意が必要である。</p>
</div>
<div class="section" id="semantic-actions-and-user-defined-assertions-referring-to-non-local-variables">
<span id="id77"></span><h3>非ローカル変数を参照する<a class="headerlink" href="#semantic-actions-and-user-defined-assertions-referring-to-non-local-variables" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この節の最初で、正規表現を使って単語・整数の組からなる文字列を解析して <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> に詰め込む例を見た。この例では辞書と正規表現を定義しておき、いずれかがスコープから出る前にそれらを使う必要があった。正規表現を先に定義しておき、異なる複数の辞書に書き込みたい場合はどうすればよいだろうか？ 正規表現オブジェクトに辞書に対する参照を直接組み込むのではなく、<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムに辞書を渡すようにしてはどうか。プレースホルダを定義し、意味アクション内で辞書そのものの代わりに使用する。後でいずれかの正規表現アルゴリズムを呼び出すときに実際の辞書オブジェクトへ参照を束縛できる。以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 辞書オブジェクトのプレースホルダを定義する:</span>
<span class="n">placeholder</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_map</span><span class="p">;</span>

<span class="c1">// =&gt; で区切られた単語と整数にマッチし、</span>
<span class="c1">// 結果を std::map&lt;&gt; に詰め込む</span>
<span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">[</span> <span class="n">_map</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

<span class="c1">// 空白で区切られた 1 つ以上の単語・整数の組にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">pair</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">(</span><span class="o">+</span><span class="n">_s</span> <span class="o">&gt;&gt;</span> <span class="n">pair</span><span class="p">);</span>

<span class="c1">// 解析する文字列</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

<span class="c1">// 結果を書き込む実際の辞書:</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="c1">// _map プレースホルダを実際の辞書に束縛する</span>
<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">what</span><span class="p">.</span><span class="n">let</span><span class="p">(</span> <span class="n">_map</span> <span class="o">=</span> <span class="n">result</span> <span class="p">);</span>

<span class="c1">// マッチを実行し結果の辞書に書き込む</span>
<span class="k">if</span><span class="p">(</span><span class="n">regex_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/placeholder.html#_CPPv4I0_iEN5boost9xpressive11placeholderE" title="boost::xpressive::placeholder"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">placeholder&lt;&gt;</span></code></a> を使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_map</span></code> を定義しており、これが <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> 変数の代理となる。意味アクション内でこのプレースホルダを辞書として使用できる。次に <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results</span></code></a> 構造体を定義して <code class="code docutils literal notranslate"><span class="pre">what.let(</span> <span class="pre">_map</span> <span class="pre">=</span> <span class="pre">result</span> <span class="pre">);</span></code> で実際の辞書をプレースホルダに束縛する。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> 呼び出しは、意味アクション内のプレースホルダを <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> への参照で置換したかのように振舞う。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>意味アクション内のプレースホルダは<strong>実際には</strong>実行時に変数への参照で置換されない。正規表現オブジェクトはいずれの正規表現アルゴリズムでも変更されることはないので、複数のスレッドで使用しても安全である。</p>
</div>
<p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> か <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使用する場合は、遅延束縛されたアクションの引数は少し異なる。正規表現イテレータのコンストラクタは、引数の束縛を指定する引数を受け付ける。変数をそのプレースホルダに束縛するのに使用する <a class="reference internal" href="reference/let.html#_CPPv4IDpEN5boost9xpressive3letE11unspecifiedDpRK11ArgBindings" title="boost::xpressive::let"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">let</span></code></a> 関数がある。以下のコードに方法を示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 辞書オブジェクトのプレースホルダを定義する:</span>
<span class="n">placeholder</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_map</span><span class="p">;</span>

<span class="c1">// =&gt; で区切られた単語と整数にマッチ</span>
<span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">[</span> <span class="n">_map</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

<span class="c1">// 解析する文字列</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

<span class="c1">// 結果を書き込む実際の辞書:</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="c1">// regex_iterator を作成し、すべてのマッチを検索する</span>
<span class="n">sregex_iterator</span> <span class="nf">it</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pair</span><span class="p">,</span> <span class="n">let</span><span class="p">(</span><span class="n">_map</span><span class="o">=</span><span class="n">result</span><span class="p">));</span>
<span class="n">sregex_iterator</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべてのマッチについて結果の辞書に書き込む</span>
<span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
    <span class="o">++</span><span class="n">it</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
</div>
<div class="section" id="semantic-actions-and-user-defined-assertions-user-defined-assertions">
<span id="id78"></span><h3>ユーザー定義表明<a class="headerlink" href="#semantic-actions-and-user-defined-assertions-user-defined-assertions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現の<strong>表明</strong>については慣れたものだろう。Perl だと表明の例として <code class="regexp docutils literal notranslate"><span class="pre">^</span></code> や <code class="regexp docutils literal notranslate"><span class="pre">$</span></code> があり、それぞれ文字列の先頭・終端にマッチする。xpressive では新たに表明を定義できる。カスタム表明は、マッチの成否を判断する時点で真でなければならない条件である。カスタム表明をチェックするには xpressive の <a class="reference internal" href="reference/check.html#_CPPv4I0EN5boost9xpressive5checkE11unspecifiedRK1T" title="boost::xpressive::check"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">check</span></code></a> 関数を使用する。</p>
<p>カスタム表明を定義する方法はいくつかある。一番簡単なのは関数オブジェクトを使うことである。長さが 3 文字か 6 文字のいずれかである部分文字列にマッチする部分式が必要であるとする。そのような述語を以下の構造体で定義する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 部分マッチが長さ 3 文字か 6 文字であれば真となる述語。</span>
<span class="k">struct</span> <span class="nc">three_or_six</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">sub_match</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">sub</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">sub</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">sub</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>この述語を正規表現で使うには以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 3 文字か 6 文字の単語にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">)[</span> <span class="n">check</span><span class="p">(</span><span class="n">three_or_six</span><span class="p">())</span> <span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>上の正規表現は長さが 3 文字か 6 文字の単語全体にマッチする。述語 <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">three_or_six</span></code> は、カスタム表明が結び付けられた部分式にマッチした部分を後方参照する <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> を受け取る。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>カスタム表明はマッチの成否に関与する。遅延実行されるアクションとは異なり、カスタム表明は正規表現エンジンがマッチを検索するときに即時実行される。</p>
</div>
<p>カスタム表明は意味アクションと同じ構文を用いてインライン定義することもできる。以下は同じカスタム表明をインラインで書き直したものである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 3 文字か 6 文字の単語にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">)[</span> <span class="n">check</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="o">||</span> <span class="n">length</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">==</span><span class="mi">6</span><span class="p">)</span> <span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>上記において、<a class="reference internal" href="reference/length.html#_CPPv4N5boost9xpressive6lengthE" title="boost::xpressive::length"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">length()</span></code></a> は引数の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">length</span></code> メンバ関数を呼び出す遅延関数であり、<a class="reference internal" href="reference/_.html#_CPPv4N5boost9xpressive1_E" title="boost::xpressive::_"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_</span></code></a> は <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match</span></code></a> を受け取るプレースホルダである。</p>
<p>カスタム表明のインライン記述は、コツが分かってしまえば非常に強力である。（あまり厳密でない意味での）正しい日付にのみマッチする正規表現を書いてみよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="k">const</span> <span class="n">days_per_month</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>

<span class="n">mark_tag</span> <span class="nf">month</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">day</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 「月/日/年」形式の正しい日付を検索する。</span>
<span class="n">sregex</span> <span class="n">date</span> <span class="o">=</span>
    <span class="p">(</span>
        <span class="c1">// 月は 1 以上 12 以下でなければならない</span>
        <span class="p">(</span><span class="n">month</span><span class="o">=</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="o">!</span><span class="n">_d</span><span class="p">)</span>     <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">]</span>
    <span class="o">&gt;&gt;</span>  <span class="sc">&#39;/&#39;</span>
        <span class="c1">// 日は 1 以上 31 以下でなければならない</span>
    <span class="o">&gt;&gt;</span>  <span class="p">(</span><span class="n">day</span><span class="o">=</span>   <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="o">!</span><span class="n">_d</span><span class="p">)</span>     <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">)</span> <span class="p">]</span>
    <span class="o">&gt;&gt;</span>  <span class="sc">&#39;/&#39;</span>
        <span class="c1">// 年は 1970 以上 2038 以下とする</span>
    <span class="o">&gt;&gt;</span>  <span class="p">(</span><span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span><span class="p">)</span> <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1970</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2038</span><span class="p">)</span> <span class="p">]</span>
    <span class="p">)</span>
    <span class="c1">// 月ごとの実際の日数を確認する！</span>
    <span class="p">[</span> <span class="n">check</span><span class="p">(</span> <span class="n">ref</span><span class="p">(</span><span class="n">days_per_month</span><span class="p">)[</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">month</span><span class="p">)</span><span class="mi">-1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">day</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>
<span class="p">;</span>

<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;99/99/9999 2/30/2006 2/28/2006&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">date</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">2/28/2006</span>
</pre></div>
</div>
<p>インラインのカスタム表明を使って年・月・日の値の範囲チェックを行っていることに注意していただきたい。<code class="regex-input docutils literal notranslate"><span class="pre">99/99/9999</span></code> や <code class="regex-input docutils literal notranslate"><span class="pre">2/30/2006</span></code> は正しい日付ではないため、この正規表現はマッチしない（99 の月は存在しないし、2 月には 30 日はない）。</p>
</div>
</div>
<div class="section" id="id79">
<h2><a class="toc-backref" href="#id138">記号表と属性</a><a class="headerlink" href="#id79" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id80">
<h3>概要<a class="headerlink" href="#id80" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive の正規表現で記号表を構築するには、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> を使うだけでよい。辞書のキーはマッチした文字列であり、辞書の値は意味アクションが返すデータである。xpressive の 属性 <a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> 、<a class="reference internal" href="reference/a2.html#_CPPv4N5boost9xpressive2a2E" title="boost::xpressive::a2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a2</span></code></a> 、…、<a class="reference internal" href="reference/a9.html#_CPPv4N5boost9xpressive2a9E" title="boost::xpressive::a9"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a9</span></code></a> はマッチしたキーに相当する値を保持し、意味アクション内で使用する。記号が見つからなかった場合の属性の既定値を指定することも可能である。</p>
</div>
<div class="section" id="id81">
<h3>記号表<a class="headerlink" href="#id81" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive の記号表は単純に <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> であり、キーは文字列型、値は何でもよい。例えば以下の正規表現は、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">map1</span></code> のキーにマッチし対応する値を属性 <a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> に代入する。次に意味アクションにおいて、属性 <a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> に格納した値を結果の整数に代入する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">map1</span><span class="p">;</span>
<span class="c1">// ...（辞書を埋める）</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">map1</span> <span class="p">)</span> <span class="p">[</span> <span class="n">ref</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="n">a1</span> <span class="p">];</span>
</pre></div>
</div>
<p>次のコード例は数値の名前を整数に変換する。説明は以下に示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/regex_actions.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">number_map</span><span class="p">;</span>
    <span class="n">number_map</span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">number_map</span><span class="p">[</span><span class="s">&quot;two&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">number_map</span><span class="p">[</span><span class="s">&quot;three&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">// number_map の文字列でマッチを行い</span>
    <span class="c1">// 整数値を &#39;result&#39; に格納する</span>
    <span class="c1">// 見つからなければ -1 を &#39;result&#39; に格納する</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">((</span><span class="n">a1</span> <span class="o">=</span> <span class="n">number_map</span> <span class="p">)</span> <span class="o">|</span> <span class="o">*</span><span class="n">_</span><span class="p">)</span>
        <span class="p">[</span> <span class="n">ref</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">|</span> <span class="mi">-1</span><span class="p">)];</span>

    <span class="n">regex_match</span><span class="p">(</span><span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">regex_match</span><span class="p">(</span><span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">regex_match</span><span class="p">(</span><span class="s">&quot;stuff&quot;</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">3</span>
<span class="go">2</span>
<span class="go">-1</span>
</pre></div>
</div>
<p>このプログラムは始めに、数の名前をキー文字列とし対応する整数を値とする数値の辞書を構築している。次に記号表の探索結果を表す属性 <a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> を使って静的正規表現を構築している。意味アクション内では属性を整数変数 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> に代入している。記号が見つからなければ既定値の <code class="docutils literal notranslate"><span class="pre">-1</span></code> を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> に代入する。記号が見つからなくてもマッチが成功するために、ワイルドカード <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">*</span><a class="reference internal" href="reference/_.html#_CPPv4N5boost9xpressive1_E" title="boost::xpressive::_"><span class="pre">_</span></a></code> を使っている。</p>
<p>この例のより完全版は <code class="file docutils literal notranslate"><span class="pre">libs/xpressive/example/numbers.cpp</span></code> にある。<a class="footnote-reference brackets" href="#id84" id="id82">7</a> このコードは「999,999,999」以下の数の名前（「ダース」のような特殊な数の名前が混ざっていてもよい）を数値に変換する。</p>
<p>記号表のマッチは既定では大文字小文字を区別するが、式を <a class="reference internal" href="reference/icase.html#_CPPv4I0EN5boost9xpressive5icaseE11unspecifiedRK4Expr" title="boost::xpressive::icase"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">icase</span></code></a> で囲むことにより大文字小文字を区別しないようにできる。</p>
</div>
<div class="section" id="id83">
<h3>属性<a class="headerlink" href="#id83" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>1 つの正規表現内で使用できる属性は最大 9 つであり、<a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> 、<a class="reference internal" href="reference/a2.html#_CPPv4N5boost9xpressive2a2E" title="boost::xpressive::a2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a2</span></code></a> 、…、<a class="reference internal" href="reference/a9.html#_CPPv4N5boost9xpressive2a9E" title="boost::xpressive::a9"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a9</span></code></a> という名前で <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">boost::xpressive</span></code> 名前空間内にある。属性の型は代入元の辞書の 2 番目の要素と同じである。属性の既定値は意味アクション内で <code class="samp docutils literal notranslate"><span class="pre">(a1</span> <span class="pre">|</span> <em><span class="pre">default-value</span></em><span class="pre">)</span></code> のような構文で指定する。</p>
<p>属性のスコープは適切に設定されるため、<code class="code docutils literal notranslate"><span class="pre">(</span> <span class="pre">(a1=sym1)</span> <span class="pre">&gt;&gt;</span> <span class="pre">(a1=sym2)[ref(x)=a1]</span> <span class="pre">)[ref(y)=a1]</span></code> のようなとてつもないこともできる。内側の意味アクションは内側の <a class="reference internal" href="reference/a1.html#_CPPv4N5boost9xpressive2a1E" title="boost::xpressive::a1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">a1</span></code></a> を参照し、外側の意味アクションは外側の属性を参照する。これらは型が異なっていてもよい。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>xpressive は検索を高速化するために、辞書から不可視の 3 分探索木を構築する。<code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_DISABLE_THREADS</span></code> を定義した場合、この不可視の 3 分木は検索後に「毎回自身を再構築」し、前回の検索頻度に基づいて次回の検索効率を向上する。</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id84"><span class="brackets"><a class="fn-backref" href="#id82">7</a></span></dt>
<dd><p>この例を寄贈してくれた David Jenkins に感謝する。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id85">
<h2><a class="toc-backref" href="#id139">地域化と正規表現特性</a><a class="headerlink" href="#id85" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="id86">
<h3>概要<a class="headerlink" href="#id86" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>文字列に対する正規表現マッチにおいて、ロカール依存の情報が必要になる場合がよくある。例えば、大文字小文字を区別しない比較はどのように行うのか？ ロカール依存の振る舞いは特性（traits）クラスが取り扱う。xpressive は <a class="reference internal" href="reference/cpp_regex_traits.html#_CPPv4I0EN5boost9xpressive16cpp_regex_traitsE" title="boost::xpressive::cpp_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">cpp_regex_traits&lt;&gt;</span></code></a> 、 <a class="reference internal" href="reference/c_regex_traits.html#_CPPv4I0EN5boost9xpressive14c_regex_traitsE" title="boost::xpressive::c_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">c_regex_traits&lt;&gt;</span></code></a> および <a class="reference internal" href="reference/null_regex_traits.html#_CPPv4I0EN5boost9xpressive17null_regex_traitsE" title="boost::xpressive::null_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">null_regex_traits&lt;&gt;</span></code></a> の 3 つの特性クラステンプレートを提供する。1 番目のものは <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::locale</span></code> をラップし、2 番目のものはグローバルな C ロカールをラップする。3 番目は非文字データを検索するのに使用する控えの特性型である。すべての特性テンプレートは<a class="reference internal" href="#concepts-traits-requirements"><span class="std std-ref">正規表現特性のコンセプト</span></a>に適合する。</p>
</div>
<div class="section" id="id87">
<h3>既定の正規表現特性を設定する<a class="headerlink" href="#id87" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>既定では xpressive はすべてにパターンに対して <a class="reference internal" href="reference/cpp_regex_traits.html#_CPPv4I0EN5boost9xpressive16cpp_regex_traitsE" title="boost::xpressive::cpp_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">cpp_regex_traits&lt;&gt;</span></code></a> を使用する。これにより、すべての正規表現オブジェクトはグローバルな <code class="xref py py-class docutils literal notranslate"><span class="pre">std::locale</span></code> を使用する。<code class="xref c c-macro docutils literal notranslate"><span class="pre">BOOST_XPRESSIVE_USE_C_TRAITS</span></code> を定義してコンパイルすると、xpressive の既定は <a class="reference internal" href="reference/c_regex_traits.html#_CPPv4I0EN5boost9xpressive14c_regex_traitsE" title="boost::xpressive::c_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">c_regex_traits&lt;&gt;</span></code></a> になる。</p>
</div>
<div class="section" id="id88">
<h3>動的正規表現でカスタムの特性を使用する<a class="headerlink" href="#id88" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>カスタムの特性オブジェクトを使う動的正規表現を作成するには、<a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler&lt;&gt;</span></code></a> を使わなければならない。基本的な方法を以下の例に示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// グローバルな C ロカールを使う regex_compiler を宣言する</span>
<span class="n">regex_compiler</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="n">c_regex_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">crxcomp</span><span class="p">;</span>
<span class="n">cregex</span> <span class="n">crx</span> <span class="o">=</span> <span class="n">crxcomp</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">w+&quot;</span> <span class="p">);</span>

<span class="c1">// カスタムの std::locale を使う regex_compiler を宣言する</span>
<span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">loc</span> <span class="o">=</span> <span class="cm">/* ... ここでロカールを作成する ... */</span><span class="p">;</span>
<span class="n">regex_compiler</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="n">cpp_regex_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">cpprxcomp</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
<span class="n">cregex</span> <span class="n">cpprx</span> <span class="o">=</span> <span class="n">cpprxcomp</span><span class="p">.</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;</span><span class="se">\\</span><span class="s">w+&quot;</span> <span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/regex_compiler.html#_CPPv4I000EN5boost9xpressive14regex_compilerE" title="boost::xpressive::regex_compiler"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_compiler</span></code></a> オブジェクトは正規表現のファクトリとして動作する。これらは一度ロカールを与えておくと、以降作成する正規表現はそのロカールを使用するようになる。</p>
</div>
<div class="section" id="id89">
<h3>静的正規表現でカスタムの特性を使用する<a class="headerlink" href="#id89" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>個々の静的正規表現に異なる特性群を使用したい場合は、<a class="reference internal" href="reference/imbue.html#_CPPv4I0EN5boost9xpressive5imbueERK6Locale" title="boost::xpressive::imbue"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">imbue</span></code></a> 特殊パターン修飾子を使用する。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// グローバルな C ロカールを使う正規表現を定義する</span>
<span class="n">c_regex_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">ctraits</span><span class="p">;</span>
<span class="n">sregex</span> <span class="n">crx</span> <span class="o">=</span> <span class="n">imbue</span><span class="p">(</span><span class="n">ctraits</span><span class="p">)(</span> <span class="o">+</span><span class="n">_w</span> <span class="p">);</span>

<span class="c1">// カスタムの std::locale を使う正規表現を定義する</span>
<span class="n">std</span><span class="o">::</span><span class="n">locale</span> <span class="n">loc</span> <span class="o">=</span> <span class="cm">/* ... ここでロカールを作成する ... */</span><span class="p">;</span>
<span class="n">cpp_regex_traits</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">cpptraits</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">cpprx1</span> <span class="o">=</span> <span class="n">imbue</span><span class="p">(</span><span class="n">cpptraits</span><span class="p">)(</span> <span class="o">+</span><span class="n">_w</span> <span class="p">);</span>

<span class="c1">// 上記の短縮形</span>
<span class="n">sregex</span> <span class="n">cpprx2</span> <span class="o">=</span> <span class="n">imbue</span><span class="p">(</span><span class="n">loc</span><span class="p">)(</span> <span class="o">+</span><span class="n">_w</span> <span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/imbue.html#_CPPv4I0EN5boost9xpressive5imbueERK6Locale" title="boost::xpressive::imbue"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">imbue</span></code></a> パターン修飾子はパターン全体を囲まなければならない。静的正規表現の一部だけを <a class="reference internal" href="reference/imbue.html#_CPPv4I0EN5boost9xpressive5imbueERK6Locale" title="boost::xpressive::imbue"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">imbue</span></code></a> するとエラーになる。例えば、</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// エラー！ 正規表現の一部だけを imbue() することはできない</span>
<span class="n">sregex</span> <span class="n">error</span> <span class="o">=</span> <span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="n">imbue</span><span class="p">(</span><span class="n">loc</span><span class="p">)(</span> <span class="n">_w</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="null-regex-traits">
<h3><a class="reference internal" href="reference/null_regex_traits.html#_CPPv4I0EN5boost9xpressive17null_regex_traitsE" title="boost::xpressive::null_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">null_regex_traits</span></code></a> で非文字データを検索する<a class="headerlink" href="#null-regex-traits" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive の静的正規表現では、パターンの検索は文字シーケンス内に限定されない。生のバイト、整数、その他<a class="reference internal" href="#concepts-chart-requirements"><span class="std std-ref">文字のコンセプト</span></a>に適合するものであれば何でも検索できる。このような場合、<a class="reference internal" href="reference/null_regex_traits.html#_CPPv4I0EN5boost9xpressive17null_regex_traitsE" title="boost::xpressive::null_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">null_regex_traits&lt;&gt;</span></code></a> を使うと簡単である。<a class="reference internal" href="#concepts-traits-requirements"><span class="std std-ref">正規表現特性のコンセプト</span></a>の控えの実装であり、文字クラスを無視し、大文字小文字に関する変換を一切行わない。</p>
<p>例えば整数列からパターンを検索する静的正規表現は、<a class="reference internal" href="reference/null_regex_traits.html#_CPPv4I0EN5boost9xpressive17null_regex_traitsE" title="boost::xpressive::null_regex_traits"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">null_regex_traits&lt;&gt;</span></code></a> を使って以下のように記述できる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 検索する整数データ</span>
<span class="kt">int</span> <span class="k">const</span> <span class="n">data</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>

<span class="c1">// 整数を検索する null_regex_traits&lt;&gt; オブジェクトを作成する...</span>
<span class="n">null_regex_traits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nul</span><span class="p">;</span>

<span class="c1">// 正規表現オブジェクトに null_regex_traits を指示する...</span>
<span class="n">basic_regex</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">rex</span> <span class="o">=</span> <span class="n">imbue</span><span class="p">(</span><span class="n">nul</span><span class="p">)(</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="p">((</span><span class="n">set</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">|</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">match_results</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span> <span class="o">*&gt;</span> <span class="n">what</span><span class="p">;</span>

<span class="c1">// 整数の配列からパターンを検索する...</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">7</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>

<span class="n">assert</span><span class="p">(</span><span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">matched</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span> <span class="o">==</span> <span class="mi">6</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id90">
<h2><a class="toc-backref" href="#id140">ヒント集</a><a class="headerlink" href="#id90" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のヒント集に従うと、xpressive の効率を最大限に引き出せる。</p>
<div class="section" id="id91">
<h3>パターンのコンパイルは一度とし、再利用せよ<a class="headerlink" href="#id91" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>正規表現のコンパイル（動的、静的によらない）は、マッチや検索の実行より<strong>何倍もの</strong>コストを要する。可能であれば <a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> のコンパイルは一度だけにし、あとは再利用せよ（事あるごとに再作成してはならない）。</p>
<p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトはいかなる正規表現アルゴリズムによっても変更されないので、正規表現（と所属するすべての文法）の初期化が完了しさえすれば完全にスレッド安全である。パターンの再利用で一番簡単な方法は、<a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> オブジェクトを static const にすることである。</p>
</div>
<div class="section" id="id92">
<h3>match_results&lt;&gt; オブジェクトを再利用せよ<a class="headerlink" href="#id92" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトは動的に確保したメモリをキャッシュする。そのため、正規表現検索を何度も行う場合は同じ <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを再利用するほうがずっとよい。</p>
<p>注意：<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトはスレッド安全でないため、スレッドを超えて再利用してはならない。</p>
</div>
<div class="section" id="id93">
<h3>match_results&lt;&gt; オブジェクトを引数に取るアルゴリズムを使用せよ<a class="headerlink" href="#id93" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>これも同様である。検索を複数回行う場合は、<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを引数に取る正規表現アルゴリズムを使用し、毎回同じ <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを使用すべきだ。<a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> オブジェクトを与えないと一時オブジェクトが作成され、アルゴリズムが結果を返すときに破棄される。オブジェクトがキャッシュしていたメモリは解放され、次回また再確保されてしまう。</p>
</div>
<div class="section" id="null">
<h3>null 終端文字列に対してはイテレータの範囲を引数に取るアルゴリズムを使用せよ<a class="headerlink" href="#null" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive は <a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> および <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> アルゴリズムについて、C 形式の null 終端文字列を操作する多重定義を提供している。イテレータの範囲を引数に取る多重定義を使用すべきだ。null 終端文字列を正規表現アルゴリズムに渡すと、終端のイテレータを計算するために <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">strlen</span></code> が呼び出されてしまう。文字列の長さが事前に分かっているのであれば、<code class="docutils literal notranslate"><span class="pre">[begin,end)</span></code> 組を取る正規表現を呼び出してこのオーバーヘッドを回避できる。</p>
</div>
<div class="section" id="id94">
<h3>静的正規表現を使用せよ<a class="headerlink" href="#id94" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>静的正規表現は同じ内容の動的版に対して、平均で約 10% から 15% 高速である。これだけでも静的版に慣れておく価値がある。</p>
</div>
<div class="section" id="regex-constants-syntax-option-type-optimize">
<h3><a class="reference internal" href="reference/regex_constants.syntax_option_type.html#_CPPv4N5boost9xpressive15regex_constants18syntax_option_type8optimizeE" title="boost::xpressive::regex_constants::syntax_option_type::optimize"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">regex_constants::syntax_option_type::optimize</span></code></a> を理解せよ<a class="headerlink" href="#regex-constants-syntax-option-type-optimize" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><a class="reference internal" href="reference/regex_constants.syntax_option_type.html#_CPPv4N5boost9xpressive15regex_constants18syntax_option_type8optimizeE" title="boost::xpressive::regex_constants::syntax_option_type::optimize"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">optimize</span></code></a> フラグを正規表現コンパイラに渡すと、パターンの解析により多くの時間をかけるようになる。この結果、パターンによっては実行が高速になるが、コンパイル時間が長くなり、しばしばパターンが要するメモリの量が増える。パターンを再利用するのであれば <a class="reference internal" href="reference/regex_constants.syntax_option_type.html#_CPPv4N5boost9xpressive15regex_constants18syntax_option_type8optimizeE" title="boost::xpressive::regex_constants::syntax_option_type::optimize"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">optimize</span></code></a> は効果があると考えてよい。パターンを一度しか使用しないのであれば、<a class="reference internal" href="reference/regex_constants.syntax_option_type.html#_CPPv4N5boost9xpressive15regex_constants18syntax_option_type8optimizeE" title="boost::xpressive::regex_constants::syntax_option_type::optimize"><code class="xref cpp cpp-enumerator docutils literal notranslate"><span class="pre">optimize</span></code></a> は避けるべきだ。</p>
</div>
<div class="section" id="id95">
<h3>よくある落とし穴<a class="headerlink" href="#id95" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>xpressive の落とし穴に足を踏み入れないように、以下のことを覚えておくとよい。</p>
<div class="section" id="id96">
<h4>文法は単一のスレッドで作成せよ<a class="headerlink" href="#id96" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>静的正規表現では正規表現を入れ子にして文法を構築するが、外側の正規表現をコンパイルすると外側と内側の両方の正規表現オブジェクト、およびそれらが直接・間接的に参照するすべての正規表現オブジェクトが更新される。そのため、グローバルな正規表現オブジェクトが文法に関与すると危険である。単一のスレッドから正規表現文法を構築するのが最善である。一度構築してしまえば、正規表現文法は複数のスレッドから問題なく実行できる。</p>
</div>
<div class="section" id="id97">
<h4>入れ子の数量子に注意せよ<a class="headerlink" href="#id97" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>これは多くの正規表現エンジンに共通の落とし穴であり、パターンによっては指数的に効率が悪化する。よくあるのは <code class="regexp docutils literal notranslate"><span class="pre">(a*)*</span></code> のようにパターン内の数量子付きの項が他の数量子に入れ子になっているというものだが、多くの場合発見しにくいのが問題である。数量子が入れ子になっているパターンには注意せよ。</p>
</div>
</div>
</div>
<div class="section" id="id98">
<h2><a class="toc-backref" href="#id141">コンセプト</a><a class="headerlink" href="#id98" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="chart">
<span id="concepts-chart-requirements"></span><h3>CharT の要件<a class="headerlink" href="#chart" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>型 <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">BidiIterT</span></code> を <a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> のテンプレート引数とすると、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">iterator_traits&lt;BidiIterT&gt;::value_type</span></code> が <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> である。型 <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> は自明な（trivial）既定コンストラクタ、コピーコンストラクタ、代入演算子、およびデストラクタをもたなければならない。さらにオブジェクトに関しては以下の要件を満たさなければならない。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> 型、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span> <span class="pre">const</span></code> 型、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">int</span></code> 型である。</p>
<table class="docutils align-default" id="id125">
<caption><span class="caption-text">CharT の要件</span><a class="headerlink" href="#id125" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>式</p></th>
<th class="head"><p>戻り値の型</p></th>
<th class="head"><p>表明、備考、事前・事後条件</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">CharT</span> <span class="pre">c</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p>既定のコンストラクタ（自明でなければならない）。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">CharT</span> <span class="pre">c(c1)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p>コピーコンストラクタ（自明でなければならない）。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">=</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p>代入演算子（自明でなければならない）。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">==</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> の値が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> と同じであれば <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">!=</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> が等値でなければ <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">&lt;</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> の値が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> より小さければ <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">&gt;</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> の値が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> より大きければ <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">&lt;=</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> より小さいか等値であれば <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">c1</span> <span class="pre">&gt;=</span> <span class="pre">c2</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c1</span></code> が <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c2</span></code> より大きいか等値であれば <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="code docutils literal notranslate"><span class="pre">intmax_t</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">c1</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> は整数型に変換可能でなければならない。</p></td>
</tr>
<tr class="row-even"><td><p><code class="code docutils literal notranslate"><span class="pre">CharT</span> <span class="pre">c(i);</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> は整数型から構築可能でなければならない。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="concepts-traits-requirements">
<span id="id99"></span><h3>特性の要件<a class="headerlink" href="#concepts-traits-requirements" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下の表において <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> 型の文字コンテナについて型と関数を定義する特性クラスである。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">u</span></code> は <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">X</span></code> 型のオブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">v</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">X</span></code> 型のオブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">p</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">CharT*</span></code> 型の値、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">I1</span></code> と <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">I2</span></code> は <code class="docutils literal notranslate"><span class="pre">Input</span> <span class="pre">Iterator</span></code>、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">CharT</span></code> 型の値、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::string_type</span></code> 型のオブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">cs</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">X::string_type</span></code> 型のオブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">b</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code> 型の値、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">int</span></code> 型の値、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">F1</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">F2</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">CharT*</span></code> 型の値、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">loc</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::locale_type</span></code> 型のオブジェクト、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">ch</span></code> は <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span></code> のオブジェクトである。</p>
<table class="docutils align-default" id="id126">
<caption><span class="caption-text">特性の要件</span><a class="headerlink" href="#id126" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>式</p></th>
<th class="head"><p>戻り値の型</p></th>
<th class="head"><p>表明、備考、事前・事後条件</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">X</span><span class="pre">::</span><span class="pre">char_type</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p><a class="reference internal" href="reference/basic_regex.html#_CPPv4I0EN5boost9xpressive11basic_regexE" title="boost::xpressive::basic_regex"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">basic_regex&lt;&gt;</span></code></a> クラステンプレートを実装する文字コンテナ型。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">X</span><span class="pre">::</span><span class="pre">string_type</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::basic_string&lt;CharT&gt;</span></code> か <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::vector&lt;CharT&gt;</span></code></p></td>
<td><p>なし。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">X</span><span class="pre">::</span><span class="pre">locale_type</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">（実装定義）</span></code></p></td>
<td><p>特性クラスが使用するロカールを表現する、コピー構築可能な型。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">X</span><span class="pre">::</span><span class="pre">char_class_type</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">（実装定義）</span></code></p></td>
<td><p>個々の文字分類（文字クラス）を表現するビットマスク型。この型の複数の値をビット和すると別の有効な値を得る。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">X</span><span class="pre">::</span><span class="pre">hash</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">char</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">0</span></code> 以上 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">UCHAR_MAX</span></code> 以下の値を生成する。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">widen</span><span class="pre">(</span><span class="pre">ch</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code></p></td>
<td><p>指定した <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">char</span></code> のワイド版を <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">CharT</span></code> で返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">in_range</span><span class="pre">(</span><span class="pre">r1</span><span class="pre">,</span> <span class="pre">r2</span><span class="pre">,</span> <span class="pre">c</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>任意の文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">r1</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">r2</span></code> について、<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">r1</span> <span class="pre">&lt;=</span> <span class="pre">c</span> <span class="pre">&amp;&amp;</span> <span class="pre">c</span> <span class="pre">&lt;=</span> <span class="pre">r2</span></code> であれば <code class="docutils literal notranslate"><span class="pre">true</span></code> を返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">r1</span> <span class="pre">&lt;=</span> <span class="pre">r2</span></code> でなければならない。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">in_range_nocase</span><span class="pre">(</span><span class="pre">r1</span><span class="pre">,</span> <span class="pre">r2</span><span class="pre">,</span> <span class="pre">c</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>任意の文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">r1</span></code> と <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">r2</span></code> について、<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">translate_nocase</span><span class="pre">(</span><span class="pre">d</span><span class="pre">)</span> <span class="pre">==</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">translate_case</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span></code> かつ <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">r1</span> <span class="pre">&lt;=</span> <span class="pre">d</span> <span class="pre">&amp;&amp;</span> <span class="pre">d</span> <span class="pre">&lt;=</span> <span class="pre">r2</span></code> となる文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">d</span></code> が存在すれば <code class="docutils literal notranslate"><span class="pre">true</span></code> を返す。<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">r1</span> <span class="pre">&lt;=</span> <span class="pre">r2</span></code> でなければならない。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">translate</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::char_type</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> と等価、つまり <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">translate</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span> <span class="pre">==</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">translate</span><span class="pre">(</span><span class="pre">d</span><span class="pre">)</span></code> となるような文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">d</span></code> を返す。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">translate_nocase</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::char_type</span></code></p></td>
<td><p>大文字小文字を区別せずに比較したとき <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> と等価、つまり <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">translate_nocase</span><span class="pre">(</span><span class="pre">c</span><span class="pre">)</span> <span class="pre">==</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">translate_nocase</span><span class="pre">(</span><span class="pre">C</span><span class="pre">)</span></code> となるような文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">C</span></code>。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">transform</span><span class="pre">(</span><span class="pre">F1</span><span class="pre">,</span> <span class="pre">F2</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::string_type</span></code></p></td>
<td><p>イテレータ範囲 <code class="docutils literal notranslate"><span class="pre">[F1,</span> <span class="pre">F2)</span></code> が示す文字シーケンスのソートキーを返す。文字シーケンス <code class="docutils literal notranslate"><span class="pre">[G1,</span> <span class="pre">G2)</span></code> が文字シーケンス <code class="docutils literal notranslate"><span class="pre">[H1,</span> <span class="pre">H2)</span></code> の前にソートされる場合に <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">transform</span><span class="pre">(</span><span class="pre">G1</span><span class="pre">,</span> <span class="pre">G2</span><span class="pre">)</span> <span class="pre">&lt;</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">transform</span><span class="pre">(</span><span class="pre">H1</span><span class="pre">,</span> <span class="pre">H2</span><span class="pre">)</span></code> とならなければならない。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">transform_primary</span><span class="pre">(</span><span class="pre">F1</span><span class="pre">,</span> <span class="pre">F2</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::string_type</span></code></p></td>
<td><p>イテレータ範囲 <code class="docutils literal notranslate"><span class="pre">[F1,</span> <span class="pre">F2)</span></code> が示す文字シーケンスのソートキーを返す。大文字小文字を区別せずにソートして文字シーケンス <code class="docutils literal notranslate"><span class="pre">[G1,</span> <span class="pre">G2)</span></code> が文字シーケンス <code class="docutils literal notranslate"><span class="pre">[H1,</span> <span class="pre">H2)</span></code> の前に現れる場合に <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">transform_primary</span><span class="pre">(</span><span class="pre">G1</span><span class="pre">,</span> <span class="pre">G2</span><span class="pre">)</span> <span class="pre">&lt;</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">transform_primary</span><span class="pre">(</span><span class="pre">H1</span><span class="pre">,</span> <span class="pre">H2</span><span class="pre">)</span></code> とならなければならない。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">lookup_classname</span><span class="pre">(</span><span class="pre">F1</span><span class="pre">,</span> <span class="pre">F2</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::char_class_type</span></code></p></td>
<td><p>イテレータ範囲 <code class="docutils literal notranslate"><span class="pre">[F1,</span> <span class="pre">F2)</span></code> が示す文字シーケンスを、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">isctype</span></code> に渡せるビットマスク型に変換する。<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">lookup_classname</span></code> が返した値同士でビット和を取っても安全である。文字シーケンスがXが解釈できる文字クラス名でなければ <code class="docutils literal notranslate"><span class="pre">0</span></code> を返す。文字シーケンス内の大文字小文字の違いで戻り値が変化することはない。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">lookup_collatename</span><span class="pre">(</span><span class="pre">F1</span><span class="pre">,</span> <span class="pre">F2</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::string_type</span></code></p></td>
<td><p>イテレータ範囲 <code class="docutils literal notranslate"><span class="pre">[F1,</span> <span class="pre">F2)</span></code> が示す文字シーケンスが構成する照合要素を表す文字シーケンスを返す。文字シーケンスが正しい照合要素でなければ空文字列を返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">isctype</span><span class="pre">(</span><span class="pre">c</span><span class="pre">,</span> <span class="pre">v</span><span class="pre">.</span><span class="pre">lookup_classname</span><span class="pre">(</span><span class="pre">F1</span><span class="pre">,</span> <span class="pre">F2</span><span class="pre">)</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">bool</span></code></p></td>
<td><p>文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> が、イテレータ範囲 <code class="docutils literal notranslate"><span class="pre">[F1,</span> <span class="pre">F2)</span></code> が示す文字クラスのメンバであれば真を返す。それ以外は偽を返す。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">value</span><span class="pre">(</span><span class="pre">c</span><span class="pre">,</span> <span class="pre">i</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">int</span></code></p></td>
<td><p>文字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> が基数 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> で有効な数字であれば、数字 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">c</span></code> の基数 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> での数値を返す。<a class="footnote-reference brackets" href="#id104" id="id100">8</a> それ以外の場合は <code class="docutils literal notranslate"><span class="pre">-1</span></code> を返す。</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">u</span><span class="pre">.</span><span class="pre">imbue</span><span class="pre">(</span><span class="pre">loc</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::locale_type</span></code></p></td>
<td><p>ロカール <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">loc</span></code> を <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">u</span></code> に指示する。<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">u</span></code> が直前まで使用していたロカールを返す。</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">v</span><span class="pre">.</span><span class="pre">getloc</span><span class="pre">(</span><span class="pre">)</span></code></p></td>
<td><p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">X::locale_type</span></code></p></td>
<td><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">v</span></code> が使用中のロカールを返す。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id101">
<h3>謝辞<a class="headerlink" href="#id101" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この節は <a class="reference external" href="http://www.boost.org/libs/regex/">Boost.Regex</a> ドキュメントの同じページと、正規表現を標準ライブラリに追加することになった<a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">草案</a>をもとに作成した。</p>
<dl class="footnote brackets">
<dt class="label" id="id104"><span class="brackets"><a class="fn-backref" href="#id100">8</a></span></dt>
<dd><p><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> の値は 8 、10 、16 のいずれかである。</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id105">
<h2><a class="toc-backref" href="#id142">例</a><a class="headerlink" href="#id105" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下に 6 つの完全なプログラム例を挙げる。</p>
<div class="section" id="examples-see-if-a-whole-string-matches-a-regex">
<span id="id106"></span><h3>文字列全体が正規表現にマッチするか調べる<a class="headerlink" href="#examples-see-if-a-whole-string-matches-a-regex" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>導入項にもあった例である。利便性のために再掲する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span><span class="p">(</span> <span class="s">&quot;hello world!&quot;</span> <span class="p">);</span>

    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">w+) (</span><span class="se">\\</span><span class="s">w+)!&quot;</span> <span class="p">);</span>
    <span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">regex_match</span><span class="p">(</span> <span class="n">hello</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rex</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// マッチ全体</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 1 番目の捕捉</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 2 番目の捕捉</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">hello world!</span>
<span class="go">hello</span>
<span class="go">world</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-see-if-a-string-contains-a-sub-string-that-matches-a-regex">
<span id="id107"></span><h3>文字列が正規表現にマッチする部分文字列を含むか調べる<a class="headerlink" href="#examples-see-if-a-string-contains-a-sub-string-that-matches-a-regex" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>この例では、カスタムの <a class="reference internal" href="reference/mark_tag.html#_CPPv4N5boost9xpressive8mark_tagE" title="boost::xpressive::mark_tag"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">mark_tag</span></code></a> を使ってパターンを読みやすくしている点に注意していただきたい。後で <a class="reference internal" href="reference/mark_tag.html#_CPPv4N5boost9xpressive8mark_tagE" title="boost::xpressive::mark_tag"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">mark_tag</span></code></a> を <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results&lt;&gt;</span></code></a> の添字に使っている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">&quot;I was born on 5/30/1973 at 7am.&quot;</span><span class="p">;</span>

    <span class="c1">// s1 、s2 、... よりも意味のある名前でカスタムの mark_tags を定義する</span>
    <span class="n">mark_tag</span> <span class="n">day</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">month</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">year</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">delim</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

    <span class="c1">// この正規表現は日付を検索する</span>
    <span class="n">cregex</span> <span class="n">date</span> <span class="o">=</span> <span class="p">(</span><span class="n">month</span><span class="o">=</span> <span class="n">repeat</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_d</span><span class="p">))</span>           <span class="c1">// 先頭に月があり ...</span>
               <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">delim</span><span class="o">=</span> <span class="p">(</span><span class="n">set</span><span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">,</span><span class="sc">&#39;-&#39;</span><span class="p">))</span>            <span class="c1">// その後ろに区切りがあり ...</span>
               <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">day</span><span class="o">=</span>   <span class="n">repeat</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_d</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">delim</span>  <span class="c1">// さらに後ろに日と、同じ区切りがあり ...</span>
               <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">year</span><span class="o">=</span>  <span class="n">repeat</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span><span class="p">));</span>    <span class="c1">// 最後に年がある。</span>

    <span class="n">cmatch</span> <span class="n">what</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">regex_search</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">date</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&gt;&gt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="o">&gt;&gt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// マッチ全体</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&gt;&gt;</span> <span class="n">what</span><span class="p">[</span><span class="n">day</span><span class="p">]</span>   <span class="o">&gt;&gt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 日</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&gt;&gt;</span> <span class="n">what</span><span class="p">[</span><span class="n">month</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 月</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&gt;&gt;</span> <span class="n">what</span><span class="p">[</span><span class="n">year</span><span class="p">]</span>  <span class="o">&gt;&gt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 年</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&gt;&gt;</span> <span class="n">what</span><span class="p">[</span><span class="n">delim</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// 区切り</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">5/30/1973</span>
<span class="go">30</span>
<span class="go">5</span>
<span class="go">1973</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-replace-all-sub-strings-that-match-a-regex">
<span id="id108"></span><h3>正規表現にマッチした部分文字列をすべて置換する<a class="headerlink" href="#examples-replace-all-sub-strings-that-match-a-regex" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のプログラムは文字列内の日付を検索し、擬似 HTML でマークアップする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span> <span class="s">&quot;I was born on 5/30/1973 at 7am.&quot;</span> <span class="p">);</span>

    <span class="c1">// 本質的には前の例と同じ正規表現だが、動的正規表現を使っている</span>
    <span class="n">sregex</span> <span class="n">date</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">d{1,2})([/-])(</span><span class="se">\\</span><span class="s">d{1,2})</span><span class="se">\\</span><span class="s">2((?:</span><span class="se">\\</span><span class="s">d{2}){1,2})&quot;</span> <span class="p">);</span>

    <span class="c1">// Perl と同様、$&amp; は正規表現にマッチした部分文字列を参照する</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">format</span><span class="p">(</span> <span class="s">&quot;&lt;date&gt;$&amp;&lt;/date&gt;&quot;</span> <span class="p">);</span>

    <span class="n">str</span> <span class="o">=</span> <span class="n">regex_replace</span><span class="p">(</span> <span class="n">str</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">I was born on &lt;date&gt;5/30/1973&lt;/date&gt; at 7am.</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-find-all-the-sub-strings-that-match-a-regex-and-step-through-them-one-at-a-time">
<span id="id109"></span><h3>正規表現にマッチする部分文字列をすべて検索し、1 つずつ辿る<a class="headerlink" href="#examples-find-all-the-sub-strings-that-match-a-regex-and-step-through-them-one-at-a-time" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のプログラムはワイド文字列から単語を検索する。<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex_iterator</span></code> を使う。<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsregex_iterator</span></code> を参照はがしすると <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">wsmatch</span></code> オブジェクトが得られることに注意していただきたい。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">wstring</span> <span class="n">str</span><span class="p">(</span> <span class="sa">L</span><span class="s">&quot;This is his face.&quot;</span> <span class="p">);</span>

    <span class="c1">// 単語全体を検索する</span>
    <span class="n">wsregex</span> <span class="n">token</span> <span class="o">=</span> <span class="o">+</span><span class="n">alnum</span><span class="p">;</span>

    <span class="n">wsregex_iterator</span> <span class="n">cur</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">token</span> <span class="p">);</span>
    <span class="n">wsregex_iterator</span> <span class="n">end</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">cur</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">wsmatch</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">what</span> <span class="o">=</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sa">L</span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">This</span>
<span class="go">is</span>
<span class="go">his</span>
<span class="go">face</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-split-a-string-into-tokens-that-each-match-a-regex">
<span id="id110"></span><h3>文字列をそれぞれ正規表現にマッチするトークンに分割する<a class="headerlink" href="#examples-split-a-string-into-tokens-that-each-match-a-regex" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のプログラムは文字列からレースのタイムを検索し、はじめに分、次に秒を表示する。<a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使っている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span> <span class="s">&quot;Eric: 4:40, Karl: 3:35, Francesca: 2:32&quot;</span> <span class="p">);</span>

    <span class="c1">// レースのタイムを検索する</span>
    <span class="n">sregex</span> <span class="n">time</span> <span class="o">=</span> <span class="n">sregex</span><span class="o">::</span><span class="n">compile</span><span class="p">(</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">d):(</span><span class="se">\\</span><span class="s">d</span><span class="se">\\</span><span class="s">d)&quot;</span> <span class="p">);</span>

    <span class="c1">// 各マッチについて、トークンイテレータは始めに1番目のマーク済み部分式の値</span>
    <span class="c1">// 次に2番目のマーク済み部分式の値をとらなければならない</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">subs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>

    <span class="n">sregex_token_iterator</span> <span class="n">cur</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">time</span><span class="p">,</span> <span class="n">subs</span> <span class="p">);</span>
    <span class="n">sregex_token_iterator</span> <span class="n">end</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">cur</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">4</span>
<span class="go">40</span>
<span class="go">3</span>
<span class="go">35</span>
<span class="go">2</span>
<span class="go">32</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-split-a-string-using-a-regex-as-a-delimiter">
<span id="id111"></span><h3>正規表現を区切りとして文字列を分割する<a class="headerlink" href="#examples-split-a-string-using-a-regex-as-a-delimiter" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>以下のプログラムは HTML でマークアップされたテキストからマークアップを除去する。HTML タグにマッチする正規表現と、文字列内の正規表現にマッチ<strong>しなかった</strong>部分を返す <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使っている。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span> <span class="s">&quot;Now &lt;bold&gt;is the time &lt;i&gt;for all good men&lt;/i&gt;&quot;</span>
                     <span class="s">&quot; to come to the aid of their&lt;/bold&gt; country.&quot;</span> <span class="p">);</span>

    <span class="c1">// HTML タグを検索する</span>
    <span class="n">sregex</span> <span class="n">html</span> <span class="o">=</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">optional</span><span class="p">(</span><span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;&gt;&#39;</span><span class="p">;</span>

    <span class="c1">// 以下のようにトークンイテレータに -1 を与えると</span>
    <span class="c1">// 正規表現にマッチ*しなかった*文字列部分を表示する。</span>
    <span class="n">sregex_token_iterator</span> <span class="n">cur</span><span class="p">(</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">html</span><span class="p">,</span> <span class="mi">-1</span> <span class="p">);</span>
    <span class="n">sregex_token_iterator</span> <span class="n">end</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;</span> <span class="n">cur</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">cur</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;{&#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">cur</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;}&#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">{Now }{is the time }{for all good men}{ to come to the aid of their}{ country.}</span>
</pre></div>
</div>
</div>
<div class="section" id="examples-display-a-tree-of-nested-results">
<span id="id112"></span><h3>入れ子になった結果木を表示する<a class="headerlink" href="#examples-display-a-tree-of-nested-results" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>入れ子になった結果木を表示する方法を以下のヘルパクラスで示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 入れ子になった結果を字下げ付きで std::cout に出力する</span>
<span class="k">struct</span> <span class="nc">output_nested_results</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">tabs_</span><span class="p">;</span>

    <span class="n">output_nested_results</span><span class="p">(</span> <span class="kt">int</span> <span class="n">tabs</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">tabs_</span><span class="p">(</span> <span class="n">tabs</span> <span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">BidiIterT</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()(</span> <span class="n">match_results</span><span class="o">&lt;</span> <span class="n">BidiIterT</span> <span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">what</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="c1">// はじめに字下げする</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="nc">std</span><span class="o">::</span><span class="n">iterator_traits</span><span class="o">&lt;</span> <span class="n">BidiIterT</span> <span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">char_type</span><span class="p">;</span>
        <span class="n">char_type</span> <span class="n">space_ch</span> <span class="o">=</span> <span class="n">char_type</span><span class="p">(</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">char_type</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="p">),</span> <span class="n">tabs_</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">space_ch</span> <span class="p">);</span>

        <span class="c1">// マッチを出力する</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

        <span class="c1">// 入れ子のマッチを出力する</span>
        <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span>
            <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">begin</span><span class="p">(),</span>
            <span class="n">what</span><span class="p">.</span><span class="n">nested_results</span><span class="p">().</span><span class="n">end</span><span class="p">(),</span>
            <span class="n">output_nested_results</span><span class="p">(</span> <span class="n">tabs_</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="reference/index.html" class="btn btn-neutral float-right" title="リファレンス" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="preface.html" class="btn btn-neutral float-left" title="前口上" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2020, exeal

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
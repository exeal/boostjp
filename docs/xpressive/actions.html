

<!DOCTYPE html>
<html class="writer-html5" lang="ja" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>意味アクションとユーザー定義表明 &mdash; Boost.Xpressive（日本語訳）  ドキュメント</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="_static/translations.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Boost.Xpressive（日本語訳）
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目次</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="preface.html">前口上 </a></li>
<li class="toctree-l1"><a class="reference internal" href="user_s_guide.html">ユーザーガイド</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference/index.html">リファレンス</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgements.html">謝辞</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendices.html">付録</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Boost.Xpressive（日本語訳）</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>意味アクションとユーザー定義表明</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/actions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>意味アクションとユーザー定義表明<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<div class="section" id="id2">
<h2>概要<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>入力文字列を解析し、そこから <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> を構築したいとする。このような場合、正規表現では不十分である。正規表現マッチの部分で<strong>何か</strong>をしたい。xpressive は、静的正規表現の部分に意味アクションを結びつける方法を提供する。本節ではその方法を説明する。</p>
</div>
<div class="section" id="semantic-actions">
<h2>意味アクション（Semantic Actions）<a class="headerlink" href="#semantic-actions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>以下のコードを考える。xpressive の意味アクションを使って単語と整数の組からなる文字列を解析し、<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> に詰め込んでいる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/xpressive.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;boost/xpressive/regex_actions.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">xpressive</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

    <span class="c1">// =&gt; で区切られた単語と整数にマッチし、</span>
    <span class="c1">// 結果を std::map&lt;&gt; に詰め込む</span>
    <span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
        <span class="p">[</span> <span class="n">ref</span><span class="p">(</span><span class="n">result</span><span class="p">)[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

    <span class="c1">// 空白で区切られた 1 つ以上の単語・整数の組にマッチする。</span>
    <span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">pair</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">(</span><span class="o">+</span><span class="n">_s</span> <span class="o">&gt;&gt;</span> <span class="n">pair</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">regex_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
<p>正規表現 <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">pair</span></code> は、パターンとアクションの 2 つの部分からなる。単語のマッチを 1 番目の部分マッチで捕捉し、<code class="regex-input docutils literal notranslate"><span class="pre">=&gt;</span></code> で区切られた整数のマッチを 2 番目の部分マッチで捕捉するというのがパターンが表現するところである。アクションは角括弧 <code class="code docutils literal notranslate"><span class="pre">[</span> <span class="pre">ref(result)[s1]</span> <span class="pre">=</span> <span class="pre">as&lt;int&gt;(s2)</span> <span class="pre">]</span></code> の内側である。これは 1 番目の部分マッチを <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">results</span></code> 辞書の添字に使用し、そこに2番目の部分マッチを整数に変換した結果を代入するという意味である。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>静的正規表現で意味アクションを使用するには、<code class="file docutils literal notranslate"><span class="pre">&lt;boost/xpressive/regex_actions.hpp&gt;</span></code> をインクルードしなければならない。</p>
</div>
<p>このコードはどのように動作するのだろう？ 静的正規表現の残りの部分だけ見ると括弧の間は式テンプレートになっている。これでアクションがコード化され、後で実行される。式 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span></code> は <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> への遅延参照を作成する。より大きな式である <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span><span class="pre">[</span><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><span class="pre">s1</span></a><span class="pre">]</span></code> は辞書に対する添字操作の遅延である。後でこのアクションを実行すると <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code> は 1 番目の <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> で置換される。同様に <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/as.html#_CPPv4I00EN5boost9xpressive2asE11unspecifiedRK1A" title="boost::xpressive::as"><span class="pre">as</span></a><span class="pre">&lt;</span><span class="pre">int</span><span class="pre">&gt;</span><span class="pre">(</span><a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><span class="pre">s2</span></a><span class="pre">)</span></code> を実行すると <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code> は 2 番目の <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> で置換される。<a class="reference internal" href="reference/as.html#_CPPv4I00EN5boost9xpressive2asE11unspecifiedRK1A" title="boost::xpressive::as"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">as&lt;&gt;</span></code></a> アクションは引数を Boost.Lexical_cast を使って要求の型に変換する。アクション全体の効果としては、新しい単語・整数の組を辞書に挿入する、となる。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><code class="file docutils literal notranslate"><span class="pre">&lt;boost/ref.hpp&gt;</span></code> の関数 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::ref</span></code> と <code class="file docutils literal notranslate"><span class="pre">&lt;boost/xpressive/regex_actions.hpp&gt;</span></code> の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::xpressive::ref</span></code> には重大な違いがある。前者は通常の参照とほぼ同様の振る舞いをする素の <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference_wrapper&lt;&gt;</span></code> を返す。一方 <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">boost::xpressive::ref</span></code> が返すのは、遅延実行する式内で使用する遅延参照である。これが、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> が <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> を受け取る <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">operator[]</span></code> をもたないにも関わらず <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">result</span><span class="pre">)</span><span class="pre">[</span><a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><span class="pre">s1</span></a><span class="pre">]</span></code> とする理由である。</p>
</div>
<p>部分マッチのプレースホルダ <a class="reference internal" href="reference/s1.html#_CPPv4N5boost9xpressive2s1E" title="boost::xpressive::s1"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s1</span></code></a> 、<a class="reference internal" href="reference/s2.html#_CPPv4N5boost9xpressive2s2E" title="boost::xpressive::s2"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">s2</span></code></a> に加えて、アクションが結び付けられている部分式にマッチした文字列を後方参照するのにアクション内で使用するプレースホルダー <a class="reference internal" href="reference/_.html#_CPPv4N5boost9xpressive1_E" title="boost::xpressive::_"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_</span></code></a> がある。例えば以下の正規表現は数字列にマッチし、それらを整数として解釈して結果をローカル変数に代入する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// ここで _ は (+_d) にマッチしたすべての文字を後方参照する</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span> <span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>アクションの遅延実行<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>アクションを正規表現のある部分に結び付けてマッチを行うとは、実際にはどういう意味なのか？ アクションが実行されるのはいつなのか？ アクションが繰り返し部分式の一部である場合は、アクションが実行される回数は1度なのか複数回なのか？ また部分式が最初はマッチしていたが正規表現の残りの部分がマッチせず最終的に失敗した場合は、アクションはまったく実行されないのか？</p>
<p>答えは既定では、アクションは<strong>遅延</strong>実行される、である。部分式が文字列にマッチすると、そのアクションはアクションが参照する部分マッチの現在の値とともに待ち行列に置かれる。マッチアルゴリズムがバックトラックしなければならなくなると、アクションは必要に応じて待ち行列から取り出される。アクションが実際に実行されるのは、正規表現全体のマッチが成功した後だけである。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> が制御を返す直前の段階で、これらは待ち行列に追加した順番で一度にすべて実行される。</p>
<p>例として、以下の数字を見つけるたびにカウンタを増やす正規表現を考える。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 感嘆符の付いた数字は数えるが、疑問符付きのものは数えない。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</pre></div>
</div>
<p>アクション <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">i</span><span class="pre">)</span></code> は 3 回（数字が見つかるたびに 1 回ずつ）待ち行列に入る。しかし<strong>実行</strong>されるのは 2 回だけ（後ろに <code class="regex-input docutils literal notranslate"><span class="pre">!</span></code> 文字がある数字 1 字について 1 回ずつ）である。<code class="regex-input docutils literal notranslate"><span class="pre">?</span></code> 文字に遭遇するとマッチアルゴリズムはバックトラックを行い、待ち行列から最後のアクションを削除する。</p>
</div>
<div class="section" id="id4">
<h2>アクションの即時実行<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>意味アクションを即時実行したい場合は、そのアクションを含む部分式を <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> で包む。<a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> は当該部分式についてバックトラックを無効にし、その部分式の待ち行列に入っているあらゆるアクションを <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> の終了とともに実行する。これにより、あたかも <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> 内の部分式が別の正規表現オブジェクトにコンパイルされ、<a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> のマッチングが <a class="reference internal" href="reference/regex_search.html#_CPPv4I0EN5boost9xpressive12regex_searchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_search"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_search</span></code></a> を個別に呼び出して実行されたかのようになる。結果この部分式は文字にマッチしアクションを実行するが、バックトラックも巻き戻しもしない。例えば上の例を以下のように書き換えたとする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 数字をすべて数える。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">keep</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">);</span>
</pre></div>
</div>
<p>部分式 <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="reference/_d.html#_CPPv4N5boost9xpressive2_dE" title="boost::xpressive::_d"><span class="pre">_d</span></a><span class="pre">[</span><span class="pre">++</span><a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><span class="pre">ref</span></a><span class="pre">(</span><span class="pre">i</span><span class="pre">)</span><span class="pre">]</span></code> を <a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> で包んだ。こうすることでこの正規表現が数字にマッチするとアクションが待ち行列に入り、<code class="regex-input docutils literal notranslate"><span class="pre">!</span></code> 文字のマッチを試行する前に即時実行されるようになる。この場合、アクションは 3 回実行される。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p><a class="reference internal" href="reference/keep.html#_CPPv4I0EN5boost9xpressive4keepE11unspecifiedRK4Expr" title="boost::xpressive::keep"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">keep</span></code></a> と同様、<a class="reference internal" href="reference/before.html#_CPPv4I0EN5boost9xpressive6beforeE11unspecifiedRK4Expr" title="boost::xpressive::before"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">before</span></code></a> と <a class="reference internal" href="reference/after.html#_CPPv4I0EN5boost9xpressive5afterE11unspecifiedRK4Expr" title="boost::xpressive::after"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">after</span></code></a> 内のアクションも、その部分式がマッチしたときに早期実行される。</p>
</div>
</div>
<div class="section" id="id5">
<h2>遅延関数<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>ここまで変数と演算子からなる意味アクションの記述方法について見てきたが、意味アクションから関数を呼び出す方法についてはどうだろう？ xpressive にはそのための機構がある。</p>
<p>まず関数オブジェクト型を定義する。以下の例は引数に対して <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">push</span></code> を呼び出す関数オブジェクトである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">push_impl</span>
<span class="p">{</span>
    <span class="c1">// 戻り値の型（tr1::result_of のために必要）</span>
    <span class="k">typedef</span> <span class="kt">void</span> <span class="n">result_type</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Sequence</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Value</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Sequence</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">,</span> <span class="n">Value</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">seq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>次に xpressive の <a class="reference internal" href="reference/function.html#_CPPv4I0EN5boost9xpressive8functionE" title="boost::xpressive::function"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">function&lt;&gt;</span></code></a> テンプレートを使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> という名前の関数オブジェクトを定義する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// グローバルな &quot;push&quot; 関数オブジェクト。</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">push_impl</span><span class="o">&gt;::</span><span class="n">type</span> <span class="k">const</span> <span class="n">push</span> <span class="o">=</span> <span class="p">{{}};</span>
</pre></div>
</div>
<p>初期化はいささか奇妙に見えるが、<code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> を静的に初期化するためである。これは実行時に構築する必要はないということを意味する。以下のように <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">push</span></code> を意味アクション内で使用する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ints</span><span class="p">;</span>
<span class="c1">// 数字がマッチしたら int へキャストし、スタックに積む。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span><span class="n">push</span><span class="p">(</span><span class="n">ref</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">))];</span>
</pre></div>
</div>
<p>この方法だとメンバ関数の呼び出しがただの関数呼び出しに見えてしまうことに気付くと思う。意味アクションを、よりメンバ関数呼び出しらしく見えるように記述する方法がある。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="n">_d</span><span class="p">)[</span><span class="n">ref</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span><span class="o">-&gt;*</span><span class="n">push</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">))];</span>
</pre></div>
</div>
<p>xpressive は <code class="code docutils literal notranslate"><span class="pre">-&gt;*</span></code> を認識し、この式を上のコードとまったく同等に扱う。</p>
<p>関数オブジェクトが引数によって戻り値の型を変えなければならない場合は、<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">result_type</span></code> 型定義の代わりに <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">result&lt;&gt;</span></code> メンバテンプレートを使用するとよい。<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::pair&lt;&gt;</span></code> か <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> の <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">first</span></code> メンバを返す <a class="reference internal" href="reference/first.html#_CPPv4N5boost9xpressive5firstE" title="boost::xpressive::first"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">first</span></code></a> 関数オブジェクトの例である。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 組の第 1 要素を返す関数オブジェクト。</span>
<span class="k">struct</span> <span class="nc">first_impl</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Sig</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="nc">result</span> <span class="p">{};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">This</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Pair</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nc">result</span><span class="o">&lt;</span><span class="n">This</span><span class="p">(</span><span class="n">Pair</span><span class="p">)</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="nc">remove_reference</span><span class="o">&lt;</span><span class="n">Pair</span><span class="o">&gt;</span>
            <span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">first_type</span> <span class="n">type</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Pair</span><span class="o">&gt;</span>
    <span class="k">typename</span> <span class="nc">Pair</span><span class="o">::</span><span class="n">first_type</span>
    <span class="k">operator</span><span class="p">()(</span><span class="n">Pair</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// OK、first(s1) により s1 が参照する部分マッチの先頭を指すイテレータを得る。</span>
<span class="n">function</span><span class="o">&lt;</span><span class="n">first_impl</span><span class="o">&gt;::</span><span class="n">type</span> <span class="k">const</span> <span class="n">first</span> <span class="o">=</span> <span class="p">{{}};</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>ローカル変数を参照する<a class="headerlink" href="#id6" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>上の例で見たように、<a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xpressive::ref</span></code></a> を使用するとアクション内からローカル変数を参照できる。この変数は正規表現による参照に保持されるが、これらの参照が懸垂しないよう注意が必要である。例えば以下のコードでは、<code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">bad_voodoo</span></code> が制御を返すと <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">i</span></code> に対する参照が懸垂する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="nf">bad_voodoo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
    <span class="c1">// エラー！ rex はローカル変数を参照により参照しており、</span>
    <span class="c1">// bad_voodoo() が制御を返した後に懸垂する。</span>
    <span class="k">return</span> <span class="n">rex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>意味アクションを記述するときは、すべての参照が懸垂しないよう注意を払わなければならない。1 つの方法は変数を、正規表現が値により保持する共有ポインタにすることである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sregex</span> <span class="nf">good_voodoo</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// val() を使って shared_ptr を値で保持する:</span>
    <span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">val</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
    <span class="c1">// OK、rex は整数への参照カウントを保持する。</span>
    <span class="k">return</span> <span class="n">rex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上のコードでは、<a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xpressive::val</span></code></a> を使って共有ポインタを値で保持している。アクション内のローカル変数は既定では値で保持されるため、通常この処理は必要ないが、この場合は必要である。アクションを <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><span class="pre">pi</span></code> と記述してしまうと即時実行されてしまう。これは <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><span class="pre">pi</span></code> が式テンプレートでないためである（<code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">++</span><span class="pre">*</span><a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><span class="pre">val</span></a><span class="pre">(</span><span class="pre">pi</span><span class="pre">)</span></code> は式テンプレートである）。</p>
<p>アクション内の変数をすべて <a class="reference internal" href="reference/ref.html#_CPPv4I0EN5boost9xpressive3refEK9referenceI1TERK1T" title="boost::xpressive::ref"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ref</span></code></a> と <a class="reference internal" href="reference/val.html#_CPPv4I0EN5boost9xpressive3valEK5valueI1TERK1T" title="boost::xpressive::val"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">val</span></code></a> で包むのはうんざりするかもしれない。これを容易にするために xpressive は <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> および <a class="reference internal" href="reference/value.html#_CPPv4I0EN5boost9xpressive5valueE" title="boost::xpressive::value"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">value&lt;&gt;</span></code></a> テンプレートを提供している。対応を以下の表に示す。</p>
<table class="docutils align-default" id="id9">
<caption><span class="caption-text">reference&lt;&gt; と value&lt;&gt;</span><a class="headerlink" href="#id9" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>これは…</p></th>
<th class="head"><p>…以下と等価である</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ref</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">reference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ri</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ri</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">val</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">value</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vpi</span><span class="p">(</span><span class="n">pi</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++*</span><span class="n">vpi</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>上で見たように <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> を使用する場合、始めにローカル変数を宣言してから <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> する。<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> を使用するとこの 2 段階を 1 つにまとめられる。</p>
<table class="docutils align-default" id="id10">
<caption><span class="caption-text">local&lt;&gt; 対 reference&lt;&gt;</span><a class="headerlink" href="#id10" title="このテーブルへのパーマリンク">¶</a></caption>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>これは…</p></th>
<th class="head"><p>…以下と等価である</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">local</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">i</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">reference</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ri</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">ri</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>上の例を <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> を使用して書き直すと以下のようになる。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">local</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;1!2!3?&quot;</span><span class="p">);</span>
<span class="c1">// 感嘆符の付いた数字は数えるが、疑問符付きのものは数えない。</span>
<span class="n">sregex</span> <span class="n">rex</span> <span class="o">=</span> <span class="o">+</span><span class="p">(</span> <span class="n">_d</span> <span class="p">[</span> <span class="o">++</span><span class="n">i</span> <span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="sc">&#39;!&#39;</span> <span class="p">);</span>
<span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">rex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/local.html#_CPPv4N5boost9xpressive5local3getEv" title="boost::xpressive::local::get"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">local::get</span></code></a> を使ってローカル変数の値にアクセスしていることに注意していただきたい。また <a class="reference internal" href="reference/reference.html#_CPPv4I0EN5boost9xpressive9referenceE" title="boost::xpressive::reference"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">reference&lt;&gt;</span></code></a> 同様、<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">local&lt;&gt;</span></code> が懸垂参照を作成する可能性があることに注意が必要である。</p>
</div>
<div class="section" id="semantic-actions-and-user-defined-assertions-referring-to-non-local-variables">
<span id="id7"></span><h2>非ローカル変数を参照する<a class="headerlink" href="#semantic-actions-and-user-defined-assertions-referring-to-non-local-variables" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>この節の最初で、正規表現を使って単語・整数の組からなる文字列を解析して <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> に詰め込む例を見た。この例では辞書と正規表現を定義しておき、いずれかがスコープから出る前にそれらを使う必要があった。正規表現を先に定義しておき、異なる複数の辞書に書き込みたい場合はどうすればよいだろうか？ 正規表現オブジェクトに辞書に対する参照を直接組み込むのではなく、<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> アルゴリズムに辞書を渡すようにしてはどうか。プレースホルダを定義し、意味アクション内で辞書そのものの代わりに使用する。後でいずれかの正規表現アルゴリズムを呼び出すときに実際の辞書オブジェクトへ参照を束縛できる。以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 辞書オブジェクトのプレースホルダを定義する:</span>
<span class="n">placeholder</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_map</span><span class="p">;</span>

<span class="c1">// =&gt; で区切られた単語と整数にマッチし、</span>
<span class="c1">// 結果を std::map&lt;&gt; に詰め込む</span>
<span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">[</span> <span class="n">_map</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

<span class="c1">// 空白で区切られた 1 つ以上の単語・整数の組にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">pair</span> <span class="o">&gt;&gt;</span> <span class="o">*</span><span class="p">(</span><span class="o">+</span><span class="n">_s</span> <span class="o">&gt;&gt;</span> <span class="n">pair</span><span class="p">);</span>

<span class="c1">// 解析する文字列</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

<span class="c1">// 結果を書き込む実際の辞書:</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="c1">// _map プレースホルダを実際の辞書に束縛する</span>
<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">what</span><span class="p">.</span><span class="n">let</span><span class="p">(</span> <span class="n">_map</span> <span class="o">=</span> <span class="n">result</span> <span class="p">);</span>

<span class="c1">// マッチを実行し結果の辞書に書き込む</span>
<span class="k">if</span><span class="p">(</span><span class="n">regex_match</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">rx</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を表示する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/placeholder.html#_CPPv4I0_iEN5boost9xpressive11placeholderE" title="boost::xpressive::placeholder"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">placeholder&lt;&gt;</span></code></a> を使って <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_map</span></code> を定義しており、これが <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::map&lt;&gt;</span></code> 変数の代理となる。意味アクション内でこのプレースホルダを辞書として使用できる。次に <a class="reference internal" href="reference/match_results.html#_CPPv4I0EN5boost9xpressive13match_resultsE" title="boost::xpressive::match_results"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">match_results</span></code></a> 構造体を定義して <code class="code docutils literal notranslate"><span class="pre">what.let(</span> <span class="pre">_map</span> <span class="pre">=</span> <span class="pre">result</span> <span class="pre">);</span></code> で実際の辞書をプレースホルダに束縛する。<a class="reference internal" href="reference/regex_match.html#_CPPv4I0EN5boost9xpressive11regex_matchEb8BidiIter8BidiIterR13match_resultsI8BidiIterERK11basic_regexI8BidiIterEN15regex_constants15match_flag_typeE" title="boost::xpressive::regex_match"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">regex_match</span></code></a> 呼び出しは、意味アクション内のプレースホルダを <code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">result</span></code> への参照で置換したかのように振舞う。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>意味アクション内のプレースホルダは<strong>実際には</strong>実行時に変数への参照で置換されない。正規表現オブジェクトはいずれの正規表現アルゴリズムでも変更されることはないので、複数のスレッドで使用しても安全である。</p>
</div>
<p><a class="reference internal" href="reference/regex_iterator.html#_CPPv4I0EN5boost9xpressive14regex_iteratorE" title="boost::xpressive::regex_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_iterator&lt;&gt;</span></code></a> か <a class="reference internal" href="reference/regex_token_iterator.html#_CPPv4I0EN5boost9xpressive20regex_token_iteratorE" title="boost::xpressive::regex_token_iterator"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">regex_token_iterator&lt;&gt;</span></code></a> を使用する場合は、遅延束縛されたアクションの引数は少し異なる。正規表現イテレータのコンストラクタは、引数の束縛を指定する引数を受け付ける。変数をそのプレースホルダに束縛するのに使用する <a class="reference internal" href="reference/let.html#_CPPv4IDpEN5boost9xpressive3letE11unspecifiedDpRK11ArgBindings" title="boost::xpressive::let"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">let</span></code></a> 関数がある。以下のコードに方法を示す。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 辞書オブジェクトのプレースホルダを定義する:</span>
<span class="n">placeholder</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">_map</span><span class="p">;</span>

<span class="c1">// =&gt; で区切られた単語と整数にマッチ</span>
<span class="n">sregex</span> <span class="n">pair</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">s1</span><span class="o">=</span> <span class="o">+</span><span class="n">_w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="s">&quot;=&gt;&quot;</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">s2</span><span class="o">=</span> <span class="o">+</span><span class="n">_d</span><span class="p">)</span> <span class="p">)</span>
    <span class="p">[</span> <span class="n">_map</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="p">];</span>

<span class="c1">// 解析する文字列</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;aaa=&gt;1 bbb=&gt;23 ccc=&gt;456&quot;</span><span class="p">);</span>

<span class="c1">// 結果を書き込む実際の辞書:</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>

<span class="c1">// regex_iterator を作成し、すべてのマッチを検索する</span>
<span class="n">sregex_iterator</span> <span class="nf">it</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pair</span><span class="p">,</span> <span class="n">let</span><span class="p">(</span><span class="n">_map</span><span class="o">=</span><span class="n">result</span><span class="p">));</span>
<span class="n">sregex_iterator</span> <span class="n">end</span><span class="p">;</span>

<span class="c1">// すべてのマッチについて結果の辞書に書き込む</span>
<span class="k">while</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span>
    <span class="o">++</span><span class="n">it</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;aaa&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;bbb&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">[</span><span class="s">&quot;ccc&quot;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>このプログラムは以下を出力する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">1</span>
<span class="go">23</span>
<span class="go">456</span>
</pre></div>
</div>
</div>
<div class="section" id="semantic-actions-and-user-defined-assertions-user-defined-assertions">
<span id="id8"></span><h2>ユーザー定義表明<a class="headerlink" href="#semantic-actions-and-user-defined-assertions-user-defined-assertions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>正規表現の<strong>表明</strong>については慣れたものだろう。Perl だと表明の例として <code class="regexp docutils literal notranslate"><span class="pre">^</span></code> や <code class="regexp docutils literal notranslate"><span class="pre">$</span></code> があり、それぞれ文字列の先頭・終端にマッチする。xpressive では新たに表明を定義できる。カスタム表明は、マッチの成否を判断する時点で真でなければならない条件である。カスタム表明をチェックするには xpressive の <a class="reference internal" href="reference/check.html#_CPPv4I0EN5boost9xpressive5checkE11unspecifiedRK1T" title="boost::xpressive::check"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">check</span></code></a> 関数を使用する。</p>
<p>カスタム表明を定義する方法はいくつかある。一番簡単なのは関数オブジェクトを使うことである。長さが 3 文字か 6 文字のいずれかである部分文字列にマッチする部分式が必要であるとする。そのような述語を以下の構造体で定義する。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 部分マッチが長さ 3 文字か 6 文字であれば真となる述語。</span>
<span class="k">struct</span> <span class="nc">three_or_six</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="n">sub_match</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">sub</span><span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">sub</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">||</span> <span class="n">sub</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">6</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>この述語を正規表現で使うには以下のようにする。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 3 文字か 6 文字の単語にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">)[</span> <span class="n">check</span><span class="p">(</span><span class="n">three_or_six</span><span class="p">())</span> <span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>上の正規表現は長さが 3 文字か 6 文字の単語全体にマッチする。述語 <code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">three_or_six</span></code> は、カスタム表明が結び付けられた部分式にマッチした部分を後方参照する <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match&lt;&gt;</span></code></a> を受け取る。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>カスタム表明はマッチの成否に関与する。遅延実行されるアクションとは異なり、カスタム表明は正規表現エンジンがマッチを検索するときに即時実行される。</p>
</div>
<p>カスタム表明は意味アクションと同じ構文を用いてインライン定義することもできる。以下は同じカスタム表明をインラインで書き直したものである。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 3 文字か 6 文字の単語にマッチする。</span>
<span class="n">sregex</span> <span class="n">rx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bow</span> <span class="o">&gt;&gt;</span> <span class="o">+</span><span class="n">_w</span> <span class="o">&gt;&gt;</span> <span class="n">eow</span><span class="p">)[</span> <span class="n">check</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="o">||</span> <span class="n">length</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="o">==</span><span class="mi">6</span><span class="p">)</span> <span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>上記において、<a class="reference internal" href="reference/length.html#_CPPv4N5boost9xpressive6lengthE" title="boost::xpressive::length"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">length()</span></code></a> は引数の <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">length</span></code> メンバ関数を呼び出す遅延関数であり、<a class="reference internal" href="reference/_.html#_CPPv4N5boost9xpressive1_E" title="boost::xpressive::_"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">_</span></code></a> は <a class="reference internal" href="reference/sub_match.html#_CPPv4I0EN5boost9xpressive9sub_matchE" title="boost::xpressive::sub_match"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">sub_match</span></code></a> を受け取るプレースホルダである。</p>
<p>カスタム表明のインライン記述は、コツが分かってしまえば非常に強力である。（あまり厳密でない意味での）正しい日付にのみマッチする正規表現を書いてみよう。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="k">const</span> <span class="n">days_per_month</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>

<span class="n">mark_tag</span> <span class="nf">month</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">day</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">// 「月/日/年」形式の正しい日付を検索する。</span>
<span class="n">sregex</span> <span class="n">date</span> <span class="o">=</span>
    <span class="p">(</span>
        <span class="c1">// 月は 1 以上 12 以下でなければならない</span>
        <span class="p">(</span><span class="n">month</span><span class="o">=</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="o">!</span><span class="n">_d</span><span class="p">)</span>     <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">]</span>
    <span class="o">&gt;&gt;</span>  <span class="sc">&#39;/&#39;</span>
        <span class="c1">// 日は 1 以上 31 以下でなければならない</span>
    <span class="o">&gt;&gt;</span>  <span class="p">(</span><span class="n">day</span><span class="o">=</span>   <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="o">!</span><span class="n">_d</span><span class="p">)</span>     <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">31</span><span class="p">)</span> <span class="p">]</span>
    <span class="o">&gt;&gt;</span>  <span class="sc">&#39;/&#39;</span>
        <span class="c1">// 年は 1970 以上 2038 以下とする</span>
    <span class="o">&gt;&gt;</span>  <span class="p">(</span><span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span> <span class="o">&gt;&gt;</span> <span class="n">_d</span><span class="p">)</span> <span class="p">[</span> <span class="n">check</span><span class="p">(</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1970</span>
                                    <span class="o">&amp;&amp;</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2038</span><span class="p">)</span> <span class="p">]</span>
    <span class="p">)</span>
    <span class="c1">// 月ごとの実際の日数を確認する！</span>
    <span class="p">[</span> <span class="n">check</span><span class="p">(</span> <span class="n">ref</span><span class="p">(</span><span class="n">days_per_month</span><span class="p">)[</span><span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">month</span><span class="p">)</span><span class="mi">-1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">day</span><span class="p">)</span> <span class="p">)</span> <span class="p">]</span>
<span class="p">;</span>

<span class="n">smatch</span> <span class="n">what</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;99/99/9999 2/30/2006 2/28/2006&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="p">(</span><span class="n">regex_search</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">date</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">what</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このプログラムは以下を印字する。</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">2/28/2006</span>
</pre></div>
</div>
<p>インラインのカスタム表明を使って年・月・日の値の範囲チェックを行っていることに注意していただきたい。<code class="regex-input docutils literal notranslate"><span class="pre">99/99/9999</span></code> や <code class="regex-input docutils literal notranslate"><span class="pre">2/30/2006</span></code> は正しい日付ではないため、この正規表現はマッチしない（99 の月は存在しないし、2 月には 30 日はない）。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 著作権 2020, exeal

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
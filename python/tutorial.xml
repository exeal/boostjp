<?xml version="1.0" ?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="tutorial">
  <info>
    <title>チュートリアル</title>
    <authorgroup>
      <author>
	<personname>
	  <firstname>Joel</firstname>
	  <surname>de Guzman</surname>
	</personname>
      </author>
      <author>
	<personname>
	  <firstname>David</firstname>
	  <surname>Abrahams</surname>
	</personname>
      </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <holder>Joel de Guzman</holder>
      <holder>David Abrahams</holder>
    </copyright>
    <legalnotice>
      <remark>
	Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        <link xlink:href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</link>
      </remark>
    </legalnotice>
  </info>

  <section xml:id="tutorial.quickstart">
    <title>クイックスタート</title>
    <para>
      Boost.Python ライブラリは Python と C++ 間のインターフェイスのためのフレームワークである。C++ のクラス、関数、オブジェクトをすばやくシームレスに Python へエクスポートでき、また逆に Python から C++ へエクスポートできる。特別なツールは必要なく、あなたのコンパイラだけで可能だ。このライブラリは C++ インターフェイスを非侵入的にラップするよう設計されており、C++ コードを変更する必要は一切ない。このため、サードパーティ製ライブラリを Python へエクスポートするには Boost.Python が最適である。ライブラリは高度なメタプログラミング技術を使ってその構文を単純化しており、コードのラッピングは宣言的なインターフェイス定義言語（IDL）のような見た目になっている。
    </para>

    <section xml:id="tutorial.quickstart.hello_world">
      <title>Hello World</title>
      <para>
	C/C++ の伝統に従い「hello, world」から始めるとしよう。
      </para>
      <programlisting language="C++">char const* greet()
{
   return "hello, world";
}</programlisting>
      <para>
	この C++ 関数は、次の Boost.Python ラッパを書くことで Python へエクスポートできる。
      </para>
      <programlisting language="C++">#include &lt;boost/python.hpp&gt;

BOOST_PYTHON_MODULE(hello_ext)
{
    using namespace boost::python;
    def("greet", greet);
}</programlisting>
      <para>
	これですべてである。あとはこれを共有ライブラリとしてビルドすると、生成した DLL が Python から可視となる。以下は Python のセッション例である。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>import hello_ext</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>print hello_ext.greet()</userinput>
<computeroutput>hello, world</computeroutput></screen>
    </section>
  </section>

  <!--
      次回、「Hello Worldモジュールのビルド」。
  -->

  <section xml:id="tutorial.hello">
    <title>Hello World のビルド</title>

    <section xml:id="tutorial.hello.from_start_to_finish">
      <title>始めから終わりまで</title>
      <para>
	まず最初は Hello World モジュールをビルドして Python で使ってみることだろう。本節でそのためのステップを明らかにする。あらゆる Boost ディストリビューションに付属するビルドツールである <command>bjam</command> を使用する。
      </para>
      <note>
	<title><command>bjam</command> を使用せずにビルドする</title>
	<para>
	  当然 <command>bjam</command> 以外にモジュールをビルドする方法はある。ここに書いていることが「唯一の方法」というわけではない。<command>bjam</command> の他にビルドツールは存在する。
	</para>
	<para>
	  しかしながら Boost.Python のビルドには <command>bjam</command> が適していると記しておく。セットアップを失敗させる方法はたくさんある。経験から言えば「Boost.Python がビルドできない」という問題の 9 割は、他のツールを使用することを余儀なくされた人から寄せられた。
	</para>
      </note>
      <para>
	細かいことは省略する。ここでの目的は Hello World モジュールを簡単に作成して Python で走らせることである。Boost.Python のビルドについて完全なリファレンスは「<link linkend="building">ビルドとテスト</link>」を見るとよい。この短いチュートリアルが終わったら DLL のビルドが完了して Python のプログラムで拡張が走っているはずである。
      </para>
      <para>
	チュートリアルの例はディレクトリ <filename class="directory">/libs/python/example/tutorial</filename> にある。以下のファイルがある。
      </para>
      <itemizedlist>
	<listitem>
	  <para><filename>hello.cpp</filename></para>
	</listitem>
	<listitem>
	  <para><filename>hello.py</filename></para>
	</listitem>
	<listitem>
	  <para><filename>Jamroot</filename></para>
	</listitem>
      </itemizedlist>
      <para>
	<filename>hello.cpp</filename> ファイルは C++ の Hello World 例、<filename>Jamroot</filename> は DLL をビルドする最小限の bjam スクリプトである。そして <filename>hello.py</filename> は <filename>hello.cpp</filename> の拡張を使用する Python プログラムである。
      </para>
      <para>
	何よりもまず bjam の実行可能ファイルを boost ディレクトリか、<command>bjam</command> をコマンドラインから実行できるパスに置いておく。ほとんどのプラットフォームでビルド済み Boost.Jam 実行可能ファイルが利用できる。bjam 実行可能ファイルの完全なリストが<link xlink:href="http://sourceforge.net/project/showfiles.php?group_id=7586">ここ</link>にある。
      </para>
    </section>

    <section xml:id="tutorial.hello.let_s_jam">
      <title>Jam ろう！</title>
      <para>
	最小限の Jamroot ファイルを <filename>/libs/python/example/tutorial/Jamroot</filename> に置いておく。そのままファイルをコピーして <code>use-project boost</code> の部分を Boost のルートディレクトリに設定すればよい。
      </para>
      <para>
	必要なことはこの Jamrules ファイルのコメントに書いてある。
      </para>
    </section>

    <section xml:id="tutorial.hello.running_bjam">
      <title>bjam を起動する</title>
      <para>
	オペレーティングシステムのコマンドラインインタープリタから <command>bjam</command> を起動する。
      </para>
      <para>
	では、始めるとしよう。
      </para>
      <para>
	<filename>user-config.jam</filename> という名前のファイルをホームディレクトリに置いてツールを調整する。Windows の場合、コマンドプロンプトウィンドウで次のようにタイプするとホームディレクトリがわかる。
      </para>
      <screen><userinput>ECHO %HOMEDRIVE%%HOMEPATH%</userinput></screen>
      <para>
	ファイルには少なくともコンパイラと Python のインストールについてのルールを書いておく必要がある。Windows の場合は例えば以下のとおり：
      </para>
      <programlisting language="bjam">#  Microsoft Visual C++ の設定
using msvc : 8.0 ;

#  Python の設定
using python : 2.4 : C:/dev/tools/Python ;</programlisting>
      <para>
	1 番目のルールで MSVC 8.0 とその関連ツールを使用することを bjam に設定している。2 番目のルールは Python についての設定であり、Python のバージョンと場所を指定している。上の例では <filename class="directory">C:/dev/tools/Python</filename> に Python をインストールした想定である。Python を正しく「標準的に」インストールした場合はこの設定は不要である。
      </para>
      <para>
	ここまで来れば準備は整った。チュートリアルの <filename>hello.cpp</filename> と <filename>Jamroot</filename> が置いてある <filename class="directory">libs/python/example/tutorial</filename> に <command>cd</command> で移動するのを忘れないように。
      </para>
      <screen><userinput>bjam</userinput></screen>
      <para>
	これでビルドが始まり、
      </para>
      <screen><userinput>cd C:\dev\boost\libs\python\example\tutorial</userinput>
<userinput>bjam</userinput>
<computeroutput>...patience...
...found 1101 targets...
...updating 35 targets...</computeroutput></screen>
      <para>
	最終的に例えば以下のように表示される。
      </para>
      <screen><computeroutput>Creating <replaceable>library path-to-boost_python.dll</replaceable>
   Creating library /path-to-hello_ext.exp/
**passed** ... hello.test
...updated 35 targets...</computeroutput></screen>
      <para>
	すべて問題なければ、DLL がビルドされ Python のプログラムが走るはずである。
      </para>
      <para>
	さあ、楽しんでいただきたい！
      </para>
    </section>
  </section>

  <section xml:id="tutorial.exposing">
    <title>クラスのエクスポート</title>
    <para>
      では C++ クラスを Python へエクスポートしよう。
    </para>
    <para>
      エクスポートすべき C++ クラス・構造体を考えよう。
    </para>
    <programlisting language="C++">struct World
{
    void set(std::string msg) { this-&gt;msg = msg; }
    std::string greet() { return msg; }
    std::string msg;
};</programlisting>
    <para>
      相当する Boost.Python ラッパを書いて Python へエクスポートできる。
    </para>
    <programlisting language="C++">#include &lt;boost/python.hpp&gt;
using namespace boost::python;

BOOST_PYTHON_MODULE(hello)
{
    class_&lt;World&gt;("World")
        .def("greet", &amp;World::greet)
        .def("set", &amp;World::set)
    ;
}</programlisting>
    <para>
      上記のようにメンバ関数 <function>greet</function> および <function>set</function> をエクスポートする C++ クラスラッパを書いた。このモジュールを共有ライブラリとしてビルドすると、Python 側から <classname>World</classname> クラスが使用できるようになる。次に示すのは Python のセッション例である。
    </para>
    <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>import hello</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>planet = hello.World()</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>planet.set('howdy')</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>planet.greet()</userinput>
<computeroutput>'howdy'</computeroutput></screen>

    <section xml:id="tutorial.exposing.constructors">
      <title>コンストラクタ</title>
      <para>
	前回の例では明示的なコンストラクタが登場しなかった。<classname>World</classname> はプレーンな構造体として宣言したので、暗黙のデフォルトコンストラクタとなっていた。Boost.Python は既定ではデフォルトコンストラクタをエクスポートするので、以下のように書けた。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>planet = hello.World()</userinput></screen>
      <para>
	デフォルトでないコンストラクタを使ってクラスをラップしたい場合もあるだろう。前回の例をビルドする。
      </para>
      <programlisting language="C++">struct World
{
    World(std::string msg): msg(msg) {} // コンストラクタを追加した
    void set(std::string msg) { this-&gt;msg = msg; }
    std::string greet() { return msg; }
    std::string msg;
};</programlisting>
      <para>
	これで <classname>World</classname> にデフォルトコンストラクタはなくなった。前回のラップコードは、ライブラリをエクスポートするところでコンパイルに失敗するだろう。代わりにエクスポートしたいコンストラクタについて <classname>class_&lt;World&gt;</classname> に通知しなければならない。
      </para>
      <programlisting language="C++">#include &lt;boost/python.hpp&gt;
using namespace boost::python;

BOOST_PYTHON_MODULE(hello)
{
    class_&lt;World&gt;("World", init&lt;std::string&gt;())
        .def("greet", &amp;World::greet)
        .def("set", &amp;World::set)
    ;
}</programlisting>
      <para>
	<function>init&lt;std::string&gt;()</function> が、<type>std::string</type> を引数にとるコンストラクタをエクスポートする（Python ではコンストラクタを「<code language="Python">"__init__"</code>」と書く）。
      </para>
      <para>
	<methodname>def()</methodname> メンバ関数に <classname>init&lt;...&gt;</classname> を渡すことでエクスポートするコンストラクタを追加できる。例えば <classname>World</classname> に <type>double</type> を 2 つとる別のコンストラクタがあるとすれば、
      </para>
      <programlisting language="C++">class_&lt;World&gt;("World", init&lt;std::string&gt;())
    .def(init&lt;double, double&gt;())
    .def("greet", &amp;World::greet)
    .def("set", &amp;World::set)
;</programlisting>
      <para>
	逆にコンストラクタを 1 つもエクスポートしたくない場合は、代わりに <constant>no_init</constant> を使う。
      </para>
      <programlisting language="C++">class_&lt;Abstract&gt;("Abstract", no_init)</programlisting>
      <para>
	これは実際には、常に Python の <exceptionname>RuntimeError</exceptionname> 例外を投げる <methodname>__init__</methodname> メソッドを追加する。
      </para>
    </section>

    <section xml:id="tutorial.exposing.class_data_members">
      <title>クラスデータメンバ</title>
      <para>
	データメンバもまた Python へエクスポートでき、対応する Python クラスの属性としてアクセス可能になる。各データメンバは<emphasis>読み取り専用</emphasis>か<emphasis>読み書き可能</emphasis>として見なすことができる。以下の <classname>Var</classname> クラスを考えよう。
      </para>
      <programlisting language="C++">struct Var
{
    Var(std::string name) : name(name), value() {}
    std::string const name;
    float value;
};</programlisting>
      <para>
	C++ クラス <classname>Var</classname> とそのデータメンバは次のようにして Python へエクスポートできる。
      </para>
      <programlisting language="C++">class_&lt;Var&gt;("Var", init&lt;std::string&gt;())
    .def_readonly("name", &amp;Var::name)
    .def_readwrite("value", &amp;Var::value);</programlisting>
      <para>
	これで Python 側で <package>hello</package> 名前空間内に <classname>Var</classname> クラスがあるように扱うことができる。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>x = hello.Var('pi')</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>x.value = 3.14</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>print x.name, 'is around', x.value</userinput>
<computeroutput>pi is around 3.14</computeroutput></screen>
      <para>
	<varname>name</varname> を<emphasis>読み取り専用</emphasis>としてエクスポートしたいっぽうで、<varname>value</varname> は<emphasis>読み書き可能</emphasis>としてエクスポートしたことに注意していただきたい。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>x.name = 'e' # nameは変更できない</userinput>
<computeroutput>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
AttributeError: can't set attribute</computeroutput></screen>
    </section>

    <section xml:id="tutorial.exposing.class_properties">
      <title>クラスプロパティ</title>
      <para>
	C++ では、公開データメンバを持つクラスは受け入れられない。カプセル化を利用して適切に設計されたクラスは、クラスのデータメンバを隠蔽しているものである。クラスのデータにアクセスする唯一の方法はアクセス関数（getter および setter）を介したものである。アクセス関数はクラスのプロパティをエクスポートする。以下がその例である。
      </para>
      <programlisting language="C++">struct Num
{
    Num();
    float get() const;
    void set(float value);
    ...
};</programlisting>
      <para>
	しかしながら Python における属性アクセスは優れたものである。ユーザが属性を直接処理しても、必ずしもカプセル化が破壊されるわけではない。属性はメソッド呼び出しの別の構文だからである。<classname>Num</classname> クラスを Boost.Python を使ってラップすると次のようになる。
      </para>
      <programlisting language="C++">class_&lt;Num&gt;("Num")
    .add_property("rovalue", &amp;Num::get)
    .add_property("value", &amp;Num::get, &amp;Num::set);</programlisting>
      <para>
	これで Python 側は以下のようになる。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>x = Num()</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>x.value = 3.14</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>x.value, x.rovalue</userinput>
<computeroutput>(3.14, 3.14)</computeroutput>
<prompt>&gt;&gt;&gt; </prompt><userinput>x.rovalue = 2.17 # エラー！</userinput></screen>
      <para>
	以下のように <property>rovalue</property> の setter メンバ関数を渡していないため、クラスのプロパティ <property>rovalue</property> は読み取り専用としてエクスポートされることに注意していただきたい。
      </para>
      <programlisting language="C++">.add_property("rovalue", &amp;Num::get)</programlisting>
    </section>

    <section xml:id="tutorial.exposing.inheritance">
      <title>継承</title>
      <para>
	これまでの例では多態的でないクラスを扱ってきたが、通常、そうしたことはあまりない。多くの場合、多態的なクラスや継承が絡んだクラス階層をラップすることになるだろう。仮想基底クラスから派生したクラスについて Boost.Python ラッパを書かなければならなくなるだろう。
      </para>
      <para>
次のような簡単な継承構造を考えよう。
      </para>
      <programlisting language="C++">struct Base { virtual ~Base(); };
struct Derived : Base {};</programlisting>
      <para>
	<classname>Base</classname> と <classname>Derived</classname> インスタンスを処理する C++ 関数群もあるとする。
      </para>
      <programlisting language="C++">void b(Base*);
void d(Derived*);
Base* factory() { return new Derived; }</programlisting>
      <para>
	基底クラス <classname>Base</classname> をラップする方法は以前見た。
      </para>
      <programlisting language="C++">class_&lt;Base&gt;("Base")
    /*...*/
    ;</programlisting>
      <para>
	<classname>Derived</classname> とその基底クラスである <classname>Base</classname> の関係について Boost.Python に伝える。
      </para>
      <programlisting language="C++">class_&lt;Derived, bases&lt;Base&gt; &gt;("Derived")
    /*...*/
    ;</programlisting>
      <para>
	これで自動的に以下の効果が得られる：
      </para>
      <orderedlist>
	<listitem>
	  <para><classname>Derived</classname> は <classname>Base</classname> のすべてのメソッド（ラップされた C++ メンバ関数）を自動的に継承する。</para>
	</listitem>
	<listitem>
	  <para><classname>Base</classname> が多態的である場合、<classname>Base</classname> へのポインタか参照で Python へ渡した <classname>Derived</classname> オブジェクトは、<classname>Derived</classname> へのポインタか参照が期待されているところに渡すことができる。</para>
	</listitem>
      </orderedlist>
      <para>
	次に C++ 自由関数 <function>b</function> 、<function>d</function> および <function>factory</function> をエクスポートする。
      </para>
      <programlisting language="C++">def("b", b);
def("d", d);
def("factory", factory);</programlisting>
      <para>
	自由関数 <function>factory</function> が、<classname>Derived</classname> クラスの新しいインスタンスを生成するために使われることに注意していただきたい。このような場合は <classname>return_value_policy&lt;manage_new_object&gt;</classname> を使って、<classname>Base</classname> へのポインタを受け入れ、Python のオブジェクトが破壊されるまでインスタンスを新しい Python の <classname>Base</classname> オブジェクトに保持しておくことを Python に伝える。Boost.Python の<link linkend="tutorial.functions.call_policy">呼び出しポリシー</link>については後で詳しく述べる。
      </para>
      <programlisting language="C++">// factory の結果について所有権を取るよう Python に伝える
def("factory", factory,
    return_value_policy&lt;manage_new_object&gt;());</programlisting>
    </section>

    <section xml:id="tutorial.exposing.class_virtual_functions">
      <title>仮想関数</title>
      <para>
	本節では仮想関数を使って関数に多態的な振る舞いをさせる方法について学ぶ。前の例に引き続き、<classname>Base</classname> クラスに仮想関数を 1 つ追加しよう。
      </para>
      <programlisting language="C++">struct Base
{
    virtual ~Base() {}
    virtual int f() = 0;
};</programlisting>
      <para>
	Boost.Python の目標の 1 つが、既存の C++ の設計に対して侵入を最小限にすることである。原則的にはサードパーティ製ライブラリに対して、インターフェイス部分を変更することなくエクスポート可能であるべきである。<classname>Base</classname> クラスに何かを追加するのは望ましいことではない。しかし Python 側でオーバーライドし C++ <emphasis>から</emphasis>多態的に呼び出す関数の場合、正しく動作させるのに足場が必要になる。Python のオーバーライドが呼び出されるように仮想関数に非侵入的にフックする、<classname>Base</classname> から派生したラッパクラスを書くことである。
      </para>
      <programlisting language="C++"></programlisting>
      <para>
	<classname>Base</classname> の継承に加え、<classname>wrapper&lt;Base&gt;</classname> を多重継承していることに注意していただきたい（<link linkend="header.wrapper_hpp">ラッパ</link>の節を見よ）。<classname>wrapper</classname> テンプレートはラップするクラスをPython側でオーバーライドできるようにする段取りを容易にする。
      </para>

      <caution>
	<title>msvc6/7 におけるバグの回避方法</title>
	<para>
	  Microsoft Visual C++ のバージョン 6 か 7 を使っている場合、<methodname>f</methodname> は次のように書かなければならない。
	</para>
	<programlisting language="C++">return call&lt;int&gt;(this-&gt;get_override("f").ptr());</programlisting>
      </caution>
      
      <para>
	<classname>BaseWrap</classname> のオーバーライドされた仮想メンバ関数 <methodname>f</methodname> は、実際には <methodname>get_override</methodname> を介して Python オブジェクトの相当するメソッドを呼び出す。
      </para>
      <para>
	最後に <classname>Base</classname> をエクスポートする。
      </para>
      <programlisting language="C++">class_&lt;BaseWrap, boost::noncopyable&gt;("Base")
    .def("f", pure_virtual(&amp;Base::f))
    ;</programlisting>
      <para>
	<function>pure_virtual</function> は、関数 <methodname>f</methodname> が純粋仮想関数であることを Boost.Python に伝える。
      </para>
      <note>
	<title>メンバ関数とメソッド</title>
	<para>
	  Python をはじめ、多くのオブジェクト指向言語では<emphasis>メソッド（<foreignphrase xml:lang="en">methods</foreignphrase>）</emphasis>という用語を使う。メソッドは大雑把に言えば C++ の<emphasis>メンバ関数（<foreignphrase xml:lang="en">member functions</foreignphrase>）</emphasis>に相当する。
	</para>
      </note>
    </section>

    <section xml:id="tutorial.exposing.virtual_functions_with_default_implementations">
      <title>既定の実装をもった仮想関数</title>
      <para>
	前節で Boost.Python の<link linkend="header.wrapper_hpp">クラスラッパ</link>機能を用いて純粋仮想関数を持ったクラスをラップする方法を見てきた。<emphasis>非</emphasis>純粋仮想関数をラップする場合、方法は少し異なる。
      </para>
      <para>
	<link linkend="tutorial.exposing.class_virtual_functions">前節</link>を思い出そう。C++ で実装するか Python で派生クラスを作成する、純粋仮想関数を持ったクラスをラップした。基底クラスは次のように純粋仮想関数 <methodname>f</methodname> を持っていた。
      </para>
      <programlisting language="C++">struct Base
{
    virtual int f() = 0;
};</programlisting>
      <para>
	しかしながら、仮にメンバ関数 <methodname>f</methodname> が純粋仮想関数として宣言されていなかったら、
      </para>
      <programlisting language="C++">struct Base
{
    virtual ~Base() {}
    virtual int f() { return 0; }
};</programlisting>
      <para>
	以下のようにラップする。
      </para>
      <programlisting language="C++">struct BaseWrap : Base, wrapper&lt;Base&gt;
{
    int f()
    {
        if (override f = this-&gt;get_override("f"))
            return f(); // ＊注意＊
        return Base::f();
    }

    int default_f() { return this-&gt;Base::f(); }
};</programlisting>
      <para>
	<methodname>BaseWrap::f</methodname> の実装方法に注意していただきたい。この場合、<methodname>f</methodname> のオーバーライドが存在するかチェックしなければならない。存在しなければ <methodname>Base::f()</methodname> を呼び出すとよい。
      </para>

      <caution>
	<title>MSVC6/7 におけるバグの回避方法</title>
	<para>
	  Microsoft Visual C++ のバージョン 6 か 7 を使っている場合、＊注意＊と書いた行を次のように変更しなければならない。
	</para>
	<programlisting language="C++">return call&lt;char const*&gt;(f.ptr());</programlisting>
      </caution>

      <para>
	最後にエスクポートを行う。
      </para>
      <programlisting language="C++">class_&lt;BaseWrap, boost::noncopyable&gt;("Base")
    .def("f", &amp;Base::f, &amp;BaseWrap::default_f)
    ;</programlisting>
      <para>
	<methodname>&amp;Base::f</methodname> と <methodname>&amp;BaseWrap::default_f</methodname> の両方をスクスポートしていることに注意していただきたい。Boost.Python は（1）転送（<foreignphrase xml:lang="en">dispatch</foreignphrase>）関数fと（2）既定の実装への転送（<foreignphrase xml:lang="en">forwarding</foreignphrase>）関数 <methodname>default_f</methodname> の追跡を維持しなければならない。この目的のための特別な <methodname>def</methodname> 関数が用意されている。
      </para>
      <para>
	Python 側では結果的に次のようになる。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>base = Base()</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>class Derived(Base):
...     def f(self):
...         return 42
...</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>derived = Derived()</userinput></screen>
      <para>
	<methodname>base.f()</methodname> を呼び出すと次のようになる。
      </para>
      <programlisting language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>base.f()</userinput>
<computeroutput>0</computeroutput></programlisting>
      <para>
	<methodname>derived.f()</methodname> を呼び出すと次のようになる。
      </para>
      <programlisting language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>derived.f()</userinput>
<computeroutput>42</computeroutput></programlisting>
    </section>

    <section xml:id="tutorial.exposing.class_operators_special_functions">
      <title>演算子・特殊関数</title>

      <section xml:id="tutorial.exposing.class_operators_special_functions.python_operators">
	<title>Python の演算子</title>
	<para>
	  C は演算子が豊富なことでよく知られている。C++ はこれを演算子の多重定義を認めることにより極限まで拡張した。Boost.Python はこれを利用して、演算子を多用した C++ クラスのラップを容易にする。
	</para>
	<para>
	  ファイルの位置を表すクラス <classname>FilePos</classname> と、<classname>FilePos</classname> インスタンスをとる演算子群を考える。
	</para>
	<programlisting language="C++">class FilePos { /*...*/ };

FilePos     operator+(FilePos, int);
FilePos     operator+(int, FilePos);
int         operator-(FilePos, FilePos);
FilePos     operator-(FilePos, int);
FilePos&amp;    operator+=(FilePos&amp;, int);
FilePos&amp;    operator-=(FilePos&amp;, int);
bool        operator&lt;(FilePos, FilePos);</programlisting>
	<para>
	  これらのクラスと演算子群は幾分簡単かつ直感的に Python へエクスポートできる。
	</para>
	<programlisting language="C++">class_&lt;FilePos&gt;("FilePos")
    .def(self + int())          // __add__
    .def(int() + self)          // __radd__
    .def(self - self)           // __sub__
    .def(self - int())          // __sub__
    .def(self += int())         // __iadd__
    .def(self -= other&lt;int&gt;())
    .def(self &lt; self);          // __lt__</programlisting>
	<para>
	  上記のコード片は非常に明確であり、ほとんど説明不要である。演算子のシグニチャと実質同じである。<constant>self</constant> が <classname>FilePos</classname> オブジェクトを表すということにのみ注意していただきたい。また、演算子式に現れるクラス <type>T</type> がすべて（容易に）デフォルトコンストラクト可能であるとは限らない。「self 式」を書くときに実際の <type>T</type> インスタンスの代わりに <code language="C++">other&lt;T&gt;()</code> が使える。
	</para>
      </section>

      <section xml:id="tutorial.exposing.class_operators_special_functions.special_methods">
	<title>特殊メソッド</title>
	<para>
	  Python には他にいくつか<emphasis>特殊メソッド</emphasis>がある。Boost.Python は、実際の Python クラスインスタンスがサポートする標準的な特殊メソッド名をすべてサポートする。直感的なインターフェイス群で、これらの Python <emphasis>特殊関数</emphasis>に相当する C++ 関数をラップできる。以下に例を示す。
	</para>
	<programlisting language="C++">class Rational
{ public: operator double() const; };

Rational pow(Rational, Rational);
Rational abs(Rational);
ostream&amp; operator&lt;&lt;(ostream&amp;,Rational);

class_&lt;Rational&gt;("Rational")
    .def(float_(self))                  // __float__
    .def(pow(self, other&lt;Rational&gt;))    // __pow__
    .def(abs(self))                     // __abs__
    .def(str(self))                     // __str__
    ;</programlisting>
	<para>
	  他に言うことは？
	</para>
	<note>
	  <para>
	    <methodname>operator&lt;&lt;</methodname> の役割は？ メソッド <methodname>str</methodname> が動作するために <methodname>operator&lt;&lt;</methodname> が必要なのだ（<methodname>operator&lt;&lt;</methodname>は <code language="C++">def(str(self))</code> が定義するメソッドが使用する）。
	  </para>
	</note>
      </section>
    </section>
  </section>

  <section xml:id="tutorial.functions">
    <title>関数</title>
    <para>
      本章では、Boost.Python の強力な関数について詳細を見る。懸垂ポインタや懸垂参照のような潜在的な落とし穴を避けつつ、C++ 関数を Python へエクスポートするための機能について見ていく。また、多重定義や既定の引数といった C++ 機能を利用した C++ 関数のエクスポートを容易にする機能についても見ていく。
    </para>
    <para>
      先を続けよう。
    </para>
    <para>
      しかしその前に Python 2.2 以降を立ち上げて <code language="Python">&gt;&gt;&gt; import this</code> とタイプしたくなるかもしれない。
    </para>
    <screen language="Python"><computeroutput>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!</computeroutput></screen>

    <section xml:id="tutorial.functions.call_policies">
      <title>呼び出しポリシー</title>
      <para>
	C++ では引数や戻り値の型としてポインタや参照を扱うことがよくある。これら単純型は非常に低水準であり表現力に乏しい。少なくとも、ポインタや参照先のオブジェクトの所有権がどこにあるか知る方法はない。もっとも、Java や Python といった言語ではそのような低水準な実体を扱うことはない。C++ では、所有権のセマンティクスを正確に記述するスマートポインタの使用をよい慣習であると考えることが多い。それでも生の参照やポインタを使う C++ インターフェイスがよいとされる場合もあり、Boost.Python がそれらに対処できなければならない。このためには、あなたの助けが必要である。次のような C++ 関数を考える。
      </para>
      <programlisting language="C++">X&amp; f(Y&amp; y, Z* z);</programlisting>
      <para>
	ライブラリはこの関数をどのようにラップすべきだろうか？ 単純なアプローチとしては、返される参照について Python の <type>X</type> オブジェクトを構築することである。この解法は動作する場合もあるが、動作しないこともある。以下が後者の例である。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>x = f(y, z) # x は C++ の X を参照する</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>del y</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>x.some_method() # クラッシュ！</userinput></screen>
      <para>
	何が起きたのか？
      </para>
      <para>
	実は <function>f()</function> が次のように実装されていたのだった。
      </para>
      <programlisting language="C++">X&amp; f(Y&amp; y, Z* z)
{
    y.z = z;
    return y.x;
}</programlisting>
      <para>
	問題は、<function>f()</function> がオブジェクト <parameter>y</parameter> のメンバへの参照を返すため、結果の <type>X&amp;</type> の寿命が <parameter>y</parameter> の寿命に縛られることである。このイディオムは珍しいものではなく、C++ の文脈では完全に受け入れられるものである。しかしながら Python のユーザとしてはこの C++ インターフェイスを使用するだけでシステムをクラッシュさせるわけにはいかない。今回の場合、<parameter>y</parameter> を削除した段階で <type>X</type> への参照が無効となり、懸垂参照が残るのである。
      </para>
      <para>
	以下のようなことが起こっている。
      </para>
      <orderedlist>
	<listitem>
	  <para><parameter>y</parameter> への参照と <parameter>z</parameter> へのポインタを渡して <function>f</function> が呼び出される</para>
	</listitem>
	<listitem>
	  <para><code language="C++">y.x</code> への参照が返される</para>
	</listitem>
	<listitem>
	  <para><parameter>y</parameter> が削除される。<varname>x</varname> は懸垂参照となる</para>
	</listitem>
	<listitem>
	  <para><code language="C++">x.some_method()</code> が呼び出される</para>
	</listitem>
	<listitem>
	  <para><emphasis>バン！</emphasis></para>
	</listitem>
      </orderedlist>
      <para>
	結果を新しいオブジェクトにコピーしてみる。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>f(y, z).set(42) # 結果を消失</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>y.x.get()       # クラッシュしないが、改善の余地がある</userinput>
<computeroutput>3.14</computeroutput></screen>
      <para>
	これは今回の C++ インターフェイスで本当に実現したかったことではない。Python インターフェイスが可能な限り綿密に C++ インターフェイスを反映すべきであるという約束を破っている。
      </para>
      <para>
	問題はこれで終わりではない。<classname>Y</classname> の実装が次のようになっているとしたら、
      </para>
      <programlisting language="C++">struct Y
{
    X x; Z* z;
    int z_value() { return z-&gt;value(); }
};</programlisting>
      <para>
	データメンバ <varname>z</varname> がクラス <classname>Y</classname> に生のポインタで保持されていることに注意していただきたい。潜在的な懸垂ポインタの問題が <classname>Y</classname> の内部で発生している。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>x = f(y, z) # y は z を参照する</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>del z       # オブジェクトzを削除</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>y.z_value() # クラッシュ！</userinput></screen>
      <para>
	参考のために <function>f</function> の実装を再掲する。
      </para>
      <programlisting language="C++">X&amp; f(Y&amp; y, Z* z)
{
    y.z = z;
    return y.x;
}</programlisting>
      <para>
	以下のようなことが起こっている。
      </para>
      <orderedlist>
	<listitem>
	  <para><parameter>y</parameter> への参照と <parameter>z</parameter> へのポインタを渡して <function>f</function> が呼び出される</para>
	</listitem>
	<listitem>
	  <para><parameter>y</parameter> が <parameter>z</parameter> へのポインタを保持する</para>
	</listitem>
	<listitem>
	  <para><code language="C++">y.x</code> への参照が返される</para>
	</listitem>
	<listitem>
	  <para><parameter>z</parameter> が削除される。<code language="C++">y.z</code> は懸垂ポインタとなる</para>
	</listitem>
	<listitem>
	  <para><code language="C++">y.z_value()</code> が呼び出される</para>
	</listitem>
	<listitem>
	  <para><code language="C++">z-&gt;value()</code> が呼び出される</para>
	</listitem>
	<listitem>
	  <para><emphasis>バン！</emphasis></para>
	</listitem>
      </orderedlist>

      <section xml:id="tutorial.functions.call_policies.call_policies">
	<title>呼び出しポリシー</title>
	<para>
	  上で扱った例のような状況では、呼び出しポリシーが使える。今回の例では <classname>return_internal_reference</classname> と <classname>with_custodian_and_ward</classname> が助けになる。
	</para>
	<programlisting language="C++">def("f", f,
    return_internal_reference&lt;1,
        with_custodian_and_ward&lt;1, 2&gt; &gt;());</programlisting>
	<para>
	  引数の <literal>1</literal> とか <literal>2</literal> って何だい？
	</para>
	<programlisting language="C++">return_internal_reference&lt;1</programlisting>
	<para>
	  これは 1 番目の引数（<code language="C++">Y&amp; y</code>）が返される参照（<type>X&amp;</type>）の所有者であると Boost.Python に伝えている。「1」は単に 1 番目の引数という意味である。まとめると「第 1 引数 <code language="C++">Y&amp; y</code> が所有する内部参照 <type>X&amp;</type> を返す」となる。
	</para>
	<programlisting language="C++">with_custodian_and_ward&lt;1, 2&gt;</programlisting>
	<para>
	  これは <foreignphrase xml:lang="en">ward</foreignphrase>（被後見人）で指定した引数（第 2 引数。<code language="C++">Z* z</code>）の寿命が <foreignphrase xml:lang="en">custodian</foreignphrase>（後見人）で指定した引数（第 1 引数。<code language="C++">Y&amp; y</code>）の寿命に依存すると Boost.Python に伝えている。
	</para>
	<para>
	  上で 2 つのポリシーを定義していることに注意していただきたい。2 つ以上のポリシーは数珠繋ぎに結合できる。汎用的な構文は以下のようになる。
	</para>
	<programlisting language="C++">policy1&lt;args...,
    policy2&lt;args...,
        policy3&lt;args...&gt; &gt; &gt;</programlisting>
	<para>
	  定義済みの呼び出しポリシーを以下のリストに挙げる。完全なリファレンスは<link linkend="reference.models_of_call_policies">ここ</link>にある。
	</para>
	<variablelist>
	  <varlistentry>
	    <term>
	      <classname>with_custodian_and_ward</classname>
	    </term>
	    <listitem>
	      <para>引数の寿命を他の引数で縛る</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>
	      <classname>with_custodian_and_ward_postcall</classname>
	    </term>
	    <listitem>
	      <para>引数の寿命を他の引数や返り値で縛る</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>
	      <classname>return_internal_reference</classname>
	    </term>
	    <listitem>
	      <para>1 つの引数の寿命を返り値の寿命で縛る</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>
	      <classname>return_value_policy&lt;T&gt;</classname>（<type>T</type> は以下のいずれか）
	    </term>
	    <listitem>
	      <variablelist>
		<varlistentry>
		  <term>
		    <classname>reference_existing_object</classname>
		  </term>
		  <listitem>
		    <para>単純（で危険）なアプローチ</para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>
		    <classname>copy_const_reference</classname>
		  </term>
		  <listitem>
		    <para>Boost.Python v1のアプローチ</para>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>
		    <classname>copy_non_const_reference</classname>
		  </term>
		  <listitem>
		    <para/>
		  </listitem>
		</varlistentry>
		<varlistentry>
		  <term>
		    <classname>manage_new_object</classname>
		  </term>
		  <listitem>
		    <para>ポインタを受け取りインスタンスを保持する</para>
		  </listitem>
		</varlistentry>
	      </variablelist>
	    </listitem>
	  </varlistentry>
	</variablelist>
	<para>
	  禅（Zen）を思い出そう、Luke
	  <footnote>
	    <para>
	      訳注　この日本語訳は <link xlink:href="http://www.python.jp/Zope/Zope/articles/misc/zen">http://www.python.jp/Zope/Zope/articles/misc/zen</link> によりました（Copyright © 2001-2012 Python Japan User's Group）。
	    </para>
	  </footnote>
	  ：
	</para>
	<para>
	  「ごちゃごちゃ難しいのより、白黒はっきりしてるのがいい」
	</para>
	<para>
	  「あいまいなことをてきとーに処理しちゃいけません」
	</para>
      </section>
    </section>

    <section xml:id="tutorial.functions.overloading">
      <title>多重定義</title>
      <para>
	多重定義したメンバ関数を手動でラップする方法を以下に示す。非メンバ関数の多重定義をラップする場合も、当然同様のテクニックが使える。
      </para>
      <para>
	次のような C++ クラスを考える。
      </para>
      <programlisting language="C++">struct X
{
    bool f(int a)
    {
        return true;
    }

    bool f(int a, double b)
    {
        return true;
    }

    bool f(int a, double b, char c)
    {
        return true;
    }

    int f(int a, int b, int c)
    {
        return a + b + c;
    };
};</programlisting>
      <para>
	クラス <classname>X</classname> に多重定義された関数が 4 つある。まずメンバ関数ポインタ変数を導入するところから始める。
      </para>
      <programlisting language="C++">bool    (X::*fx1)(int)              = &amp;X::f;
bool    (X::*fx2)(int, double)      = &amp;X::f;
bool    (X::*fx3)(int, double, char)= &amp;X::f;
int     (X::*fx4)(int, int, int)    = &amp;X::f;</programlisting>
      <para>
	これがあれば、続けて Python のために定義とラップができる。
      </para>
      <programlisting language="C++">.def("f", fx1)
.def("f", fx2)
.def("f", fx3)
.def("f", fx4)</programlisting>
    </section>

    <section xml:id="tutorial.functions.default_arguments">
      <title>既定の引数</title>
      <para>
	Boost.Python は（メンバ）関数ポインタをラップするが、残念ながら C++ 関数ポインタは既定の引数について情報を持たない。既定の引数を持った関数fを考える。
      </para>
      <programlisting language="C++">int f(int, double = 3.14, char const* = "hello");</programlisting>
      <para>
	しかし関数 <function>f</function> へのポインタ型は、その既定の引数について情報を持たない。
      </para>
      <programlisting language="C++">int(*g)(int,double,char const*) = f;    // 既定の引数が失われる！</programlisting>
      <para>
	この関数ポインタを <function>def</function> 関数へ渡すとしても、既定の引数を取得する方法はない。
      </para>
      <programlisting language="C++">def("f", f);                            // 既定の引数が失われる！</programlisting>
      <para>
	このため C++ ラップコードを書くときは、<link linkend="tutorial.functions.overloading">前節</link>で示したような手動のラップか薄いラッパを書くことに頼るしかない。
      </para>
      <programlisting language="C++">// 「薄いラッパ」を書く
int f1(int x) { return f(x); }
int f2(int x, double y) { return f(x,y); }

/*...*/

    // init モジュール内
    def("f", f);  // 3 引数バージョン
    def("f", f2); // 2 引数バージョン	
    def("f", f1); // 1 引数バージョン</programlisting>
      <para>
	以下のいずれかの関数（メンバ関数）をラップするときは、次節に進むとよい。
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    既定の引数を持つ
	  </para>
	</listitem>
	<listitem>
	  <para>
	    引数の先頭部分に共通列を持つ形で多重定義されている
	  </para>
	</listitem>
      </itemizedlist>

      <section xml:id="tutorial.functions.default_arguments.boost_python_function_overloads">
	<title>BOOST_PYTHON_FUNCTION_OVERLOADS</title>
	<para>
	  Boost.Python はこれを容易にする方法を提供する。例えば次の関数が与えられたとする。
	</para>
	<programlisting language="C++">int foo(int a, char b = 1, unsigned c = 2, double d = 3)
{
    /*...*/
}</programlisting>
	<para>
	  次のマクロ呼び出しにより、薄いラッパが作成される。
	</para>
	<programlisting language="C++">BOOST_PYTHON_FUNCTION_OVERLOADS(foo_overloads, foo, 1, 4)</programlisting>
	<para>
	  このマクロは、<code language="C++">def(...)</code> に渡すことができる <classname>foo_overloads</classname> クラスを作成する。このマクロの 3 番目と 4 番目の引数は、それぞれ引数の最小数と最大数である。<function>foo</function> 関数では引数の最小数は 1 、最大数は 4 である。<code language="C++">def(...)</code> 関数は <function>foo</function> のファミリをすべて自動的に追加する。
	</para>
	<programlisting language="C++">def("foo", foo, foo_overloads());</programlisting>
      </section>

      <section xml:id="tutorial.functions.default_arguments.boost_python_member_function_overloads">
	<title>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</title>
	<para>
	  オブジェクトはここにも、そこにも、あそこにも、どこにでもある。Python にエクスポートするのは、クラスのメンバ関数が最も頻度が高い。ここでまた、以前の既定の引数や引数の先頭部分が共通列である多重定義の場合の不便が出てくる。これを容易にするマクロが提供されている。
	</para>
	<para>
	  <symbol>BOOST_PYTHON_FUNCTION_OVERLOADS</symbol> と同様、メンバ関数をラップする薄いラッパを自動的に作成するのに <symbol>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</symbol> を使用する。例を挙げる。
	</para>
	<programlisting language="C++">struct george
{
    void
    wack_em(int a, int b = 0, char c = 'x')
    {
        /*...*/
    }
};</programlisting>
	<para>
	  ここで次のようにマクロを呼び出すと、
	</para>
	<programlisting language="C++">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(george_overloads, wack_em, 1, 3)</programlisting>
	<para>
	  <classname>george</classname> の <methodname>wack_em</methodname> メンバ関数について最少で 1 、最多で 3（マクロの 3 番目と 4 番目の引数）の薄いラッパ群を生成する。薄いラッパはすべて <classname>george_overloads</classname> という名前のクラスに収められ、<code language="C++">def(...)</code> に引数として渡すことができる。
	</para>
	<programlisting language="C++">.def("wack_em", &amp;george::wack_em, george_overloads());</programlisting>
	<para>
	  詳細は<link linkend="header.overloads_hpp">多重定義のリファレンス</link>を見よ。
	</para>
      </section>

      <section xml:id="tutorial.functions.default_arguments.init_and_optional">
	<title>init と optional</title>
	<para>
	  クラスのコンストラクタ、特に既定の引数と多重定義については類似の機能が提供されている。<classname>init&lt;...&gt;</classname> を覚えているだろうか？ 例えばクラス <classname>X</classname> とそのコンストラクタがあるとすると、
	</para>
	<programlisting language="C++">struct X
{
    X(int a, char b = 'D', std::string c = "constructor", double d = 0.0);
    /*...*/
}</programlisting>
	<para>
	  このコンストラクタを一発で Boost.Python に追加するには、
	</para>
	<programlisting language="C++">.def(init&lt;int, optional&lt;char, std::string, double&gt; &gt;())</programlisting>
	<para>
	  <classname>init&lt;...&gt;</classname> と <classname>optional&lt;...&gt;</classname> の使用が既定（省略可能な引数）を表すことに注意していただきたい。
	</para>
      </section>
    </section>

    <section xml:id="tutorial.functions.auto_overloading">
      <title>自動多重定義</title>
      <para>
	前節で <symbol>BOOST_PYTHON_FUNCTION_OVERLOADS</symbol> および <symbol>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</symbol> が、引数列の先頭部分が共通である多重定義関数およびメンバ関数に対しても使用できることを見た。以下に例を示す。
      </para>
      <programlisting language="C++">void foo()
{
   /*...*/
}

void foo(bool a)
{
   /*...*/
}

void foo(bool a, int b)
{
   /*...*/
}

void foo(bool a, int b, char c)
{
   /*...*/
}</programlisting>
      <para>
	前節と同様、これらの多重定義された関数について薄いラッパを一発で生成できる。
      </para>
      <programlisting language="C++">BOOST_PYTHON_FUNCTION_OVERLOADS(foo_overloads, foo, 0, 3)</programlisting>
      <para>
	その結果、次のように書ける。
      </para>
      <programlisting language="C++">.def("foo", (void(*)(bool, int, char))0, foo_overloads());</programlisting>
      <para>
	この例では引数の個数は最少で 0 、最多で 3 となっていることに注意していただきたい。
      </para>

      <section xml:id="tutorial.functions.auto_overloading.manual_wrapping">
	<title>手動のラッピング</title>
	<para>
	  <emphasis>多重定義した関数は引数列の先頭に共通部分を持っていなければならない</emphasis>ということを強調しておく。それ以外の場合、上で述べた方法は動作せず、関数を<link linkend="tutorial.functions.overloading">手動で</link>ラップしなければならない。
	</para>
	<para>
	  実際には多重定義関数の手動ラッピングと、<symbol>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</symbol> とその姉妹版である <symbol>BOOST_PYTHON_FUNCTION_OVERLOADS</symbol> による自動的なラッピングを混用することは可能である。<link linkend="tutorial.functions.overloading">多重定義</link>の節で見た例だと 4 つの多重定義関数は引数の先頭列が共通であるので、<symbol>BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS</symbol> を使って最初の 3 つの <function>def</function> を自動的にラップでき、残り 1 つだけを手動でラップすることになる。方法は以下のとおり。
	</para>
	<programlisting language="C++">BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(xf_overloads, f, 1, 4)</programlisting>
	<para>
	  両方の <methodname>X::f</methodname> 多重定義について、メンバ関数ポインタを作成すると、
	</para>
	<programlisting language="C++">bool    (X::*fx1)(int, double, char)    = &amp;X::f;
int     (X::*fx2)(int, int, int)        = &amp;X::f;</programlisting>
	<para>
	  結果、以下のように書ける。
	</para>
	<programlisting language="C++">.def("f", fx1, xf_overloads());
.def("f", fx2)</programlisting>
      </section>
    </section>
  </section>

  <section xml:id="tutorial.object">
    <title>オブジェクトのインターフェイス</title>
    <para>
      C++ が静的型付けであるのに対し、Python は動的型付けである。Python の変数は整数、浮動小数点数、リスト、辞書、タプル、文字列、長整数、その他を保持できる。Boost.Python と C++ の視点では、これら Python 的な変数は <classname>object</classname> クラスのインスタンスにすぎない。本章で Python のオブジェクトをどのように扱うか見ていく。
    </para>
    <para>
      以前述べたように Boost.Python の目的の 1 つは、C++ と Python 間における Python 的な感覚の双方向マッピングの提供である。Boost.Python における C++ の <classname>object</classname> は可能な限り Python に類似したものとなっている。これにより学習曲線は著しく最小化されるはずである。
    </para>

    <section xml:id="tutorial.object.basic_interface">
      <title>基本的なインターフェイス</title>
      <para>
	<classname>object</classname> クラスは <type>PyObject*</type> をラップする。参照カウントの管理といった <type>PyObject</type> の複雑な取り扱いは、すべて <classname>object</classname> クラスが処理する。C++ オブジェクトの相互運用性はシームレスなものである。実際のところ、Boost.Python における C++ の <classname>object</classname> はあらゆる C++ オブジェクトから明示的に構築できる。
      </para>
      <para>
	説明のために、以下のような Python コード片を考える。
      </para>
      <programlisting language="Python">def f(x, y):
     if (y == 'foo'):
         x[3:7] = 'bar'
     else:
         x.items += y(3, x)
     return x

def getfunc():
   return f;</programlisting>
      <para>
	Boost.Python の機能を用いて C++ で書き直すと次のようになる。
      </para>
      <programlisting language="C++">object f(object x, object y) {
     if (y == "foo")
         x.slice(3,7) = "bar";
     else
         x.attr("items") += y(3, x);
     return x;
}
object getfunc() {
    return object(f);
}</programlisting>
      <para>
	C++ でコードを書いているという外観的な差を除けば、そのルックアンドフィールは Python のプログラマにも明確である。
      </para>
    </section>

    <section xml:id="tutorial.object.derived_object_types">
      <title>object の派生型</title>
      <para>
	Boost.Python には、Python の各型に対応する <classname>object</classname> の派生型がある。
      </para>
      <itemizedlist>
	<listitem>
	  <para><classname>list</classname></para>
	</listitem>
	<listitem>
	  <para><classname>dict</classname></para>
	</listitem>
	<listitem>
	  <para><classname>tuple</classname></para>
	</listitem>
	<listitem>
	  <para><classname>str</classname></para>
	</listitem>
	<listitem>
	  <para><classname>long_</classname></para>
	</listitem>
	<listitem>
	  <para><classname>enum_</classname></para>
	</listitem>
      </itemizedlist>
      <para>
	これらの <classname>object</classname> の派生型は実際の Python 型と同様に振舞う。例を挙げる。
      </para>
      <screen language="Python"><userinput>str(1)</userinput> ==> <computeroutput>"1"</computeroutput></screen>
      <para>
	個々の派生 <classname>object</classname> は対応する Python 型のメソッドを持つ。例えば <classname>dict</classname> は <methodname>keys()</methodname> メソッドを持つ。
      </para>
      <programlisting language="Python">d.keys()</programlisting>
      <para>
	<emphasis>タプルリテラル</emphasis>を宣言するのに <function>make_tuple</function>が提供されている。例を挙げる。
      </para>
      <programlisting language="C++">make_tuple(123, 'D', "Hello, World", 0.0);</programlisting>
      <para>
	C++ において、Boost.Python の <classname>object</classname> を関数の引数に渡す場合は派生型の一致が要求される。例えば以下に示す関数 <function>f</function> をラップする場合、Python の <classname>str</classname> 型とその派生型のみを受け付ける。
      </para>
      <programlisting language="C++">void f(str name)
{
    object n2 = name.attr("upper")();   // NAME = name.upper()
    str NAME = name.upper();            // こちらのほうがよい
    object msg = "%s is bigger than %s" % make_tuple(NAME,name);
}</programlisting>
      <para>
	細かく見ると、
      </para>
      <programlisting language="C++">str NAME = name.upper();</programlisting>
      <para>
	このコードから分かるように、<classname>str</classname> 型のメソッドを C++ メンバ関数として提供している。次に、
      </para>
      <programlisting language="C++">object msg = "%s is bigger than %s" % make_tuple(NAME,name);</programlisting>
      <para>
	上記のコードのように Python の <code language="Python">"format" % x,y,z</code> を C++ で書ける。標準の C++ で同じことを簡単に行う方法がないため便利である。
      </para>

      <caution>
	<para>
	  Python 同様、Python の可変型の多くがコンストラクタでコピーを行うというよく知られた落とし穴があるので注意が必要である。
	</para>
	<para>
	  Python の場合：
	</para>
	<screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>d = dict(x.__dict__)     # x.__dict__ をコピーする</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>d['whatever'] = 3        # コピーを変更する</userinput></screen>
        <para>
	  C++ の場合：
	</para>
	<programlisting language="C++">dict d(x.attr("__dict__"));  // x.__dict__ をコピーする
d['whatever'] = 3;           // コピーを変更する</programlisting>
      </caution>

      <section xml:id="tutorial.object.derived_object_types.class_t_as_objects">
	<title>object としての class_&lt;T&gt;</title>
	<para>
	  Boost.Python における <classname>object</classname> の動的な性質に従えば、あらゆる <classname>class_&lt;T&gt;</classname> もまたこれら型の 1 つである！ 以下のコード片はクラス（型）オブジェクトをラップする。
	</para>
	<para>
	  これを使って、ラップされたインスタンスを作成できる。
	</para>
	<programlisting language="C++">object vec345 = (
    class_&lt;Vec2&gt;("Vec2", init&lt;double, double&gt;())
        .def_readonly("length", &amp;Point::length)
        .def_readonly("angle", &amp;Point::angle)
    )(3.0, 4.0);

assert(vec345.attr("length") == 5.0);</programlisting>
      </section>
    </section>

    <section xml:id="tutorial.object.extracting_c___objects">
      <title>C++ オブジェクトの抽出</title>
      <para>
	<classname>object</classname> インスタンスを使用せずに C++ の値が必要になることがある。これは <function>extract&lt;T&gt;</function> 関数で実現できる。以下を考える。
      </para>
      <programlisting language="C++">double x = o.attr("length"); // コンパイルエラー</programlisting>
      <para>
	Boost.Python の <classname>object</classname> は <type>double</type> へ暗黙に変換できないため、上記のコードはコンパイルエラーとなる。代わりに以下のように書けば希望どおりとなる。
      </para>
      <programlisting language="C++">double l = extract&lt;double&gt;(o.attr("length"));
Vec2&amp; v = extract&lt;Vec2&amp;&gt;(o);
assert(l == v.length());</programlisting>
      <para>
	1 行目は Boost.Python の <classname>object</classname> の <property>length</property> 属性を抽出しようとしている。2 行目は Boost.Python の <classname>object</classname> が保持している <type>Vec2</type> オブジェクトを抽出しようとしている。
      </para>
      <para>
	「～しようとしている」と書いたことに注意していただきたい。Boost.Python の <classname>object</classname> が実際には <type>Vec2</type> 型を保持していなかったらどうなるだろうか？ これは Python の <classname>object</classname> がもつ動的な性質を考えれば十分ありうることである。安全のため、希望する C++ 型を抽出できない場合は適当な例外が投げられる。例外を避けるには抽出できるかテストする必要がある。
      </para>
      <programlisting language="C++">extract&lt;Vec2&amp;&gt; x(o);
if (x.check()) {
    Vec2&amp; v = x(); ...</programlisting>
      <para>
	明敏な読者は <function>extract&lt;T&gt;</function> の機能が変更可能コピーの問題を解決することに気付いたかもしれない。
      </para>
      <programlisting language="C++">dict d = extract&lt;dict&gt;(x.attr("__dict__"));
d["whatever"] = 3;          // x.__dict__ を変更する！</programlisting>
    </section>

    <section xml:id="tutorial.object.enums">
      <title>列挙</title>
      <para>
	Boost.Python には、C++ の列挙を捕捉、ラップする気の利いた機能がある。Python に <code language="C++">enum</code> 型はないが、C++ の列挙を Python へ <type>int</type> としてエクスポートしたいことがよくある。Python の動的型付けから C++ の強い静的型付けへの適切な変換に気を付けていれば Boost.Python の列挙機能で容易に可能である（C++ では、整数から列挙へ暗黙に変換することはできない）。次のような C++ の列挙があったとして、
      </para>
      <programlisting language="C++">enum choice { red, blue };</programlisting>
      <para>
	次のようにして Python へエクスポートする。
      </para>
      <programlisting language="C++"></programlisting>
      <para>
	新しい列挙は現在の <methodname>scope()</methodname> に作成される。これは大抵の場合現在のモジュールである。上記のコード片は Python の <type>int</type> 型から派生した、第 1 引数に渡した C++ 型に対応する Python クラスを作成する。
      </para>
      <note>
	<title>スコープとは</title>
	<para>
	  スコープは、新しい拡張クラスやラップした関数が属性として定義される Python の名前空間を制御するグローバルな関連 Python オブジェクトを持つクラスである。詳細は<link linkend="header.scope_hpp">リファレンス</link>を見よ。
	</para>
      </note>
      <para>
	Python からはこれらの値に以下のようにしてアクセスできる。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>my_module.choice.red</userinput>
<computeroutput>my_module.choice.red</computeroutput></screen>
      <para>
	ここで <package>my_module</package> は列挙を宣言したモジュールである。新しいスコープをクラスに対して作成することもできる。
      </para>
      <programlisting language="C++">scope in_X = class_&lt;X&gt;("X")
                .def( ... )
                .def( ... )
            ;

// X::nested を X.nested としてエクスポートする
enum_&lt;X::nested&gt;("nested")
    .value("red", red)
    .value("blue", blue)
    ;</programlisting>
    </section>

    <section xml:id="tutorial.object.creating_python_object">
      <title>PyObject* から boost::python::object を作成する</title>
      <para>
	<type>PyObject*</type> である <varname>pyobj</varname> へのポインタを <classname>boost::python::object</classname> で管理したい場合、以下のようにする。
      </para>
      <programlisting language="C++">boost::python::object o(boost::python::handle&lt;&gt;(pyobj));</programlisting>
      <para>
	この場合、オブジェクト <varname>o</varname> は <varname>pyobj</varname> を管理するが、構築時に参照カウントを増やさない。
      </para>
      <para>
	あるいは借用（<foreignphrase xml:lang="en">borrowed</foreignphrase>）参照を使う方法として、
      </para>
      <programlisting language="C++">boost::python::object o(boost::python::handle&lt;&gt;(boost::python::borrowed(pyobj)));</programlisting>
      <para>
	この場合 <symbol>Py_INCREF</symbol> が呼び出されるので、オブジェクト <varname>o</varname> がスコープ外に出ても <varname>pyobj</varname> は破壊されない。
      </para>
    </section>
  </section>

  <section xml:id="tutorial.embedding">
    <title>組み込み</title>
    <para>
      Boost.Python を使って Python から C++ のコードを呼び出す方法について理解できたと思う。しかしときには逆のこと、つまり C++ 側から Python のコードを呼び出す必要が出てくるはずである。これには Python のインタープリタを C++ のプログラムに<emphasis>組み込む</emphasis>必要がある。
    </para>
    <para>
      現時点では Boost.Python は組み込みに必要なことをすべてサポートしているわけではない。したがってこのギャップを埋めるには <link xlink:href="http://www.python.org/doc/current/api/api.html">Python の C API</link> を使う必要が出てくる。とはいえ Boost.Python は組み込みの大部分を容易にしており、将来のバージョンでは Python の C API に触れる必要はなくなるかもしれない。そういうわけだから期待しておいて欲しい。
    </para>

    <section>
      <title/>
      <section xml:id="tutorial.embedding.building_embedded_programs">
	<title>組み込みプログラムをビルドする</title>
	<para>
	  Python をプログラムに組み込み可能にするには、Python だけでなく Boost.Python 本体の実行時ライブラリにもリンクしなければならない。
	</para>
	<para>
	  Boost.Python のライブラリは 2 種類ある。いずれも Boost の <filename class="directory">/libs/python/build/bin-stage</filename> サブディレクトリにある。Windows ではライブラリの名前は <filename class="libraryfile">boost_python.lib</filename>（リリースビルド用）と <filename class="libraryfile">boost_python_debug.lib</filename>（デバッグ用）である。ライブラリが見つからない場合は、おそらくまだ Boost.Python をビルドしていないのだろう。<link linkend="building">ビルドとテスト</link>を見て方法を確認するとよい。
	</para>
	<para>
	  Python のライブラリは、Python ディレクトリの <filename class="directory">/libs</filename> サブディレクトリにある。Windows では pythonXY.lib のような名前で、X.Y が Python のメジャーバージョンの番号である。
	</para>
	<para>
	  また Python の <filename class="directory">/include</filename> サブディレクトリをインクルードパスに追加しておかなければならない。
	</para>
	<para>
	  Jamfile に以上のことをすべて要約すると、
	</para>
	<programlisting language="bjam">projectroot c:\projects\embedded_program ; # プログラムの場所

# Python 用の規則
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;

exe embedded_program # 実行可能ファイルの名前
  : # ソースファイル
     embedded_program.cpp
  : # 必須条件
     &lt;find-library&gt;boost_python &lt;library-path&gt;c:\boost\libs\python
  $(PYTHON_PROPERTIES)
    &lt;library-path&gt;$(PYTHON_LIB_PATH)
    &lt;find-library&gt;$(PYTHON_EMBEDDED_LIBRARY) ;</programlisting>
      </section>

      <section xml:id="tutorial.embedding.getting_started">
	<title>はじめに</title>
	<para>
	  ビルドできるようになったのはよいが、まだビルドするものがない。Python のインタープリタを C++ のプログラムに組み込むには、以下の 3 段階が必要である。
	</para>
	<orderedlist>
	  <listitem>
	    <para><filename class="headerfile">&lt;boost/python.hpp&gt;</filename> をインクルードする。</para>
	  </listitem>
	  <listitem>
	    <para><function><link xlink:href="http://docs.python.jp/2/c-api/init.html#Py_Initialize">Py_Initialize</link>()</function> を呼び出してインタープリタを起動、<package>__main__</package> モジュールを作成する。</para>
	  </listitem>
	  <listitem>
	    <para>他の Python C API を呼び出してインタープリタを使用する。</para>
	  </listitem>
	</orderedlist>
	<note>
	  <para>
	    <emphasis>現時点ではインタープリタを停止するのに <function><link xlink:href="http://docs.python.jp/2/c-api/init.html#Py_Finalize">Py_Finalize</link>()</function> を呼び出してはならない。これは Boost.Python の将来のバージョンで修正する。</emphasis>
	  </para>
	</note>
	<para>
	  （当然ながら、上記の段階の間に C++ コードが入る。）
	</para>
	<para>
	  これでプログラムにインタープリタを組み込み可能になった。次に使用方法を見ていく。
	</para>
      </section>
    </section>

    <section xml:id="tutorial.embedding.using_the_interpreter">
      <title>インタープリタを使用する</title>
      <para>
	すでに知っていることと思うが、Python のオブジェクトは参照カウントで管理されている。当然、Python C API の <type>PyObject</type> も参照カウンタを持っているが、違いがある。参照カウントは Python では完全に自動で行われているが、Python C API では<link xlink:href="http://docs.python.jp/2/c-api/refcounting.html">手動で</link>行う必要がある。これは厄介で、とりわけ C++ 例外が現れるコードで正しく取り扱うのが困難である。幸いにも Boost.Python には <classname linkend="header.handle_hpp">handle</classname> および <classname linkend="header.object_hpp">object</classname> クラステンプレートがあり、この処理を自動化できる。
      </para>

      <section xml:id="tutorial.embedding.using_the_interpreter.running_python_code">
	<title>Python のコードを起動する</title>
	<para>
	  Boost.Python は、C++ から Python のコードを起動する関数を 3 つ提供している。
	</para>
	<programlisting language="C++">object eval(str expression, object globals = object(), object locals = object())
object exec(str code, object globals = object(), object locals = object())
object exec_file(str filename, object globals = object(), object locals = object())</programlisting>
	<para>
	  <function>eval</function> は与えられた式を評価し結果の値を返す。<function>exec</function> は与えられたコード（典型的には文の集まり）を実行し結果を返す。<function>exec_file</function>は与えられたファイル内のコードを実行する。
	</para>
	<para>
	  <parameter>globals</parameter> と <parameter>locals</parameter> 引数は、コードを実行するコンテキストの <varname>globals</varname> と <varname>locals</varname> に相当する Python の辞書である。ほとんどの目的において、<package>__main__</package> モジュールの名前空間辞書を両方の引数に使用するとよい。
	</para>
	<para>
	  Boost.Python はモジュールをインポートする関数を提供する。
	</para>
	<programlisting language="C++">object import(str name)</programlisting>
	<para>
	  <function>import</function> は Python のモジュールをインポートし（潜在的には、はじめに起動しているプロセスに読み込む）、返す。
	</para>
	<para>
	  <package>__main__</package> モジュールをインポートし、その名前空間で Python のコードを走らせてみよう。
	</para>
	<programlisting language="C++">object main_module = import("__main__");
object main_namespace = main_module.attr("__dict__");

object ignored = exec("hello = file('hello.txt', 'w')\n"
                      "hello.write('Hello world!')\n"
                      "hello.close()",
                      main_namespace);</programlisting>
	<para>
	  このコードは現在のディレクトリに <filename>hello.txt</filename> という名前のファイルを作成し、プログラミングサークルでよく知られたフレーズを書き込む。
	</para>
      </section>

      <section xml:id="tutorial.embedding.using_the_interpreter.manipulating_python_objects">
	<title>Python のオブジェクトを操作する</title>
	<para>
	  Python オブジェクトを操作するクラスを用意したいことがよくある。しかしすでに上記や<link linkend="tutorial.object">前節</link>でそのようなクラスを見た。文字通りの名前を持つ <classname>object</classname> とその派生型である。またそれらを <classname>handle</classname> から構築できることも見た。以下の例を見ればより明らかだろう。
	</para>
	<programlisting language="C++">object main_module = import("__main__");
object main_namespace = main_module.attr("__dict__");
object ignored = exec("result = 5 ** 2", main_namespace);
int five_squared = extract&lt;int&gt;(main_namespace["result"]);</programlisting>
	<para>
	  <package>__main__</package> モジュールの名前空間に相当する辞書オブジェクトを作成している。次に 5 の 2 乗を結果の変数に代入し、この変数を辞書から読んでいる。同じ結果を得る他の方法としては代わりに <function>eval</function> を使用する方法があり、こちらは結果を直接返す。
	</para>
	<programlisting language="C++">object result = eval("5 ** 2");
int five_squared = extract&lt;int&gt;(result);</programlisting>
      </section>

      <section xml:id="tutorial.embedding.using_the_interpreter.exception_handling">
	<title>例外処理</title>
	<para>
	  Python の式を評価中に例外を送出した場合、<exceptionname linkend="error_already_set">error_already_set</exceptionname> が投げられる。
	</para>
	<programlisting language="C++">try
{
    object result = eval("5/0");
    // ここには絶対に来ない：
    int five_divided_by_zero = extract&lt;int&gt;(result);
}
catch(error_already_set const &amp;)
{
    // 何らかの方法で例外を処理する
}</programlisting>
	<para>
	  <exceptionname>error_already_set</exceptionname> 例外クラス自体は何の情報も持たない。送出された Python の例外について詳細を調べるには、catch 文内で Python C API の<link xlink:href="http://www.python.org/doc/api/exceptionHandling.html">例外処理関数</link>を使用する必要がある。これは単純に <function xlink:href="http://docs.python.jp/2/c-api/exceptions.html">PyErr_Print()</function> を呼び出して例外のトレースバックをコンソールへプリントするか、あるいは例外の型を<link xlink:href="http://docs.python.jp/2/c-api/exceptions.html#standardexceptions">標準の例外</link>と比較する程度となるだろう。
	</para>
	<programlisting language="C++">catch(error_already_set const &amp;)
{
    if (PyErr_ExceptionMatches(PyExc_ZeroDivisionError))
    {
        // ZeroDivisionError を個別に処理する
    }
    else
    {
        // 他のすべてのエラーを stderr にプリントする
        PyErr_Print();
    }
}</programlisting>
	<para>
	  （例外についてより多くの情報を取得するには、<link xlink:href="http://docs.python.jp/2/c-api/exceptions.html">このリスト</link>にある例外処理関数を使用する。）
	</para>
      </section>
    </section>
  </section>

  <section xml:id="tutorial.iterators">
    <title>イテレータ</title>
    <para>
      C++、特に STL においてイテレータはあらゆる場面で使用されている。Python にもイテレータがあるが、両者には大きな違いがある。
    </para>

    <variablelist>
      <varlistentry>
	<term>C++ のイテレータ：</term>
	<listitem>
	  <itemizedlist>
	    <listitem>
	      <para>C++ のイテレータは 5 つに分類される（ランダムアクセス、双方向、単方向、入力、出力）</para>
	    </listitem>
	    <listitem>
	      <para>再配置とアクセスの 2 種類の操作がある</para>
	    </listitem>
	    <listitem>
	      <para>範囲を表すのにイテレータの組（先頭と末尾）が必要</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>Python のイテレータ：</term>
	<listitem>
	  <itemizedlist>
	    <listitem>
	      <para>分類は 1 つしかない（単方向）</para>
	    </listitem>
	    <listitem>
	      <para>操作は 1 種類しかない（<code language="Python">next()</code>）</para>
	    </listitem>
	    <listitem>
	      <para>終了時に <exceptionname>StopIteration</exceptionname> 例外を投げる</para>
	    </listitem>
	  </itemizedlist>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>
      典型的な Python の走査プロトコルである <code language="Python">for y in x...</code> は以下のようである。
    </para>
    <programlisting language="C++">iter = x.__iter__()         # イテレータを取得する
try:
    while 1:
    y = iter.next()         # 各要素を取得する
    ...                     # y を処理する
except StopIteration: pass  # イテレータが尽きた</programlisting>
    <para>
      Boost.Python は、C++ のイテレータを Python のイテレータとして振舞うようにする機構をいくつか提供している。必要なことは C++ のイテレータから Python の走査プロトコルと互換性のある適切な <function>__iter__</function> 関数を用意することである。例えば、
    </para>
    <programlisting language="C++">object get_iterator = iterator&lt;vector&lt;int&gt; &gt;();
object iter = get_iterator(v);
object first = iter.next();</programlisting>
    <para>
      あるいは <classname>class_&lt;&gt;</classname> で以下のようにする。
    </para>
    <programlisting language="C++">.def("__iter__", iterator&lt;vector&lt;int&gt; &gt;())</programlisting>

    <section>
      <title>range</title>
      <para>
	<function>range</function> 関数を使用すると、Python の実践的なイテレータを作成できる。
      </para>
      <itemizedlist>
	<listitem>
	  <para><code language="C++">range(start, finish)</code></para>
	</listitem>
	<listitem>
	  <para><code language="C++">range&lt;Policies, Target&gt;(start, finish)</code></para>
	</listitem>
      </itemizedlist>
      <para>
	ここで <varname><replaceable>start</replaceable></varname> 、<varname><replaceable>finish</replaceable></varname> は以下のいずれかである。
      </para>
      <itemizedlist>
	<listitem>
	  <para>メンバデータポインタ</para>
	</listitem>
	<listitem>
	  <para>メンバ関数ポインタ</para>
	</listitem>
	<listitem>
	  <para>関数オブジェクト（<type>Target</type> 引数を使用）</para>
	</listitem>
      </itemizedlist>
    </section>

    <section>
      <title>iterator</title>
      <itemizedlist>
	<listitem>
	  <para><code language="C++">iterator&lt;T, Policies&gt;()</code></para>
	</listitem>
      </itemizedlist>
      <para>
	コンテナ <type>T</type> が与えられた場合、<classname>iterator</classname> は単に <code language="C++">&amp;T::begin</code> と <code language="C++">&amp;T::end</code> で <function>range</function> を呼び出すショートカットとなる。
      </para>
      <para>
	実際にやってみよう。以下はある仮説の粒子加速器のコードからの例である。
      </para>
      <programlisting language="Python">f = Field()
for x in f.pions:
    smash(x)
for y in f.bogons:
    count(y)</programlisting>
      <para>
	C++ のラッパは以下のようになるだろう。
      </para>
      <programlisting language="C++">class_&lt;F&gt;("Field")
    .property("pions", range(&amp;F::p_begin, &amp;F::p_end))
    .property("bogons", range(&amp;F::b_begin, &amp;F::b_end));</programlisting>
    </section>

    <section>
      <title>stl_input_iterator</title>
      <para>
	ここまで C++ のイテレータと範囲を Python へエクスポートする方法を見てきた。しかし時には違うこと、Python のシーケンスを STL アルゴリズムに渡したり、STL コンテナを初期化したいと考えることがある。Python のイテレータを STL のイテレータのように見せかける必要がある。これには <classname>stl_input_iterator&lt;&gt;</classname> を使用する。<methodname>std::list&lt;int&gt;::assign()</methodname> を Python へエクスポートする関数の実装方法を考えよう。
      </para>
      <programlisting language="C++">template&lt;typename T&gt;
void list_assign(std::list&lt;T&gt;&amp; l, object o) {
    // Python のシーケンスを STL の入力範囲に変換する
    stl_input_iterator&lt;T&gt; begin(o), end;
    l.assign(begin, end);
}

// list&lt;int&gt; のラッパの一部
class_&lt;std::list&lt;int&gt; &gt;("list_int")
    .def("assign", &amp;list_assign&lt;int&gt;)
    // ...
    ;</programlisting>
      <para>
	これで Python 側であらゆる整数シーケンスを <varname>list_int</varname> オブジェクトへ代入できる。
      </para>
      <programlisting language="C++">x = list_int();
x.assign([1,2,3,4,5])</programlisting>
    </section>
  </section>

  <section xml:id="tutorial.exception">
    <title>例外の変換</title>
    <para>
      C++ の例外はすべて Python コードとの境界で捕捉しなければならない。この境界は C++ が Python と接する地点である。Boost.Python は選択した標準の例外を変換してダウンする既定の例外ハンドラを提供する。
    </para>
    <programlisting language="Python">raise RuntimeError, 'unidentifiable C++ Exception'</programlisting>
    <para>
      ユーザがカスタムの変換器を提供してもよい。例えば、
      <footnote>
	<para>
	  訳注　『2001 年宇宙の旅』（“2001: A Space Odyssey” : Stanley Kubrick and Arthur C. Clarke, 1968）かな？
	</para>
      </footnote>
    </para>
    <programlisting language="C++">struct PodBayDoorException;
void translator(PodBayDoorException const&amp; x) {
    PyErr_SetString(PyExc_UserWarning, "I'm sorry Dave...");
}
BOOST_PYTHON_MODULE(kubrick) {
     register_exception_translator&lt;
          PodBayDoorException&gt;(translator);
     ...</programlisting>
  </section>

  <section xml:id="tutorial.techniques">
    <title>典型的なテクニック</title>
    <para>
      Boost.Python でコードをラップするのに使えるテクニックをいくつか紹介する。
    </para>

    <section xml:id="tutorial.techniques.creating_packages">
      <title>パッケージを作成する</title>
      <para>
	Python のパッケージは、ユーザに一定の機能を提供するモジュールの集まりである。パッケージの作成についてなじみがなければ、<link xlink:href="http://docs.python.jp/2/tutorial/modules.html">Python のチュートリアル</link>によい導入がある。
      </para>
      <para>
	しかし今は Boost.Python を使って C++ コードをラップしているのである。優れたパッケージインターフェイスをユーザに提供するにはどうすればよいだろうか？ 概念的なことを捉えるために例を使って考えよう。
      </para>
      <para>
	音に関する C++ ライブラリがあったとする。様々な形式で読み書きし、音データにフィルタをかける等するものとする。（便宜的に）名前を <package>sounds</package> としておこう。以下のような整理された C++ 名前空間の階層がすでにあるとする。
      </para>
      <literallayout>sounds::core
sounds::io
sounds::filters</literallayout>
      <para>
	Python ユーザに同じ階層を提示し、次のようなコードが書けるようにしたい。
      </para>
      <programlisting language="Python">import sounds.filters
sounds.filters.echo(...) # echo は C++ 関数</programlisting>
      <para>
	第 1 段階はラップコードを書くことである。以下のように Boost.Python を使って各モジュールを個別にエクスポートしなければならない。
      </para>
      <programlisting language="C++">/* ファイル core.cpp */
BOOST_PYTHON_MODULE(core)
{
    /* 名前空間 sounds::core 内のものをすべてエクスポートする */
    ...
}

/* ファイル io.cpp */
BOOST_PYTHON_MODULE(io)
{
    /* 名前空間 sounds::io 内のものをすべてエクスポートする */
    ...
}

/* ファイル filters.cpp */
BOOST_PYTHON_MODULE(filters)
{
    /* 名前空間 sounds::filters 内のものをすべてエクスポートする */
    ...
}</programlisting>
      <para>
	これらのファイルをコンパイルすると、<filename>core.pyd</filename> 、<filename>io.pyd</filename> および <filename>filters.pyd</filename> の Python 拡張が生成される。
      </para>
      <note>
	<para>
	  拡張子 <filename class="extension">.pyd</filename> は Python の拡張モジュールで使用するものであり、単純に共有ライブラリである。システムで既定のもの（Unix の場合は <filename class="extension">.so</filename> 、Windows の場合は <filename class="extension">.dll</filename>）を使用しても差し支えない。
	</para>
      </note>
      <para>
	次に以下の Python パッケージ用のディレクトリ構造を作成する。
      </para>
      <literallayout>sounds/
    __init__.py
    core.pyd
    filters.pyd
    io.pyd</literallayout>
      <para>
	ファイル <filename>__init__.py</filename> は、ディレクトリ <filename class="directory">sounds/</filename> が実際は Python のパッケージであることを Python に伝える。このファイルは空でもよいが、後述するようにここでマジックを行うことも可能だ。
      </para>
      <para>
	これでパッケージの準備が整った。ユーザがなすべきなのは、<filename class="directory">sounds</filename> を <link xlink:href="http://docs.python.jp/2/tutorial/modules.html#tut-searchpath">PYTHONPATH</link> に置いてインタープリタを起動することだけである。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>import sounds.io</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>import sounds.filters</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>sound = sounds.io.open('file.mp3')</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>new_sound = sounds.filters.echo(sound, 1.0)</userinput></screen>
      <para>
	何も問題ないようだが、どうだろう？
      </para>
      <para>
	これはパッケージ階層を作成する最も単純な方法だが、柔軟性がまるでない。<emphasis>純粋な</emphasis> Python の関数、例えば音オブジェクトに 3 つのフィルタを同時にかける関数を <package>filters</package> パッケージに追加したい場合はどうだろうか？ 確かにC++ で書いてエクスポートすれば可能だが、Python でやってみてはどうか。そうすれば拡張モジュールの再コンパイルが不要で、書くのも簡単である。
      </para>
      <para>
	こういった柔軟性が必要な場合、パッケージ階層を少しばかり複雑にしなければならない。まず拡張モジュール群の名前を変更しなければならない。
      </para>
      <programlisting language="C++">/* ファイル core.cpp */
BOOST_PYTHON_MODULE(_core)
{
    ...
    /* 名前空間 sounds::core 内のものをすべてエクスポートする */
}</programlisting>
      <para>
	モジュール名に下線を追加したことに注意していただきたい。ファイル名も <filename>_core.pyd</filename> に変わるはずである。他の拡張モジュールも同様である。これでパッケージ階層は以下のように変更された。
      </para>
      <literallayout>sounds/
    __init__.py
    core/
        __init__.py
        _core.pyd
    filters/
        __init__.py
        _filters.pyd
    io/
        __init__.py
        _io.pyd</literallayout>
      <para>
	各拡張モジュールについてディレクトリを作成し、それぞれに <filename>__init__.py</filename> を追加したことに注意していただきたい。しかしこれをこのままおいておくと、ユーザは次のような構文で <package>core</package> モジュールの関数にアクセスしなければならない。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>import sounds.core._core</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>sounds.core._core.foo(...)</userinput></screen>
      <para>
	これは望ましいことではない。しかしここで <filename>__init__.py</filename> のマジックが発動する。<filename>__init__.py</filename> の名前空間に持ち込まれるものはすべてユーザが直接アクセスできるのである。そういうわけで、名前空間全体を <filename>_core.pyd</filename> から <filename>core/__init__.py</filename> へ持ち込むだけでよい。つまり次のコード行を <filename>sounds/core/__init__.py</filename> へ追加する。
      </para>
      <programlisting language="Python">from _core import *</programlisting>
      <para>
	他のパッケージも同様に行う。これでユーザは以前のように拡張モジュール内と関数とクラスにアクセスできるようになる。
      </para>
      <screen language="C++"><prompt>&gt;&gt;&gt; </prompt><userinput>import sounds.filters</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>sounds.filters.echo(...)</userinput></screen>
      <para>
	他にも純粋な Python 関数をあらゆるモジュールに容易に追加できるという利点もある。この方法であればユーザには C++ 関数と Python 関数の見分けが付かない。では<emphasis>純粋な</emphasis> Python 関数 <function>echo_noise</function> を <package>filters</package> パッケージに追加しよう。この関数は与えられた <parameter>sound</parameter> オブジェクトに <function>echo</function> と <function>noise</function> の両方のフィルタを順番に適用する。<filename>sounds/filters/echo_noise.py</filename> という名前でファイルを作成して関数のコードを書く。
      </para>
      <programlisting language="Python">import _filters
def echo_noise(sound):
    s = _filters.echo(sound)
    s = _filters.noise(sound)
    return s</programlisting>
      <para>
	次に以下の行を <filename>sounds/filters/__init__.py</filename> に追加する。
      </para>
      <programlisting language="Python">from echo_noise import echo_noise</programlisting>
      <para>
	これで終わりだ。ユーザは、<package>filters</package> パッケージの他の関数と同様にこの関数にアクセスできる。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>import sounds.filters</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>sounds.filters.echo_noise(...)</userinput></screen>
    </section>

    <section xml:id="tutorial.techniques.extending_wrapped_objects_in_python">
      <title>ラップしたオブジェクトを Python で拡張する</title>
      <para>
	Python の柔軟性に感謝することだ。クラスを作成した後であってもメソッドを容易に追加できる。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>class C(object): pass</userinput>
<prompt>&gt;&gt;&gt; </prompt>
<prompt>&gt;&gt;&gt; </prompt><userinput># 普通の関数</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>def C_str(self): return 'C のインスタンス！'</userinput>
<prompt>&gt;&gt;&gt; </prompt>
<prompt>&gt;&gt;&gt; </prompt><userinput># メンバ関数に変更する</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>C.__str__ = C_str</userinput>
<prompt>&gt;&gt;&gt; </prompt>
<prompt>&gt;&gt;&gt; </prompt><userinput>c = C()</userinput>
<prompt>&gt;&gt;&gt; </prompt><userinput>print c</userinput>
<computeroutput>C のインスタンス！</computeroutput>
<prompt>&gt;&gt;&gt; </prompt><userinput>C_str(c)</userinput>
<computeroutput>C のインスタンス！</computeroutput></screen>
      <para>
	やはり Python は素晴らしい。
      </para>
      <para>
	同様のことが Boost.Python でラップしたクラスでもできる。C++ 側に <classname>point</classname> クラスがあるとする。
      </para>
      <programlisting language="C++">class point {...};

BOOST_PYTHON_MODULE(_geom)
{
    class_&lt;point&gt;("point")...;
}</programlisting>
      <para>
	前節『<link linkend="tutorial.techniques.creating_packages">パッケージを作成する</link>』のテクニックを使うと <filename>geom/__init__.py</filename> に直接コードが書ける。
      </para>
      <programlisting language="C++">from _geom import *

# 普通の関数
def point_str(self):
    return str((self.x, self.y))

# メンバ関数に変更する
point.__str__ = point_str</programlisting>
      <para>
	C++ で作成した<emphasis>すべての</emphasis> <classname>point</classname> インスタンスがこのメンバ関数を持つことになる！ このテクニックには色々と利点がある。
      </para>
      <itemizedlist>
	<listitem>
	  <para>追加する関数についてのコンパイル時間増加がゼロになる</para>
	</listitem>
	<listitem>
	  <para>メモリのフットプリントが見かけ上ゼロに削減する</para>
	</listitem>
	<listitem>
	  <para>再コンパイルの必要が最小になる</para>
	</listitem>
	<listitem>
	  <para>高速なプロトタイピング（インターフェイスを変更しないことが要求されている場合、コードを C++ に移動することが可能）</para>
	</listitem>
      </itemizedlist>
      <para>
	メタクラスを使って簡単な構文糖を追加することもできる。メソッドを他のクラスに「注入する」特別なメタクラスを作成しよう。
      </para>
      <programlisting language="Python"># Boost.Python がすべてのラップされたクラスに対して使用するもの。
# "point" の代わりに Boost でエクスポートしたあらゆるクラスが使用できる
BoostPythonMetaclass = point.__class__

class injector(object):
    class __metaclass__(BoostPythonMetaclass):
        def __init__(self, name, bases, dict):
            for b in bases:
                if type(b) not in (self, type):
                    for k,v in dict.items():
                        setattr(b,k,v)
            return type.__init__(self, name, bases, dict)

# point にいくつかメソッドを注入する
class more_point(injector, point):
    def __repr__(self):
        return 'Point(x=%s, y=%s)' % (self.x, self.y)
    def foo(self):
        print 'foo!'</programlisting>
      <para>
	これでどうなるか見てみよう。
      </para>
      <screen language="Python"><prompt>&gt;&gt;&gt; </prompt><userinput>print point()</userinput>
<computeroutput>Point(x=10, y=10)</computeroutput>
<prompt>&gt;&gt;&gt; </prompt><userinput>point().foo()</userinput>
<computeroutput>foo!</computeroutput></screen>
      <para>
	別の有用な考えとして、コンストラクタをファクトリ関数で置き換える方法がある。
      </para>
      <programlisting language="Python">_point = point

def point(x=0, y=0):
    return _point(x, y)</programlisting>
      <para>
	このような簡単な例ではつまらない感じがするが、多重定義や引数が多数あるコンストラクタにおいては優れた単純化となることが多い。キーワードサポートに対してコンパイル時間のオーバーヘッドがゼロ、メモリのフットプリントも事実上ゼロとなる。
      </para>
    </section>

    <section xml:id="tutorial.techniques.reducing_compiling_time">
      <title>コンパイルにかかる時間を短縮する</title>
      <para>
	多数のクラスをエクスポートすると、Boost.Python ラッパのコンパイルにかなりの時間がかかる。またメモリの消費量が容易に過大となる。これが問題となるのであれば、<classname>class_</classname> 定義を複数のファイルに分割するとよい。
      </para>
      <programlisting language="C++">/* ファイル point.cpp */
#include &lt;point.h&gt;
#include &lt;boost/python.hpp&gt;

void export_point()
{
    class_&lt;point&gt;("point")...;
}

/* ファイル triangle.cpp */
#include &lt;triangle.h&gt;
#include &lt;boost/python.hpp&gt;

void export_triangle()
{
    class_&lt;triangle&gt;("triangle")...;
}</programlisting>
      <para>
	そして <symbol>BOOST_PYTHON_MODULE</symbol> マクロを含んだ <filename>main.cpp</filename> ファイルを作成し、その中でエクスポート関数を呼び出す。
      </para>
      <programlisting language="C++">void export_point();
void export_triangle();

BOOST_PYTHON_MODULE(_geom)
{
    export_point();
    export_triangle();
}</programlisting>
      <para>
	これらのファイルをすべてコンパイル、リンクすると、通常の方法の場合と同じ結果が得られる。しかしメモリはまともな状態が維持できる。
      </para>
      <programlisting language="C++">#include &lt;boost/python.hpp&gt;
#include &lt;point.h&gt;
#include &lt;triangle.h&gt;

BOOST_PYTHON_MODULE(_geom)
{
    class_&lt;point&gt;("point")...;
    class_&lt;triangle&gt;("triangle")...;
}</programlisting>
      <para>
	C++ ライブラリ開発と Python へのエクスポートを同時に行っている場合にも、この方法を推奨する。クラス内で変更があっても、ラッパコード全体ではなく単一の cpp ファイルについてコンパイルが必要になるだけである。
      </para>
      <note>
	<para>
	  <link linkend="pyste">Pyste</link> を使ってクラスをエクスポートする場合は、<option>--multiple</option> オプションを覚えておくとよい。ここで示したように複数のファイルにラッパを生成する。
	</para>
      </note>
      <note>
	<para>
	  巨大なソースファイルをコンパイルしてエラーメッセージ「致命的なエラー C1204：コンパイラの制限：内部構造がオーバーフローしました。」が出た場合にも、この方法を推奨する。<link linkend="faq.fatal_error_c1204_compiler_limit">FAQ</link> に説明がある。
	</para>
      </note>
    </section>
  </section>
</article>

<?xml version="1.0" ?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:lang="ja" version="5.0" xml:id="v2.numeric">
  <title>boost/python/numeric.hpp</title>

  <section xml:id="v2.numeric.introduction">
    <title>はじめに</title>
    <para>
      Python の <classname xlink:href="http://www.python.org/dev/doc/devel/lib/typesmapping.html">array</classname> 型に対する <link linkend="v2.ObjectWrapper.TypeWrapper-concept">TypeWrapper</link> をエクスポートする。
    </para>
  </section>

  <section xml:id="v2.numeric.classes">
    <title>クラス</title>

    <section xml:id="v2.numeric.array-spec">
      <title><classname>array</classname> クラス</title>
      <para>
	<link xlink:href="http://numpy.sourceforge.net/numdoc/HTML/numdoc.htm">Numerical Python</link>
	<footnote>
	  <para>
	    訳注　現在は <link xlink:href="http://www.numpy.org/">NumPy</link> というパッケージに変わっています。Numeric モジュールは <package xlink:href="http://docs.scipy.org/doc/numpy/reference/routines.oldnumeric.html">numpy.oldnumeric</package> 、NumArray モジュールは <package xlink:href="http://docs.scipy.org/doc/numpy/reference/routines.numarray.html">numpy.numarray</package> という名前で互換モジュールが残されています。現在このクラスを使用する場合 NumPy をインストールした状態で後述の <function>array.set_module_and_type</function> 関数を使用して <classname>numpy.ndarray</classname> クラスを指示するのが一般的ですが、古いクラスとインターフェイスが完全に一致しているわけではありません。
	  </para>
	</footnote>
	の NumericおよびNumArrayモジュールの配列型へのアクセスを提供する。後述の関数群を除き、以下に定義するコンストラクタとメンバ関数のセマンティクスを完全に理解するには、<link linkend="v2.ObjectWrapper.TypeWrapper-concept">TypeWrapper</link> コンセプトの定義を読むことである。<classname>array</classname> は <classname linkend="v2.object.object-spec">object</classname> から公開派生しているので、<classname>object</classname> の公開インターフェイスは <classname>array</classname> のインスタンスにも当てはまる。
      </para>
      <para xml:id="v2.numeric.default_search">
	<package>numarray</package> モジュールが既定の位置にインストールされている場合、Python の対応する型として <classname>numarray.NDArray</classname> を既定で使用する。それ以外の場合、<classname>Numeric.ArrayType</classname> にフォールバックする。いずれの拡張モジュールもインストールされていない場合、ラップした関数を <classname>numeric::array</classname> 引数で多重定義したものはマッチすることなく、他で <classname>numeric::array</classname> を使用しようとすると適切な Python の例外を<glossterm baseform="raise">送出する</glossterm>。対応する Python の型は <methodname linkend="v2.numeric.array-spec-statics">set_module_and_type(...)</methodname> 静的関数で手動で設定できる。
      </para>

      <section xml:id="v2.array.array-spec-synopsis">
	<title><classname>array</classname> クラスの概要</title>
	<programlisting language="C++"><![CDATA[namespace boost { namespace python { namespace numeric
{
   class array : public object
   {
    public:
      object astype();
      template <class Type>
      object astype(Type const& type_);

      template <class Type>
      array new_(Type const& type_) const;

      template <class Sequence> 
      void resize(Sequence const& x);
      void resize(long x1);
      void resize(long x1, long x2);
      ...
      void resize(long x1, long x2,...long xn);

      template <class Sequence> 
      void setshape(Sequence const& x);
      void setshape(long x1);
      void setshape(long x1, long x2);
      ...
      void setshape(long x1, long x2,...long xn);

      template <class Indices, class Values>
      void put(Indices const& indices, Values const& values);

      template <class Sequence>
      object take(Sequence const& sequence, long axis = 0);

      template <class File>
      void tofile(File const& f) const;

      object factory();
      template <class Sequence>
      object factory(Sequence const&);
      template <class Sequence, class Typecode>
      object factory(Sequence const&, Typecode const&, bool copy = true, bool savespace = false);
      template <class Sequence, class Typecode, class Type>
      object factory(Sequence const&, Typecode const&, bool copy, bool savespace, Type const&);
      template <class Sequence, class Typecode, class Type, class Shape>
      object factory(Sequence const&, Typecode const&, bool copy, bool savespace, Type const&, Shape const&);

      template <class T1>
      explicit array(T1 const& x1);
      template <class T1, class T2>
      explicit array(T1 const& x1, T2 const& x2);
      ...
      template <class T1, class T2,...class Tn>
      explicit array(T1 const& x1, T2 const& x2,...Tn const& xn);

      static void set_module_and_type();
      static void set_module_and_type(char const* package_path = 0, char const* type_name = 0);
      static void get_module_name();

      object argmax(long axis=-1);

      object argmin(long axis=-1);

      object argsort(long axis=-1);

      void byteswap();

      object copy() const;

      object diagonal(long offset = 0, long axis1 = 0, long axis2 = 1) const;

      void info() const;

      bool is_c_array() const;
      bool isbyteswapped() const;
      void sort();
      object trace(long offset = 0, long axis1 = 0, long axis2 = 1) const;
      object type() const;
      char typecode() const;
      
      object getflat() const;
      long getrank() const;
      object getshape() const;
      bool isaligned() const;
      bool iscontiguous() const;
      long itemsize() const;
      long nelements() const;
      object nonzero() const;
   
      void ravel();
   
      object repeat(object const& repeats, long axis=0);
   
      void setflat(object const& flat);
   
      void swapaxes(long axis1, long axis2);
   
      str tostring() const;
   
      void transpose(object const& axes = object());
   
      object view() const;
  };
}}}]]></programlisting>
      </section>

      <section xml:id="v2.array.array-spec-observers">
	<title><classname>array</classname> クラスのオブザーバ関数</title>
	<orderedlist>
	  <listitem>
	    <methodsynopsis language="C++">
	      <type>object</type>
	      <methodname>factory</methodname>
	      <void/>
	    </methodsynopsis>
	    <methodsynopsis language="C++">
	      <modifier>template &lt;class Sequence&gt;</modifier>
	      <type>object</type>
	      <methodname>factory</methodname>
	      <methodparam>
		<type>Sequence const&amp;</type>
		<parameter/>
	      </methodparam>
	    </methodsynopsis>
	    <methodsynopsis language="C++">
	      <modifier>template &lt;class Sequence, class Typecode&gt;</modifier>
	      <type>object</type>
	      <methodname>factory</methodname>
	      <methodparam>
		<type>Sequence const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>Typecode const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>copy</parameter>
		<initializer>true</initializer>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>savespace</parameter>
		<initializer>false</initializer>
	      </methodparam>
	    </methodsynopsis>
	    <methodsynopsis language="C++">
	      <modifier>template &lt;class Sequence, class Typecode, class Type&gt;</modifier>
	      <type>object</type>
	      <methodname>factory</methodname>
	      <methodparam>
		<type>Sequence const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>Typecode const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>copy</parameter>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>savespace</parameter>
	      </methodparam>
	      <methodparam>
		<type>Type const&amp;</type>
		<parameter/>
	      </methodparam>
	    </methodsynopsis>
	    <methodsynopsis language="C++">
	      <modifier>template &lt;class Sequence, class Typecode, class Type, class Shape&gt;</modifier>
	      <type>object</type>
	      <methodname>factory</methodname>
	      <methodparam>
		<type>Sequence const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>Typecode const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>copy</parameter>
	      </methodparam>
	      <methodparam>
		<type>bool</type>
		<parameter>savespace</parameter>
	      </methodparam>
	      <methodparam>
		<type>Type const&amp;</type>
		<parameter/>
	      </methodparam>
	      <methodparam>
		<type>Shape const&amp;</type>
		<parameter/>
	      </methodparam>
	    </methodsynopsis>
	    <para>
	      これらの関数は内部的な配列型の <methodname>array()</methodname> 関数群にマップする。「<token>array</token>」という名前でないのは、メンバ関数をクラスと同じ名前で定義できないという C++ の制限による。
	    </para>
	  </listitem>

	  <listitem>
	    <methodsynopsis language="C++">
	      <modifier>template &lt;class Type&gt;</modifier>
	      <type>array</type>
	      <methodname>new_</methodname>
	      <methodparam>
		<type>Type const&amp;</type>
		<parameter/>
		<modifier>const</modifier>
	      </methodparam>
	    </methodsynopsis>
	    <para>
	      この関数は内部的な配列型の <methodname>new()</methodname> 関数にマップする。「<token>new</token>」という名前でないのは、C++ のキーワードだからである。
	    </para>
	  </listitem>
	</orderedlist>
      </section>

      <section xml:id="v2.array.array-spec-statics">
	<title><classname>array</classname> クラスの静的関数</title>
	<orderedlist>
	  <listitem>
	    <methodsynopsis language="C++">
	      <modifier>static</modifier>
	      <type>void</type>
	      <methodname>set_module_and_type</methodname>
	      <methodparam>
		<type>char const*</type>
		<parameter>package_path</parameter>
	      </methodparam>
	      <methodparam>
		<type>char const*</type>
		<parameter>type_name</parameter>
	      </methodparam>
	    </methodsynopsis>
	    <methodsynopsis language="C++">
	      <modifier>static</modifier>
	      <type>void</type>
	      <methodname>set_module_and_type</methodname>
	      <void/>
	    </methodsynopsis>
	    <variablelist spacing="compact">
	      <varlistentry>
		<term>要件：</term>
		<listitem>
		  <para>
		    <parameter>package_path</parameter> と <parameter>type_name</parameter> は、与えられた場合は <glossterm baseform="ntbs">ntbs</glossterm>。
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>効果：</term>
		<listitem>
		  <para>
		    第 1 形式は、名前 <parameter>type_name</parameter> の型を与えるモジュールのパッケージパスを <parameter>package_path</parameter> に設定する。第 2 形式は、<link linkend="v2.numeric.default_search">既定の探索動作</link>を復元する。対応する Python の型は必要となった最初の 1 回目、および以降の <methodname>set_module_and_type</methodname> 呼び出し後に必要となった最初の 1 回目のみ探索される。
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </listitem>

	  <listitem>
	    <methodsynopsis language="C++">
	      <modifier>static</modifier>
	      <type>std::string</type>
	      <methodname>get_module_name</methodname>
	      <void/>
	    </methodsynopsis>
	    <variablelist spacing="compact">
	      <varlistentry>
		<term>効果：</term>
		<listitem>
		  <para>
		    新しい <classname>numeric::array</classname> インスタンスが保持するクラスを含むモジュールの名前を返す。
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </listitem>
	</orderedlist>
      </section>
    </section>
  </section>

  <section xml:id="v2.array.examples">
    <title>例</title>
    <programlisting language="C++"><![CDATA[#include <boost/python/numeric.hpp>
#include <boost/python/tuple.hpp>

// 二次元配列の最初の要素を設定する
void set_first_element(numeric::array& y, double value)
{
    y[make_tuple(0,0)] = value;
}]]></programlisting>
  </section>
</section>
